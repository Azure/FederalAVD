{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "metadata": {
    "_generator": {
      "name": "bicep",
      "version": "0.40.2.10011",
      "templateHash": "4483080867000808962"
    },
    "name": "AVD Session Host Replacer Add-On",
    "description": "Deploys automated session host lifecycle management for Azure Virtual Desktop",
    "owner": "FederalAVD"
  },
  "parameters": {
    "location": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "Optional. The location for all resources. Defaults to deployment location."
      }
    },
    "tags": {
      "type": "object",
      "defaultValue": {},
      "metadata": {
        "description": "Optional. Tags for all resources."
      }
    },
    "functionAppNameOverride": {
      "type": "string",
      "defaultValue": "",
      "maxLength": 60,
      "metadata": {
        "description": "Optional. Explicit name for the Function App. If not provided, name is derived from host pool naming convention. Use this for brownfield deployments with non-standard host pool names. Must be globally unique and follow Azure naming rules (2-60 chars, alphanumeric and hyphens)."
      }
    },
    "storageAccountNameOverride": {
      "type": "string",
      "defaultValue": "",
      "maxLength": 24,
      "metadata": {
        "description": "Optional. Explicit name for the Storage Account (used by Function App). If not provided, name is derived from host pool naming convention. Use this for brownfield deployments with non-standard host pool names. Must be globally unique, 3-24 chars, lowercase alphanumeric only."
      }
    },
    "applicationInsightsNameOverride": {
      "type": "string",
      "defaultValue": "",
      "maxLength": 260,
      "metadata": {
        "description": "Optional. Explicit name for the Application Insights instance. If not provided, name is derived from shared naming convention. Use this for brownfield deployments with non-standard naming. Must follow Azure naming rules (1-260 chars, alphanumeric, hyphens, underscores, parentheses, periods)."
      }
    },
    "virtualMachineNameConvOverride": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Naming convention override for session host virtual machines. If not provided, derived from host pool naming convention. Use format with SHNAME token (e.g., \"vm-SHNAME\" or \"SHNAME-vm\"). SHNAME will be replaced with session host name prefix + index."
      }
    },
    "diskNameConvOverride": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Naming convention override for session host OS disks. If not provided, derived from host pool naming convention. Use format with SHNAME token (e.g., \"disk-SHNAME\" or \"SHNAME-disk\")."
      }
    },
    "networkInterfaceNameConvOverride": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Naming convention override for session host network interfaces. If not provided, derived from host pool naming convention. Use format with SHNAME token (e.g., \"nic-SHNAME\" or \"SHNAME-nic\")."
      }
    },
    "availabilitySetNameConvOverride": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Naming convention override for availability sets. If not provided, derived from host pool naming convention. Use format with ## token for index (e.g., \"avset-##\" or \"##-avset\")."
      }
    },
    "sessionHostReplacerUserAssignedIdentityResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The resource ID of the User-Assigned Managed Identity with Microsoft Graph API permissions (Device.ReadWrite.All, DeviceManagementManagedDevices.ReadWrite.All). If not provided, the function app will use its system-assigned managed identity."
      }
    },
    "appServicePlanResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The resource ID of an existing App Service Plan for the function app. If not provided, a new plan will be deployed."
      }
    },
    "appServicePlanSku": {
      "type": "string",
      "defaultValue": "PremiumV3_P0v3",
      "allowedValues": [
        "PremiumV3_P0v3",
        "PremiumV3_P1v3",
        "PremiumV3_P2v3",
        "PremiumV3_P3v3"
      ],
      "metadata": {
        "description": "Optional. The SKU for the App Service Plan. Only applies if appServicePlanResourceId is not provided. Default is P0v3 for cost optimization."
      }
    },
    "zoneRedundant": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Whether to deploy the App Service Plan with zone redundancy. Only applies if appServicePlanResourceId is not provided. Default is false."
      }
    },
    "privateEndpoint": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Enable private endpoints for function app and storage. Default is false."
      }
    },
    "privateEndpointSubnetResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The subnet resource ID for private endpoints. Required if privateEndpoint is true."
      }
    },
    "functionAppDelegatedSubnetResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The subnet resource ID for the function app VNet integration. Required if privateEndpoint is true."
      }
    },
    "azureBlobPrivateDnsZoneResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Private DNS Zone resource IDs. Required if privateEndpoint is true."
      }
    },
    "azureFunctionAppPrivateDnsZoneResourceId": {
      "type": "string",
      "defaultValue": ""
    },
    "azureTablePrivateDnsZoneResourceId": {
      "type": "string",
      "defaultValue": ""
    },
    "encryptionKeyVaultResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The resource ID of the Key Vault for encryption. Required if keyManagementStorageAccounts is set to Customer."
      }
    },
    "keyManagementStorageAccounts": {
      "type": "string",
      "defaultValue": "MicrosoftManaged",
      "allowedValues": [
        "MicrosoftManaged",
        "CustomerManaged",
        "CustomerManagedHSM"
      ],
      "metadata": {
        "description": "Optional. Key management solution for storage accounts. Options: Platform, Customer."
      }
    },
    "logAnalyticsWorkspaceResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Log Analytics Workspace resource ID for Application Insights."
      }
    },
    "privateLinkScopeResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Private Link Scope resource ID for Application Insights."
      }
    },
    "credentialsKeyVaultResourceId": {
      "type": "string",
      "metadata": {
        "description": "Required. The resource ID of the Key Vault containing session host credential secrets (VirtualMachineAdminPassword, VirtualMachineAdminUserName, DomainJoinUserPassword, DomainJoinUserPrincipalName)."
      }
    },
    "sessionHostTemplateSpecResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The resource ID of the Template Spec version for session host deployments. If not provided, a new template spec will be created."
      }
    },
    "templateSpecName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The name of the Template Spec to create. Defaults to hostpool-based naming."
      }
    },
    "templateSpecVersion": {
      "type": "string",
      "defaultValue": "1.0.0",
      "metadata": {
        "description": "Optional. The version of the Template Spec. Default is 1.0.0."
      }
    },
    "timerSchedule": {
      "type": "string",
      "defaultValue": "0 0,30 * * * *",
      "metadata": {
        "description": "Optional. Timer schedule for the function app (NCrontab format: {second} {minute} {hour} {day} {month} {day-of-week}). Default runs every 30 minutes starting at minute 0 (runs at :00 and :30). To stagger across deployments, vary the minute (e.g., \"0 15,45 * * * *\" runs at :15 and :45 past each hour). For half-hourly execution during specific hours, use \"0 0,30 8-17 * * 1-5\" for 8 AM to 5 PM weekdays. The UI form automatically generates the correct format when you select hours and start minute."
      }
    },
    "deployWorkbook": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Whether to deploy the Azure Monitor Workbook dashboard. Set to true for the first deployment or when updating the workbook. Set to false for subsequent deployments in the same subscription to avoid conflicts. Default is true."
      }
    },
    "workbookLocation": {
      "type": "string",
      "defaultValue": "[parameters('location')]",
      "metadata": {
        "description": "Optional. The Azure region for the centralized workbook deployment. Defaults to the function app location. The workbook location does not affect its ability to query cross-region Application Insights instances."
      }
    },
    "replacementMode": {
      "type": "string",
      "defaultValue": "SideBySide",
      "allowedValues": [
        "SideBySide",
        "DeleteFirst"
      ],
      "metadata": {
        "description": "Optional. Replacement mode strategy. SideBySide: Adds new hosts before deleting old ones (higher capacity during updates, zero downtime). DeleteFirst: Deletes idle hosts before adding replacements (lower cost, temporary capacity reduction). Default is SideBySide."
      }
    },
    "drainGracePeriodHours": {
      "type": "int",
      "defaultValue": 24,
      "minValue": 1,
      "maxValue": 168,
      "metadata": {
        "description": "Optional. The grace period in hours after draining before deleting session hosts WITH active sessions. Default is 24 hours."
      }
    },
    "minimumDrainMinutes": {
      "type": "int",
      "defaultValue": 15,
      "minValue": 0,
      "maxValue": 120,
      "metadata": {
        "description": "Optional. Minimum drain time in minutes for session hosts with ZERO sessions before deletion. With hourly scheduling: 0=current run, 1-60=next run (~1hr), 61-120=second run (~2hrs). Values >0 provide safety buffer for API lag, race conditions, and admin intervention. Default is 15 minutes."
      }
    },
    "minimumCapacityPercentage": {
      "type": "int",
      "defaultValue": 80,
      "minValue": 20,
      "maxValue": 100,
      "metadata": {
        "description": "Optional. Safety floor: minimum percentage of target capacity to maintain during DeleteFirst mode. Deletions are capped to prevent dropping below this threshold. Higher values = more conservative (e.g., 80% keeps more hosts running), lower values = more aggressive (e.g., 50% allows faster replacement). Only applies when replacementMode is DeleteFirst. Default is 80%."
      }
    },
    "maxDeletionsPerCycle": {
      "type": "int",
      "defaultValue": 50,
      "minValue": 1,
      "maxValue": 100,
      "metadata": {
        "description": "Optional. Maximum number of hosts to delete and deploy per cycle in DeleteFirst mode. Controls the pace of replacements - function deletes this many idle hosts, then deploys the same number of replacements. Lower values = slower, safer updates. Only applies when replacementMode is DeleteFirst. Default is 5."
      }
    },
    "minimumHostIndex": {
      "type": "int",
      "defaultValue": 1,
      "minValue": 0,
      "maxValue": 999,
      "metadata": {
        "description": "Optional. Minimum host index for hostname numbering. Gap-filling logic starts from this index when deploying new hosts (e.g., 1 allows host01, host02; 10 allows host10, host11). Applies to both DeleteFirst and SideBySide modes. Default is 1."
      }
    },
    "enableShutdownRetention": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Enable shutdown retention for replaced session hosts in SideBySide mode. When enabled, old session hosts are shutdown (deallocated) instead of deleted, allowing for rollback. They are automatically deleted after the retention period expires. Only applies when replacementMode is SideBySide. Default is false."
      }
    },
    "shutdownRetentionDays": {
      "type": "int",
      "defaultValue": 3,
      "minValue": 1,
      "maxValue": 7,
      "metadata": {
        "description": "Optional. Number of days to retain shutdown session hosts before automatic deletion in SideBySide mode. Provides rollback window in case issues are discovered with new hosts. Only applies when replacementMode is SideBySide and enableShutdownRetention is true. Default is 3 days."
      }
    },
    "targetSessionHostCount": {
      "type": "int",
      "defaultValue": 0,
      "minValue": 0,
      "maxValue": 1000,
      "metadata": {
        "description": "Required. The target number of session hosts to maintain in the host pool. Set to 0 for auto-detect mode: the function will automatically maintain whatever count exists when a replacement cycle begins, allowing you to manually scale between image updates."
      }
    },
    "fixSessionHostTags": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Whether to fix session host tags during execution. Default is true."
      }
    },
    "includePreExistingSessionHosts": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Whether to include pre-existing session hosts in automation. Default is true."
      }
    },
    "tagIncludeInAutomation": {
      "type": "string",
      "defaultValue": "IncludeInAutoReplace",
      "metadata": {
        "description": "Optional. Tag name to identify session hosts included in automation. Default is IncludeInAutoReplace."
      }
    },
    "tagDeployTimestamp": {
      "type": "string",
      "defaultValue": "AutoReplaceDeployTimestamp",
      "metadata": {
        "description": "Optional. Tag name for deploy timestamp. Default is AutoReplaceDeployTimestamp."
      }
    },
    "tagPendingDrainTimestamp": {
      "type": "string",
      "defaultValue": "AutoReplacePendingDrainTimestamp",
      "metadata": {
        "description": "Optional. Tag name for pending drain timestamp. Default is AutoReplacePendingDrainTimestamp."
      }
    },
    "tagShutdownTimestamp": {
      "type": "string",
      "defaultValue": "AutoReplaceShutdownTimestamp",
      "metadata": {
        "description": "Optional. Tag name for shutdown timestamp in SideBySide mode with shutdown retention. Default is AutoReplaceShutdownTimestamp."
      }
    },
    "tagScalingPlanExclusionTag": {
      "type": "string",
      "defaultValue": "ScalingPlanExclusion",
      "metadata": {
        "description": "Optional. Tag name for scaling plan exclusion. Default is ScalingPlanExclusion."
      }
    },
    "removeEntraDevice": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Whether to remove Entra ID device records when deleting session hosts. Default is true."
      }
    },
    "removeIntuneDevice": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Whether to remove Intune device records when deleting session hosts. Default is true."
      }
    },
    "enableProgressiveScaleUp": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Enable progressive scale-up with percentage-based batching for deployments. When enabled, the function will start with a small percentage of needed hosts and gradually increase. Default is false."
      }
    },
    "initialDeploymentPercentage": {
      "type": "int",
      "defaultValue": 20,
      "minValue": 1,
      "maxValue": 100,
      "metadata": {
        "description": "Optional. Initial deployment size as percentage of total needed hosts. Used when progressive scale-up is enabled. Default is 10%."
      }
    },
    "scaleUpIncrementPercentage": {
      "type": "int",
      "defaultValue": 40,
      "minValue": 5,
      "maxValue": 50,
      "metadata": {
        "description": "Optional. Percentage increment added after each successful deployment run. Used when progressive scale-up is enabled. Default is 20%."
      }
    },
    "maxDeploymentBatchSize": {
      "type": "int",
      "defaultValue": 100,
      "minValue": 1,
      "maxValue": 1000,
      "metadata": {
        "description": "Optional. Maximum number of hosts to deploy per run in SideBySide mode. Controls the pace of new deployments - function adds this many new hosts in parallel before deleting old ones. Lower values = slower rollout, higher values = faster but more resource-intensive. Only applies when replacementMode is SideBySide. Default is 100."
      }
    },
    "successfulRunsBeforeScaleUp": {
      "type": "int",
      "defaultValue": 1,
      "minValue": 1,
      "maxValue": 5,
      "metadata": {
        "description": "Optional. Number of consecutive successful deployment runs required before increasing the deployment percentage. Default is 1."
      }
    },
    "replaceSessionHostOnNewImageVersionDelayDays": {
      "type": "int",
      "defaultValue": 0,
      "minValue": 0,
      "maxValue": 30,
      "metadata": {
        "description": "Optional. Delay in days before replacing session hosts after a new image version is detected. Only used when replacementMode is ImageVersion. Default is 0 days."
      }
    },
    "allowImageVersionRollback": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Allow replacement of session hosts even if their current image version is newer than the latest available version. When false (default), session hosts with newer versions will not be replaced to prevent unintended rollbacks. Only used when replacementMode is ImageVersion."
      }
    },
    "virtualMachinesResourceGroupId": {
      "type": "string",
      "metadata": {
        "description": "Required. The resource ID of the resource group where virtual machines are deployed."
      }
    },
    "hostPoolResourceId": {
      "type": "string",
      "metadata": {
        "description": "Required. The resource ID of the AVD Host Pool where session hosts will be registered."
      }
    },
    "sessionHostNamePrefix": {
      "type": "string",
      "metadata": {
        "description": "Required. The VM name prefix used for session hosts."
      }
    },
    "sessionHostNameIndexLength": {
      "type": "int",
      "defaultValue": 2,
      "metadata": {
        "description": "Optional. VM name index length for padding."
      }
    },
    "imagePublisher": {
      "type": "string",
      "defaultValue": "MicrosoftWindowsDesktop",
      "metadata": {
        "description": "Optional. Publisher of the marketplace image. Default is MicrosoftWindowsDesktop."
      }
    },
    "imageOffer": {
      "type": "string",
      "defaultValue": "windows-11",
      "metadata": {
        "description": "Optional. Offer of the marketplace image. Default is windows-11."
      }
    },
    "imageSku": {
      "type": "string",
      "defaultValue": "win11-25h2-avd",
      "metadata": {
        "description": "Optional. SKU of the marketplace image. Default is win11-25h2-avd."
      }
    },
    "customImageResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The resource ID of a custom image to use for session hosts. If provided, imagePublisher, imageOffer, and imageSku are ignored."
      }
    },
    "virtualMachineSize": {
      "type": "string",
      "defaultValue": "Standard_D4ads_v6",
      "metadata": {
        "description": "Optional. The VM size for session hosts."
      }
    },
    "virtualMachineSubnetResourceId": {
      "type": "string",
      "metadata": {
        "description": "Required. The subnet resource ID for session host NICs."
      }
    },
    "identitySolution": {
      "type": "string",
      "defaultValue": "ActiveDirectoryDomainServices",
      "allowedValues": [
        "ActiveDirectoryDomainServices",
        "EntraDomainServices",
        "EntraKerberos-Hybrid",
        "EntraKerberos-CloudOnly",
        "EntraId"
      ],
      "metadata": {
        "description": "Optional. The identity solution for session hosts."
      }
    },
    "domainName": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The domain name for domain join."
      }
    },
    "ouPath": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. The OU path for domain join."
      }
    },
    "intuneEnrollment": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Enable Intune enrollment for Entra joined VMs."
      }
    },
    "timeZone": {
      "type": "string",
      "defaultValue": "Eastern Standard Time",
      "metadata": {
        "description": "Optional. The time zone for session hosts."
      }
    },
    "availability": {
      "type": "string",
      "defaultValue": "None",
      "allowedValues": [
        "AvailabilityZones",
        "AvailabilitySets",
        "None"
      ],
      "metadata": {
        "description": "Optional. Availability configuration."
      }
    },
    "availabilityZones": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Optional. Availability zones for session hosts."
      }
    },
    "securityType": {
      "type": "string",
      "defaultValue": "TrustedLaunch",
      "allowedValues": [
        "Standard",
        "TrustedLaunch",
        "ConfidentialVM"
      ],
      "metadata": {
        "description": "Optional. Security type for session hosts."
      }
    },
    "secureBootEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Enable secure boot."
      }
    },
    "vTpmEnabled": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Enable vTPM."
      }
    },
    "integrityMonitoring": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Enable integrity monitoring."
      }
    },
    "encryptionAtHost": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Enable encryption at host."
      }
    },
    "confidentialVMOSDiskEncryption": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Enable confidential VM OS disk encryption."
      }
    },
    "diskSizeGB": {
      "type": "int",
      "defaultValue": 0,
      "metadata": {
        "description": "Optional. OS disk size in GB. 0 uses image default."
      }
    },
    "diskSku": {
      "type": "string",
      "defaultValue": "Premium_LRS",
      "allowedValues": [
        "Premium_LRS",
        "StandardSSD_LRS",
        "Standard_LRS"
      ],
      "metadata": {
        "description": "Optional. OS disk SKU."
      }
    },
    "enableAcceleratedNetworking": {
      "type": "bool",
      "defaultValue": true,
      "metadata": {
        "description": "Optional. Enable accelerated networking."
      }
    },
    "enableIPv6": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Enable IPv6 dynamic private IP on session hosts."
      }
    },
    "enableMonitoring": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. Enable monitoring with Azure Monitor Agent."
      }
    },
    "diskEncryptionSetResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Existing disk encryption set resource ID."
      }
    },
    "avdInsightsDataCollectionRulesResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. AVD Insights data collection rules resource ID."
      }
    },
    "vmInsightsDataCollectionRulesResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. VM Insights data collection rules resource ID."
      }
    },
    "dataCollectionEndpointResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Data collection endpoint resource ID."
      }
    },
    "fslogixConfigureSessionHosts": {
      "type": "bool",
      "defaultValue": false,
      "metadata": {
        "description": "Optional. FSLogix configuration - enable session host configuration."
      }
    },
    "fslogixContainerType": {
      "type": "string",
      "defaultValue": "ProfileContainer",
      "allowedValues": [
        "ProfileContainer",
        "OfficeContainer",
        "ProfileContainer OfficeContainer",
        "ProfileContainer CloudCache",
        "OfficeContainer CloudCache",
        "ProfileContainer OfficeContainer CloudCache"
      ],
      "metadata": {
        "description": "Optional. FSLogix container type."
      }
    },
    "fslogixSizeInMBs": {
      "type": "int",
      "defaultValue": 30720,
      "metadata": {
        "description": "Optional. FSLogix container size in MBs."
      }
    },
    "fslogixStorageService": {
      "type": "string",
      "defaultValue": "AzureFiles",
      "allowedValues": [
        "AzureFiles",
        "AzureNetAppFiles"
      ],
      "metadata": {
        "description": "Optional. FSLogix storage service."
      }
    },
    "fslogixLocalStorageAccountResourceIds": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Optional. FSLogix local storage account resource IDs."
      }
    },
    "fslogixRemoteStorageAccountResourceIds": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Optional. FSLogix remote storage account resource IDs."
      }
    },
    "fslogixLocalNetAppVolumeResourceIds": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Optional. FSLogix local NetApp volume resource IDs."
      }
    },
    "fslogixRemoteNetAppVolumeResourceIds": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Optional. FSLogix remote NetApp volume resource IDs."
      }
    },
    "fslogixOSSGroups": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Optional. FSLogix OSS groups for sharding."
      }
    },
    "avdAgentsDSCPackage": {
      "type": "string",
      "defaultValue": "Configuration_1.0.03266.1110.zip",
      "metadata": {
        "description": "Optional. AVD Agents DSC package name or URL."
      }
    },
    "artifactsContainerUri": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Artifacts container URI for custom scripts."
      }
    },
    "artifactsUserAssignedIdentityResourceId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Optional. Artifacts user assigned identity resource ID."
      }
    },
    "sessionHostCustomizations": {
      "type": "array",
      "defaultValue": [],
      "metadata": {
        "description": "Optional. Session host customizations array."
      }
    }
  },
  "variables": {
    "$fxv#0": {
      "AzureCloud": {
        "australiacentral": {
          "abbreviation": "auc",
          "recoveryServicesGeo": "acl"
        },
        "australiacentral2": {
          "abbreviation": "auc2",
          "recoveryServicesGeo": "acl2"
        },
        "australiaeast": {
          "abbreviation": "aue",
          "recoveryServicesGeo": "ae"
        },
        "australiasoutheast": {
          "abbreviation": "ause",
          "recoveryServicesGeo": "ase"
        },
        "brazilsouth": {
          "abbreviation": "brs",
          "recoveryServicesGeo": "brs"
        },
        "brazilsoutheast": {
          "abbreviation": "brse",
          "recoveryServicesGeo": "bse"
        },
        "canadacentral": {
          "abbreviation": "cac",
          "recoveryServicesGeo": "cnc"
        },
        "canadaeast": {
          "abbreviation": "cae",
          "recoveryServicesGeo": "cne"
        },
        "centralindia": {
          "abbreviation": "inc",
          "recoveryServicesGeo": "inc"
        },
        "centralus": {
          "abbreviation": "usc",
          "recoveryServicesGeo": "cus"
        },
        "eastasia": {
          "abbreviation": "ase",
          "recoveryServicesGeo": "ea"
        },
        "eastus": {
          "abbreviation": "use",
          "recoveryServicesGeo": "eus"
        },
        "eastus2": {
          "abbreviation": "use2",
          "recoveryServicesGeo": "eus2"
        },
        "francecentral": {
          "abbreviation": "frc",
          "recoveryServicesGeo": "frc"
        },
        "francesouth": {
          "abbreviation": "frs",
          "recoveryServicesGeo": "frs"
        },
        "germanynorth": {
          "abbreviation": "den",
          "recoveryServicesGeo": "gn"
        },
        "germanywestcentral": {
          "abbreviation": "dewc",
          "recoveryServicesGeo": "gwc"
        },
        "israelcentral": {
          "abbreviation": "ilc",
          "recoveryServicesGeo": "ilc"
        },
        "italynorth": {
          "abbreviation": "itn",
          "recoveryServicesGeo": "itn"
        },
        "japaneast": {
          "abbreviation": "jpe",
          "recoveryServicesGeo": "jpe"
        },
        "japanwest": {
          "abbreviation": "jpw",
          "recoveryServicesGeo": "jpw"
        },
        "jioindiacentral": {
          "abbreviation": "injc",
          "recoveryServicesGeo": "jic"
        },
        "jioindiawest": {
          "abbreviation": "injw",
          "recoveryServicesGeo": "jiw"
        },
        "koreacentral": {
          "abbreviation": "krc",
          "recoveryServicesGeo": "krc"
        },
        "koreasouth": {
          "abbreviation": "krs",
          "recoveryServicesGeo": "krs"
        },
        "northcentralus": {
          "abbreviation": "usnc",
          "recoveryServicesGeo": "ncus"
        },
        "northeurope": {
          "abbreviation": "eun",
          "recoveryServicesGeo": "ne"
        },
        "norwayeast": {
          "abbreviation": "noe",
          "recoveryServicesGeo": "nwe"
        },
        "norwaywest": {
          "abbreviation": "now",
          "recoveryServicesGeo": "nww"
        },
        "polandcentral": {
          "abbreviation": "plc",
          "recoveryServicesGeo": "plc"
        },
        "qatarcentral": {
          "abbreviation": "qac",
          "recoveryServicesGeo": "qac"
        },
        "southafricanorth": {
          "abbreviation": "zan",
          "recoveryServicesGeo": "san"
        },
        "southafricawest": {
          "abbreviation": "zaw",
          "recoveryServicesGeo": "saw"
        },
        "southcentralus": {
          "abbreviation": "ussc",
          "recoveryServicesGeo": "scus"
        },
        "southeastasia": {
          "abbreviation": "asse",
          "recoveryServicesGeo": "sea"
        },
        "southindia": {
          "abbreviation": "ins",
          "recoveryServicesGeo": "ins"
        },
        "swedencentral": {
          "abbreviation": "sec",
          "recoveryServicesGeo": "sdc"
        },
        "switzerlandnorth": {
          "abbreviation": "chn",
          "recoveryServicesGeo": "szn"
        },
        "switzerlandwest": {
          "abbreviation": "chw",
          "recoveryServicesGeo": "szw"
        },
        "uaecentral": {
          "abbreviation": "aec",
          "recoveryServicesGeo": "uac"
        },
        "uaenorth": {
          "abbreviation": "aen",
          "recoveryServicesGeo": "uan"
        },
        "uksouth": {
          "abbreviation": "uks",
          "recoveryServicesGeo": "uks"
        },
        "ukwest": {
          "abbreviation": "ukw",
          "recoveryServicesGeo": "ukw"
        },
        "westcentralus": {
          "abbreviation": "uswc",
          "recoveryServicesGeo": "wcus"
        },
        "westeurope": {
          "abbreviation": "euw",
          "recoveryServicesGeo": "we"
        },
        "westindia": {
          "abbreviation": "inw",
          "recoveryServicesGeo": "inw"
        },
        "westus": {
          "abbreviation": "usw",
          "recoveryServicesGeo": "wus"
        },
        "westus2": {
          "abbreviation": "usw2",
          "recoveryServicesGeo": "wus2"
        },
        "westus3": {
          "abbreviation": "usw3",
          "recoveryServicesGeo": "wus3"
        }
      },
      "AzureUSGovernment": {
        "usdodcentral": {
          "abbreviation": "dodc",
          "recoveryServicesGeo": "udc"
        },
        "usdodeast": {
          "abbreviation": "dode",
          "recoveryServicesGeo": "ude"
        },
        "usgovarizona": {
          "abbreviation": "az",
          "recoveryServicesGeo": "uga"
        },
        "usgovtexas": {
          "abbreviation": "tx",
          "recoveryServicesGeo": "ugt"
        },
        "usgovvirginia": {
          "abbreviation": "va",
          "recoveryServicesGeo": "ugv"
        }
      },
      "other": {
        "north": {
          "abbreviation": "no"
        },
        "east": {
          "abbreviation": "ea"
        },
        "south": {
          "abbreviation": "so"
        },
        "west": {
          "abbreviation": "we"
        },
        "central": {
          "abbreviation": "ce"
        },
        "northcentral": {
          "abbreviation": "noce"
        },
        "eastcentral": {
          "abbreviation": "wece"
        },
        "southcentral": {
          "abbreviation": "soce"
        },
        "westcentral": {
          "abbreviation": "wece"
        }
      }
    },
    "$fxv#1": {
      "applicationInsights": "appi",
      "appServicePlans": "asp",
      "availabilitySets": "as",
      "computeGalleries": "gal",
      "dataCollectionEndpoints": "dce",
      "dataCollectionRules": "dcr",
      "desktopApplicationGroups": "vddag",
      "diskAccesses": "da",
      "remoteApplicationGroups": "vdrag",
      "diskEncryptionSets": "des",
      "functionApps": "fa",
      "hostPools": "vdpool",
      "keyVaults": "kv",
      "logAnalyticsWorkspaces": "law",
      "natGateways": "ng",
      "netAppAccounts": "naa",
      "netAppCapacityPools": "nacp",
      "networkInterfaces": "nic",
      "networkSecurityGroups": "nsg",
      "osdisks": "osdisk",
      "privateEndpoints": "pe",
      "privateLinkScopes": "pls",
      "publicIPAddresses": "pip",
      "recoveryServicesVaults": "rsv",
      "resourceGroups": "rg",
      "routeTables": "rt",
      "scalingPlans": "vdscaling",
      "storageAccounts": "sa",
      "templateSpecs": "ts",
      "userAssignedIdentities": "uai",
      "virtualMachines": "vm",
      "workbooks": "wb",
      "workspaces": "vdws",
      "imageDefinitions": "vmid"
    },
    "$fxv#10": "# SessionHostReplacer Lifecycle Module\r\n# Contains session host removal, shutdown retention, and drain notification functions\r\n\r\n# Import Core and DeviceCleanup utilities\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Core.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.DeviceCleanup.psm1\" -Force\r\n\r\n#Region Session Host Lifecycle\r\n\r\nfunction Remove-ExpiredShutdownVMs {\r\n    <#\r\n    .SYNOPSIS\r\n    Removes VMs that have been shutdown for longer than the retention period.\r\n    \r\n    .DESCRIPTION\r\n    Checks for VMs tagged with shutdown timestamp and deletes them if they have exceeded\r\n    the configured retention period. Also removes associated Entra ID and Intune devices.\r\n    \r\n    .PARAMETER ARMToken\r\n    ARM access token for Azure Resource Manager API calls\r\n    \r\n    .PARAMETER GraphToken\r\n    Graph access token for Entra ID and Intune API calls\r\n    \r\n    .PARAMETER ShutdownRetentionDays\r\n    Number of days to retain shutdown VMs before deletion\r\n    \r\n    .OUTPUTS\r\n    PSCustomObject with counts of cleaned up and retained VMs\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter()]\r\n        [string] $GraphToken,\r\n        [Parameter()]\r\n        [array] $CachedVMs,\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n        [Parameter()]\r\n        [int] $ShutdownRetentionDays = (Read-FunctionAppSetting ShutdownRetentionDays),\r\n        [Parameter()]\r\n        [string] $TagShutdownTimestamp = (Read-FunctionAppSetting Tag_ShutdownTimestamp),\r\n        [Parameter()]\r\n        [string] $VirtualMachinesSubscriptionId = (Read-FunctionAppSetting VirtualMachinesSubscriptionId),\r\n        [Parameter()]\r\n        [string] $VirtualMachinesResourceGroupName = (Read-FunctionAppSetting VirtualMachinesResourceGroupName),\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n        [Parameter()]\r\n        [string] $HostPoolResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n        [Parameter()]\r\n        [bool] $RemoveEntraDevice = (Read-FunctionAppSetting RemoveEntraDevice -AsBoolean),\r\n        [Parameter()]\r\n        [bool] $RemoveIntuneDevice = (Read-FunctionAppSetting RemoveIntuneDevice -AsBoolean),\r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    Write-LogEntry -Message \"Checking for shutdown VMs exceeding retention period of $ShutdownRetentionDays days\"\r\n    \r\n    # Use cached VMs if provided, otherwise fetch\r\n    if ($CachedVMs -and $CachedVMs.Count -gt 0) {\r\n        Write-LogEntry -Message \"Using cached VM data for shutdown retention check\" -Level Trace\r\n        $allVMs = $CachedVMs\r\n    }\r\n    else {\r\n        $Uri = \"$ResourceManagerUri/subscriptions/$VirtualMachinesSubscriptionId/resourceGroups/$VirtualMachinesResourceGroupName/resources?`$filter=resourceType eq 'Microsoft.Compute/virtualMachines'&api-version=2021-04-01\"\r\n        $allVMs = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n    }\r\n    \r\n    # Filter to VMs with the shutdown timestamp tag\r\n    $shutdownVMs = $allVMs | Where-Object { $_.tags -and $_.tags.PSObject.Properties.Name -contains $TagShutdownTimestamp }\r\n    \r\n    if (-not $shutdownVMs -or $shutdownVMs.Count -eq 0) {\r\n        Write-LogEntry -Message \"No shutdown VMs found with retention tag\" -Level Trace\r\n        return [PSCustomObject]@{\r\n            CleanedUpCount = 0\r\n            RetainedCount  = 0\r\n        }\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Found $($shutdownVMs.Count) shutdown VM(s) to evaluate\"\r\n    \r\n    $cleanedUpCount = 0\r\n    $retainedCount = 0\r\n    $deletedVMNames = @()\r\n    $currentTime = (Get-Date).ToUniversalTime()\r\n    \r\n    foreach ($vm in $shutdownVMs) {\r\n        $vmName = $vm.name\r\n        $vmId = $vm.id\r\n        \r\n        # Get the shutdown timestamp from tags\r\n        $shutdownTimestampString = $vm.tags.$TagShutdownTimestamp\r\n        \r\n        if ([string]::IsNullOrEmpty($shutdownTimestampString)) {\r\n            Write-LogEntry -Message \"VM $vmName has shutdown tag but no timestamp value - skipping\" -Level Warning\r\n            continue\r\n        }\r\n        \r\n        try {\r\n            $shutdownTime = [DateTime]::Parse($shutdownTimestampString, $null, [System.Globalization.DateTimeStyles]::AssumeUniversal -bor [System.Globalization.DateTimeStyles]::AdjustToUniversal)\r\n            $age = ($currentTime - $shutdownTime).TotalDays\r\n            \r\n            Write-LogEntry -Message \"VM $vmName has been shutdown for $([Math]::Round($age, 2)) days (retention: $ShutdownRetentionDays days)\" -Level Trace\r\n            \r\n            if ($age -ge $ShutdownRetentionDays) {\r\n                Write-LogEntry -Message \"VM $vmName has exceeded retention period - deleting...\"\r\n                \r\n                try {\r\n                    # Use helper function to delete VM and clean up resources\r\n                    Remove-VirtualMachine `\r\n                        -VMName $vmName `\r\n                        -VMId $vmId `\r\n                        -ARMToken $ARMToken `\r\n                        -GraphToken $GraphToken `\r\n                        -RemoveEntraDevice $RemoveEntraDevice `\r\n                        -RemoveIntuneDevice $RemoveIntuneDevice `\r\n                        -HostPoolSubscriptionId $HostPoolSubscriptionId `\r\n                        -HostPoolResourceGroupName $HostPoolResourceGroupName `\r\n                        -HostPoolName $HostPoolName `\r\n                        -ClientId $ClientId\r\n                    \r\n                    $cleanedUpCount++\r\n                    $deletedVMNames += $vmName\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"Failed to delete shutdown VM $vmName : $($_.Exception.Message)\" -Level Error\r\n                }\r\n            }\r\n            else {\r\n                $remainingDays = [Math]::Round($ShutdownRetentionDays - $age, 1)\r\n                Write-LogEntry -Message \"VM $vmName will be retained for $remainingDays more day(s)\" -Level Trace\r\n                $retainedCount++\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to parse shutdown timestamp for VM $vmName : $($_.Exception.Message)\" -Level Warning\r\n        }\r\n    }\r\n    \r\n    if ($cleanedUpCount -gt 0) {\r\n        Write-LogEntry -Message \"Cleanup complete: Deleted $cleanedUpCount expired shutdown VM(s), retained $retainedCount VM(s)\"\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"No shutdown VMs exceeded retention period\"\r\n    }\r\n    \r\n    return [PSCustomObject]@{\r\n        CleanedUpCount  = $cleanedUpCount\r\n        RetainedCount   = $retainedCount\r\n        DeletedVMNames  = $deletedVMNames\r\n    }\r\n}\r\n\r\nfunction Remove-SessionHosts {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter()]\r\n        [string] $GraphToken,\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n        [Parameter(Mandatory = $true)]\r\n        $SessionHostsPendingDelete,\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n        [Parameter()]\r\n        [string] $ResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n        [Parameter()]\r\n        [int] $DrainGracePeriodHours = (Read-FunctionAppSetting DrainGracePeriodHours),\r\n        [Parameter()]\r\n        [int] $MinimumDrainMinutes = (Read-FunctionAppSetting MinimumDrainMinutes),\r\n        [Parameter()]\r\n        [string] $ReplacementMode = (Read-FunctionAppSetting ReplacementMode),\r\n        [Parameter()]\r\n        [string] $TagPendingDrainTimeStamp = (Read-FunctionAppSetting Tag_PendingDrainTimestamp),\r\n        [Parameter()]\r\n        [string] $TagShutdownTimestamp = (Read-FunctionAppSetting Tag_ShutdownTimestamp),\r\n        [Parameter()]\r\n        [string] $TagScalingPlanExclusionTag = (Read-FunctionAppSetting Tag_ScalingPlanExclusionTag),\r\n        [Parameter()]\r\n        [bool] $RemoveEntraDevice,\r\n        [Parameter()]\r\n        [bool] $RemoveIntuneDevice,\r\n        [Parameter()]\r\n        [bool] $EnableShutdownRetention = (Read-FunctionAppSetting EnableShutdownRetention -AsBoolean),\r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n\r\n    # Initialize results tracking\r\n    $successfulDeletions = @()\r\n    $successfulShutdowns = @()\r\n    $failedDeletions = @()\r\n\r\n    foreach ($sessionHost in $SessionHostsPendingDelete) {\r\n        $drainSessionHost = $false\r\n        $deleteSessionHost = $false\r\n\r\n        Write-LogEntry -Message \"Evaluating session host $($sessionHost.SessionHostName): Sessions=$($sessionHost.Sessions), AllowNewSession=$($sessionHost.AllowNewSession), PendingDrainTimeStamp=$($sessionHost.PendingDrainTimeStamp)\" -Level Trace\r\n\r\n        if ($sessionHost.Sessions -eq 0) {\r\n            Write-LogEntry -Message \"Session host $($sessionHost.FQDN) has no sessions.\"\r\n            \r\n            # Optimization: If VM is already powered off, skip draining and delete immediately (no point draining an offline VM)\r\n            if ($sessionHost.PoweredOff) {\r\n                Write-LogEntry -Message \"Session host $($sessionHost.FQDN) is powered off - marking for immediate deletion without drain period (VM already shutdown)\"\r\n                $deleteSessionHost = $true\r\n            }\r\n            # Optimization: If MinimumDrainMinutes = 0, skip draining entirely and delete immediately\r\n            elseif ($MinimumDrainMinutes -eq 0) {\r\n                Write-LogEntry -Message \"Session host $($sessionHost.FQDN) is idle and MinimumDrainMinutes is 0 - marking for immediate removal without drain period\"\r\n                $deleteSessionHost = $true\r\n            }\r\n            elseif (-Not $sessionHost.AllowNewSession) {\r\n                Write-LogEntry -Message \"Session host $($sessionHost.FQDN) is in drain mode with zero sessions.\"\r\n                if ($sessionHost.PendingDrainTimeStamp) {                    \r\n                    # In SideBySide mode, skip minimum drain time check since new capacity is already deployed\r\n                    if ($ReplacementMode -eq 'SideBySide') {\r\n                        $deleteSessionHost = $true\r\n                    }\r\n                    # If VM is powered off, skip minimum drain time check - no race condition possible\r\n                    elseif ($sessionHost.PoweredOff) {\r\n                        Write-LogEntry -Message \"Session host $($sessionHost.FQDN) is powered off - skipping minimum drain time check (no race condition possible)\"\r\n                        $deleteSessionHost = $true\r\n                    }\r\n                    else {\r\n                        $elapsedMinutes = ((Get-Date).ToUniversalTime() - $sessionHost.PendingDrainTimeStamp).TotalMinutes\r\n                  \r\n                        Write-LogEntry -Message \"Session host $($sessionHost.FQDN) has been draining for $([Math]::Round($elapsedMinutes, 1)) minutes (minimum required: $MinimumDrainMinutes)\"\r\n                        if ($elapsedMinutes -ge $MinimumDrainMinutes) {\r\n                            Write-LogEntry -Message \"Session host $($sessionHost.FQDN) has met the minimum drain time for idle hosts.\"\r\n                            $deleteSessionHost = $true\r\n                        }\r\n                        else {\r\n                            Write-LogEntry -Message \"Session host $($sessionHost.FQDN) has not yet met the minimum drain time.\"\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    Write-LogEntry -Message \"Session host $($sessionHost.FQDN) does not have a drain timestamp.\"\r\n                    $drainSessionHost = $true\r\n                }\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"Session host $($sessionHost.FQDN) is not in drain mode. Turning on drain mode.\"\r\n                $drainSessionHost = $true\r\n            }\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Session host $($sessionHost.FQDN) has $($sessionHost.Sessions) sessions.\" \r\n            if (-Not $sessionHost.AllowNewSession) {\r\n                Write-LogEntry -Message \"Session host $($sessionHost.FQDN) is in drain mode.\"\r\n                if ($sessionHost.PendingDrainTimeStamp) {\r\n                    Write-LogEntry -Message \"Session Host $($sessionHost.FQDN) drain timestamp is $($sessionHost.PendingDrainTimeStamp)\"\r\n                    $maxDrainGracePeriodDate = $sessionHost.PendingDrainTimeStamp.AddHours($DrainGracePeriodHours)\r\n                    Write-LogEntry -Message \"Session Host $($sessionHost.FQDN) can stay in grace period until $($maxDrainGracePeriodDate.ToUniversalTime().ToString('o'))\" -Level Trace \r\n                    if ($maxDrainGracePeriodDate -lt (Get-Date).ToUniversalTime()) {\r\n                        Write-LogEntry -Message \"Session Host $($sessionHost.FQDN) has exceeded the drain grace period.\"\r\n                        $deleteSessionHost = $true\r\n                    }\r\n                    else {\r\n                        Write-LogEntry -Message \"Session Host $($sessionHost.FQDN) has not exceeded the drain grace period.\" -Level Trace\r\n                    }\r\n                }\r\n                else {\r\n                    Write-LogEntry -Message \"Session Host $($sessionHost.FQDN) does not have a drain timestamp.\" -Level Trace\r\n                    $drainSessionHost = $true\r\n                }\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"Session host $($sessionHost.Name) in not in drain mode. Turning on drain mode.\"\r\n                $drainSessionHost = $true\r\n            }\r\n        }\r\n\r\n        if ($drainSessionHost) {\r\n            try {\r\n                Write-LogEntry -Message \"Enabling drain mode for session host $($sessionHost.SessionHostName)\"\r\n                $Uri = \"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName/sessionHosts/$($sessionHost.FQDN)?api-version=2024-04-03\"\r\n                Invoke-AzureRestMethod -ARMToken $ARMToken -Body (@{properties = @{allowNewSession = $false } } | ConvertTo-Json) -Method 'PATCH' -Uri $Uri | Out-Null\r\n                \r\n                Write-LogEntry -Message \"Drain mode enabled for $($sessionHost.SessionHostName)\" -Level Trace\r\n                \r\n                $drainTimestamp = (Get-Date).ToUniversalTime().ToString('o')\r\n                Write-LogEntry -Message \"Setting drain timestamp tag on $($sessionHost.SessionHostName): $drainTimestamp\"\r\n                $Uri = \"$ResourceManagerUri$($sessionHost.ResourceId)/providers/Microsoft.Resources/tags/default?api-version=2021-04-01\"\r\n                $Body = @{\r\n                    properties = @{\r\n                        tags = @{ $TagPendingDrainTimeStamp = $drainTimestamp }\r\n                    }\r\n                    operation  = 'Merge'\r\n                }\r\n                Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $Uri | Out-Null\r\n                \r\n                Write-LogEntry -Message \"Successfully tagged $($sessionHost.SessionHostName) with drain timestamp\"\r\n                \r\n                # Update in-memory session host object so timestamp is available for deletion check in same run\r\n                $sessionHost.PendingDrainTimeStamp = [DateTime]::Parse($drainTimestamp, $null, [System.Globalization.DateTimeStyles]::AssumeUniversal -bor [System.Globalization.DateTimeStyles]::AdjustToUniversal)\r\n                \r\n                # Re-evaluate deletion eligibility now that we have a timestamp\r\n                # Priority order: PoweredOff > SideBySide > MinDrain=0 > MinDrainTime\r\n                if ($sessionHost.Sessions -eq 0) {\r\n                    $elapsedMinutes = ((Get-Date).ToUniversalTime() - $sessionHost.PendingDrainTimeStamp).TotalMinutes\r\n                    \r\n                    # HIGHEST PRIORITY: If VM is already powered off, delete immediately (no point waiting - it's already offline)\r\n                    if ($sessionHost.PoweredOff) {\r\n                        Write-LogEntry -Message \"Session host $($sessionHost.SessionHostName) is powered off - marking for immediate deletion (VM already shutdown)\"\r\n                        $deleteSessionHost = $true\r\n                    }\r\n                    # In SideBySide mode, allow immediate deletion since new capacity is already deployed\r\n                    elseif ($ReplacementMode -eq 'SideBySide') {\r\n                        Write-LogEntry -Message \"Session host $($sessionHost.SessionHostName) is in SideBySide mode - marking for immediate deletion (new capacity already deployed)\"\r\n                        $deleteSessionHost = $true\r\n                    }\r\n                    elseif ($MinimumDrainMinutes -eq 0) {\r\n                        Write-LogEntry -Message \"Session host $($sessionHost.SessionHostName) has MinimumDrainMinutes=0 - marking for immediate deletion\"\r\n                        $deleteSessionHost = $true\r\n                    }\r\n                    elseif ($elapsedMinutes -ge $MinimumDrainMinutes) {\r\n                        Write-LogEntry -Message \"Session host $($sessionHost.SessionHostName) meets deletion criteria ($([Math]::Round($elapsedMinutes, 1)) minutes elapsed >= $MinimumDrainMinutes required) - marking for deletion\"\r\n                        $deleteSessionHost = $true\r\n                    }\r\n                    else {\r\n                        Write-LogEntry -Message \"Session host $($sessionHost.SessionHostName) must wait $([Math]::Round($MinimumDrainMinutes - $elapsedMinutes, 1)) more minutes before deletion (minimum drain time: $MinimumDrainMinutes minutes)\"\r\n                    }\r\n                }\r\n                \r\n                if ($TagScalingPlanExclusionTag -ne ' ') {\r\n                    Write-LogEntry -Message \"Setting scaling plan exclusion tag on $($sessionHost.SessionHostName)\" -Level Trace\r\n                    $Body = @{\r\n                        properties = @{\r\n                            tags = @{ $TagScalingPlanExclusionTag = 'SessionHostReplacer' }\r\n                        }\r\n                        operation  = 'Merge'\r\n                    }\r\n                    Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $Uri | Out-Null\r\n                    \r\n                    Write-LogEntry -Message \"Successfully set scaling plan exclusion tag with value: SessionHostReplacer\" -Level Trace\r\n                }\r\n\r\n                Write-LogEntry -Message 'Notifying Users' -Level Trace\r\n                Send-DrainNotification -ARMToken $ARMToken -SessionHostName ($sessionHost.FQDN)\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Error enabling drain mode for $($sessionHost.SessionHostName): $($_.Exception.Message)\" -Level Error\r\n            }\r\n        }\r\n\r\n        if ($deleteSessionHost) {\r\n            try {\r\n                # If shutdown retention is enabled, shutdown instead of delete\r\n                if ($EnableShutdownRetention) {\r\n                    Write-LogEntry -Message \"Shutdown retention enabled - deallocating session host $($sessionHost.SessionHostName) for rollback capability...\"\r\n                    \r\n                    # Check current power state before attempting deallocate\r\n                    Write-LogEntry -Message \"Checking power state of VM: $($sessionHost.VMName)...\" -Level Trace\r\n                    $Uri = \"$ResourceManagerUri$($sessionHost.ResourceId)/instanceView?api-version=2024-07-01\"\r\n                    $instanceView = Invoke-AzureRestMethod -ARMToken $ARMToken -Method 'GET' -Uri $Uri\r\n                    \r\n                    # Get power state from instance view (e.g., \"PowerState/running\", \"PowerState/deallocated\")\r\n                    $powerState = ($instanceView.statuses | Where-Object { $_.code -like 'PowerState/*' }).code\r\n                    Write-LogEntry -Message \"Current power state: $powerState\" -Level Trace\r\n                    \r\n                    # Only deallocate if VM is not already stopped/deallocated\r\n                    if ($powerState -notlike 'PowerState/deallocated' -and $powerState -notlike 'PowerState/stopped') {\r\n                        Write-LogEntry -Message \"Deallocating VM: $($sessionHost.ResourceId)...\" -Level Trace\r\n                        $Uri = \"$ResourceManagerUri$($sessionHost.ResourceId)/deallocate?api-version=2024-07-01\"\r\n                        [void](Invoke-AzureRestMethod -ARMToken $ARMToken -Method 'POST' -Uri $Uri)\r\n                    }\r\n                    else {\r\n                        Write-LogEntry -Message \"VM is already deallocated/stopped - skipping deallocate operation\" -Level Trace\r\n                    }\r\n                    \r\n                    # Tag with shutdown timestamp for later cleanup and ensure scaling exclusion tag is present\r\n                    $shutdownTimestamp = (Get-Date).ToUniversalTime().ToString('o')\r\n                    Write-LogEntry -Message \"Setting shutdown timestamp tag on $($sessionHost.SessionHostName): $shutdownTimestamp\" -Level Trace\r\n                    $Uri = \"$ResourceManagerUri$($sessionHost.ResourceId)/providers/Microsoft.Resources/tags/default?api-version=2021-04-01\"\r\n                    \r\n                    # Build tags to apply: shutdown timestamp + scaling exclusion tag (if configured)\r\n                    $tagsToApply = @{ $TagShutdownTimestamp = $shutdownTimestamp }\r\n                    if ($TagScalingPlanExclusionTag -and $TagScalingPlanExclusionTag -ne ' ') {\r\n                        $tagsToApply[$TagScalingPlanExclusionTag] = 'SessionHostReplacer'\r\n                        Write-LogEntry -Message \"Ensuring scaling exclusion tag is set on shutdown retention VM: $($sessionHost.SessionHostName)\" -Level Trace\r\n                    }\r\n                    \r\n                    $Body = @{\r\n                        properties = @{\r\n                            tags = $tagsToApply\r\n                        }\r\n                        operation  = 'Merge'\r\n                    }\r\n                    Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $Uri | Out-Null\r\n                    \r\n                    # Track successful shutdown\r\n                    $successfulShutdowns += $sessionHost.SessionHostName\r\n                    Write-LogEntry -Message \"Successfully shutdown session host $($sessionHost.SessionHostName) - will remain in host pool for $((Read-FunctionAppSetting ShutdownRetentionDays)) days for rollback\"\r\n                }\r\n                else {\r\n                    # Standard delete flow - use helper function\r\n                    Write-LogEntry -Message \"Deleting session host $($SessionHost.SessionHostName)...\"\r\n                    \r\n                    Remove-VirtualMachine `\r\n                        -VMName $sessionHost.SessionHostName `\r\n                        -VMId $sessionHost.ResourceId `\r\n                        -FQDN $sessionHost.FQDN `\r\n                        -ARMToken $ARMToken `\r\n                        -GraphToken $GraphToken `\r\n                        -RemoveEntraDevice $RemoveEntraDevice `\r\n                        -RemoveIntuneDevice $RemoveIntuneDevice `\r\n                        -HostPoolSubscriptionId $HostPoolSubscriptionId `\r\n                        -HostPoolResourceGroupName $ResourceGroupName `\r\n                        -HostPoolName $HostPoolName `\r\n                        -ClientId $ClientId\r\n                    \r\n                    # Track successful deletion\r\n                    $successfulDeletions += $sessionHost.SessionHostName\r\n                }\r\n            }\r\n            catch {\r\n                # Track failed deletion\r\n                $failedDeletions += [PSCustomObject]@{\r\n                    SessionHostName = $sessionHost.SessionHostName\r\n                    Reason          = $_.Exception.Message\r\n                }\r\n                Write-Error \"Failed to delete session host $($sessionHost.SessionHostName): $($_.Exception.Message)\"\r\n            }\r\n        }\r\n    }\r\n\r\n    # Return results object\r\n    return [PSCustomObject]@{\r\n        SuccessfulDeletions = $successfulDeletions\r\n        SuccessfulShutdowns = $successfulShutdowns\r\n        FailedDeletions     = $failedDeletions\r\n    }\r\n}\r\n\r\nfunction Remove-VirtualMachine {\r\n    <#\r\n    .SYNOPSIS\r\n    Removes a virtual machine and cleans up associated resources.\r\n    \r\n    .DESCRIPTION\r\n    Helper function to remove a VM from the host pool, clean up device records,\r\n    and delete the VM. Used by both Remove-SessionHosts and Remove-ExpiredShutdownVMs.\r\n    \r\n    .PARAMETER VMName\r\n    The name of the VM to remove\r\n    \r\n    .PARAMETER VMId\r\n    The full resource ID of the VM\r\n    \r\n    .PARAMETER FQDN\r\n    The FQDN of the session host (optional - will be looked up if not provided)\r\n    \r\n    .PARAMETER ARMToken\r\n    ARM access token\r\n    \r\n    .PARAMETER GraphToken\r\n    Graph access token for device cleanup\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $VMName,\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $VMId,\r\n        [Parameter()]\r\n        [string] $FQDN,\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter()]\r\n        [string] $GraphToken,\r\n        [Parameter()]\r\n        [bool] $RemoveEntraDevice = $false,\r\n        [Parameter()]\r\n        [bool] $RemoveIntuneDevice = $false,\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n        [Parameter()]\r\n        [string] $HostPoolResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    Write-LogEntry -Message \"Deleting virtual machine $VMName\" -Level Trace\r\n    \r\n    # If FQDN not provided, query host pool to find it\r\n    if ([string]::IsNullOrEmpty($FQDN)) {\r\n        Write-LogEntry -Message \"FQDN not provided - querying host pool to find session host\" -Level Trace\r\n        $Uri = \"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$HostPoolResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName/sessionHosts?api-version=2024-04-03\"\r\n        $sessionHostsInPool = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n        \r\n        $matchingHost = $sessionHostsInPool | Where-Object { $_.name -like \"*/$VMName\" -or $_.properties.resourceId -eq $VMId }\r\n        \r\n        if ($matchingHost) {\r\n            $FQDN = $matchingHost.name.Split('/')[-1]\r\n            Write-LogEntry -Message \"Found session host in pool: $FQDN\" -Level Trace\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Session host $VMName not found in host pool (may have been manually removed)\" -Level Trace\r\n        }\r\n    }\r\n    \r\n    # Remove from host pool if FQDN is known\r\n    if (-not [string]::IsNullOrEmpty($FQDN)) {\r\n        Write-LogEntry -Message \"Removing session host $FQDN from host pool $HostPoolName\" -Level Trace\r\n        $Uri = \"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$HostPoolResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName/sessionHosts/$FQDN`?api-version=2024-04-03\"\r\n        [void](Invoke-AzureRestMethod -ARMToken $ARMToken -Method DELETE -Uri $Uri)\r\n        Write-LogEntry -Message \"Removed $VMName from host pool\" -Level Trace\r\n    }\r\n    \r\n    # Extract hostname from FQDN for device cleanup (Entra ID/Intune use hostname, not VM resource name)\r\n    $deviceName = if (-not [string]::IsNullOrEmpty($FQDN)) {\r\n        $FQDN.Split('.')[0]  # Get hostname from FQDN (e.g., \"avdtest29use207\" from \"avdtest29use207.domain.com\")\r\n    } else {\r\n        $VMName  # Fallback to VM name if FQDN not available\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Using device name '$deviceName' for Entra ID/Intune cleanup\" -Level Trace\r\n    \r\n    # Remove from identity directories\r\n    Remove-DeviceFromDirectories -DeviceName $deviceName -GraphToken $GraphToken -RemoveEntraDevice $RemoveEntraDevice -RemoveIntuneDevice $RemoveIntuneDevice -ClientId $ClientId\r\n    \r\n    # Delete the VM\r\n    Write-LogEntry -Message \"Deleting VM: $VMId\" -Level Trace\r\n    $Uri = \"$ResourceManagerUri$VMId`?forceDeletion=true&api-version=2024-07-01\"\r\n    [void](Invoke-AzureRestMethod -ARMToken $ARMToken -Method 'DELETE' -Uri $Uri)\r\n    \r\n    Write-LogEntry -Message \"Successfully deleted VM $VMName\"\r\n}\r\n\r\nfunction Send-DrainNotification {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string]$ARMToken,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $SessionHostName,\r\n\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n\r\n        [Parameter()]\r\n        [string] $ResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n\r\n        [Parameter()]\r\n        [int] $DrainGracePeriodHours = (Read-FunctionAppSetting DrainGracePeriodHours),\r\n\r\n        [Parameter()]\r\n        [string] $MessageTitle = \"Automatic Session Host Maintenance\",\r\n\r\n        [Parameter()]\r\n        [string] $MessageBody = \"Your session host {0} is being replaced. Please save your work and log off. You will be disconnected in {1} hours.\"\r\n    )\r\n    \r\n    try {       \r\n        Write-LogEntry -Message \"Getting user sessions for session host $SessionHostName\"\r\n        $SessionsUri = \"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName/sessionHosts/$SessionHostName/userSessions?api-version=2024-04-03\"\r\n        \r\n        $sessionsResponse = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $SessionsUri\r\n        \r\n        # Ensure we have an array\r\n        $sessions = @($sessionsResponse)\r\n        \r\n        # Filter out any empty or invalid session objects\r\n        $sessions = $sessions | Where-Object { $_ -and $_.name }\r\n        \r\n        if ($sessions.Count -eq 0) {\r\n            Write-LogEntry -Message \"No active sessions found on session host $SessionHostName\"\r\n            return\r\n        }\r\n        \r\n        Write-LogEntry -Message \"Found $($sessions.Count) active session(s) on session host $SessionHostName\"\r\n        \r\n        foreach ($session in $sessions) {\r\n            $sessionId = $session.name -replace '.+\\/.+\\/(.+)', '$1'\r\n            $userPrincipalName = $session.properties.userPrincipalName\r\n            \r\n            if ([string]::IsNullOrWhiteSpace($sessionId)) {\r\n                Write-LogEntry -Message \"Skipping session with invalid ID: $($session.name)\" -Level Warning\r\n                continue\r\n            }\r\n            \r\n            $formattedMessageBody = $MessageBody -f $SessionHostName, $DrainGracePeriodHours\r\n            \r\n            Write-LogEntry -Message \"Sending drain notification to user $userPrincipalName on session $sessionId\"\r\n            \r\n            $MessageUri = \"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName/sessionHosts/$SessionHostName/userSessions/$sessionId/sendMessage?api-version=2024-04-03\"\r\n            \r\n            $MessagePayload = @{\r\n                messageTitle = $MessageTitle\r\n                messageBody  = $formattedMessageBody\r\n            } | ConvertTo-Json -Depth 10\r\n            \r\n            try {\r\n                Invoke-AzureRestMethod -ARMToken $ARMToken -Method Post -Uri $MessageUri -Body $MessagePayload | Out-Null\r\n                Write-LogEntry -Message \"Successfully sent message to user $userPrincipalName\"\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Failed to send message to user $userPrincipalName : $_\" -Level Warning\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Error in Send-DrainNotification: $_\" -Level Error\r\n    }\r\n}\r\n\r\nfunction Test-NewSessionHostsAvailable {\r\n    <#\r\n    .SYNOPSIS\r\n    Verifies that newly deployed session hosts are in 'Available' status before proceeding with old host removal.\r\n    \r\n    .DESCRIPTION\r\n    Safety check to ensure new session hosts have successfully registered to the host pool and passed health checks\r\n    before shutting down or deleting old hosts. This prevents capacity loss if new hosts fail to become accessible.\r\n    \r\n    .PARAMETER ARMToken\r\n    ARM access token for Azure Resource Manager API calls\r\n    \r\n    .PARAMETER SessionHosts\r\n    Collection of all current session hosts from the host pool\r\n    \r\n    .PARAMETER LatestImageVersion\r\n    The latest image version info (Version and Definition) to identify new hosts\r\n    \r\n    .PARAMETER MinimumAvailableCount\r\n    Minimum number of new hosts that must be Available before proceeding (default: 1)\r\n    \r\n    .PARAMETER MinimumAvailablePercentage\r\n    Minimum percentage of new hosts that must be Available before proceeding (default: 100)\r\n    \r\n    .OUTPUTS\r\n    PSCustomObject with:\r\n    - AllAvailable: Boolean indicating if all new hosts are available\r\n    - AvailableCount: Number of new hosts in Available status\r\n    - TotalNewHosts: Total number of new hosts found\r\n    - UnavailableHosts: Array of hosts not in Available status with their status\r\n    - SafeToProceed: Boolean indicating if it's safe to remove old hosts\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter(Mandatory = $true)]\r\n        $SessionHosts,\r\n        [Parameter(Mandatory = $true)]\r\n        $LatestImageVersion,\r\n        [Parameter()]\r\n        [int] $MinimumAvailableCount = 1,\r\n        [Parameter()]\r\n        [int] $MinimumAvailablePercentage = 100\r\n    )\r\n    \r\n    Write-LogEntry -Message \"Verifying new session hosts are available before proceeding with old host removal\"\r\n    \r\n    # Identify new hosts (hosts on the latest image version)\r\n    $newHosts = $SessionHosts | Where-Object { \r\n        $_.ImageVersion -eq $LatestImageVersion.Version -and \r\n        $_.ImageDefinition -eq $LatestImageVersion.Definition \r\n    }\r\n    \r\n    if (-not $newHosts -or $newHosts.Count -eq 0) {\r\n        Write-LogEntry -Message \"No new session hosts found on latest image version - skipping availability check\" -Level Trace\r\n        return [PSCustomObject]@{\r\n            AllAvailable      = $true\r\n            AvailableCount    = 0\r\n            TotalNewHosts     = 0\r\n            UnavailableHosts  = @()\r\n            SafeToProceed     = $true\r\n            Message           = \"No new hosts to verify\"\r\n        }\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Found {0} new session host(s) on latest image version {1}\" -StringValues $newHosts.Count, $LatestImageVersion.Version\r\n    \r\n    # Check status of each new host\r\n    # Available statuses that indicate the host is working: Available, Needs Assistance (non-fatal), Upgrading, Upgrade Failed\r\n    # Statuses that indicate the host is NOT working: Unavailable, Shutdown, NoHeartbeat, NotJoinedToDomain, DomainTrustRelationshipLost, SxSStackListenerNotReady, FSLogixNotHealthy\r\n    $availableStatuses = @('Available', 'NeedsAssistance', 'Upgrading', 'UpgradeFailed')\r\n    \r\n    $availableHosts = @()\r\n    $unavailableHosts = @()\r\n    \r\n    foreach ($newHost in $newHosts) {\r\n        $hostStatus = $newHost.Status\r\n        $hostName = $newHost.SessionHostName\r\n        \r\n        Write-LogEntry -Message \"New host {0} status: {1}\" -StringValues $hostName, $hostStatus -Level Trace\r\n        \r\n        if ($hostStatus -in $availableStatuses) {\r\n            $availableHosts += $newHost\r\n            Write-LogEntry -Message \"New host {0} is accessible (Status: {1})\" -StringValues $hostName, $hostStatus -Level Trace\r\n        }\r\n        else {\r\n            $unavailableHosts += [PSCustomObject]@{\r\n                SessionHostName = $hostName\r\n                Status          = $hostStatus\r\n                ImageVersion    = $newHost.ImageVersion\r\n            }\r\n            Write-LogEntry -Message \"New host {0} is NOT accessible (Status: {1})\" -StringValues $hostName, $hostStatus -Level Warning\r\n        }\r\n    }\r\n    \r\n    $availableCount = $availableHosts.Count\r\n    $totalNewHosts = $newHosts.Count\r\n    $availablePercentage = if ($totalNewHosts -gt 0) { [Math]::Round(($availableCount / $totalNewHosts) * 100, 1) } else { 0 }\r\n    \r\n    # Determine if safe to proceed\r\n    $meetsMinimumCount = $availableCount -ge $MinimumAvailableCount\r\n    $meetsMinimumPercentage = $availablePercentage -ge $MinimumAvailablePercentage\r\n    $allAvailable = $unavailableHosts.Count -eq 0\r\n    $safeToProceed = $meetsMinimumCount -and $meetsMinimumPercentage\r\n    \r\n    # Build result message\r\n    $message = if ($allAvailable) {\r\n        \"All $totalNewHosts new session host(s) are available\"\r\n    }\r\n    elseif ($safeToProceed) {\r\n        \"$availableCount of $totalNewHosts new session host(s) are available ($availablePercentage%) - meets minimum requirements\"\r\n    }\r\n    else {\r\n        \"Only $availableCount of $totalNewHosts new session host(s) are available ($availablePercentage%) - does NOT meet minimum requirements (need $MinimumAvailableCount hosts and $MinimumAvailablePercentage%)\"\r\n    }\r\n    \r\n    Write-LogEntry -Message \"NEW_HOST_VERIFICATION | Available: {0}/{1} ({2}%) | SafeToProceed: {3}\" -StringValues $availableCount, $totalNewHosts, $availablePercentage, $safeToProceed\r\n    \r\n    if (-not $safeToProceed) {\r\n        Write-LogEntry -Message \"WARNING: New session hosts are not ready - will skip removal of old hosts to preserve capacity\" -Level Warning\r\n        foreach ($unavailable in $unavailableHosts) {\r\n            Write-LogEntry -Message \"  - {0}: Status={1}\" -StringValues $unavailable.SessionHostName, $unavailable.Status -Level Warning\r\n        }\r\n    }\r\n    \r\n    return [PSCustomObject]@{\r\n        AllAvailable         = $allAvailable\r\n        AvailableCount       = $availableCount\r\n        TotalNewHosts        = $totalNewHosts\r\n        AvailablePercentage  = $availablePercentage\r\n        UnavailableHosts     = $unavailableHosts\r\n        SafeToProceed        = $safeToProceed\r\n        Message              = $message\r\n    }\r\n}\r\n\r\n#EndRegion Session Host Lifecycle\r\n\r\n# Export functions\r\nExport-ModuleMember -Function Remove-SessionHosts, Remove-VirtualMachine, Remove-ExpiredShutdownVMs, Send-DrainNotification, Test-NewSessionHostsAvailable\r\n",
    "$fxv#11": "# SessionHostReplacer Monitoring Module\r\n# Contains host pool status tagging function\r\n\r\n# Import Core utilities\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Core.psm1\" -Force\r\n\r\n#Region Monitoring\r\n\r\nfunction Update-HostPoolStatus {\r\n    <#\r\n    .SYNOPSIS\r\n    Updates the host pool with a status tag indicating SessionHostReplacer progress.\r\n    \r\n    .DESCRIPTION\r\n    Creates a composite status tag on the host pool showing overall status and metrics.\r\n    Format: \"Status: X/Y up-to-date | N draining | M shutdown\"\r\n    \r\n    Status values:\r\n    - Complete: All hosts up-to-date, no pending work\r\n    - Updating: Active deployments or deletions in progress\r\n    - Recovery: Failed deployments detected\r\n    - Draining: Hosts in drain mode waiting for grace period\r\n    \r\n    .PARAMETER ARMToken\r\n    ARM access token for API calls\r\n    \r\n    .PARAMETER SessionHosts\r\n    Collection of all session hosts in the pool\r\n    \r\n    .PARAMETER RunningDeployments\r\n    Count of active deployments\r\n    \r\n    .PARAMETER FailedDeployments\r\n    Collection of failed deployments\r\n    \r\n    .PARAMETER HostsToReplace\r\n    Count of hosts needing replacement\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n        [Parameter(Mandatory = $true)]\r\n        $SessionHosts,\r\n        [Parameter()]\r\n        [int] $RunningDeployments = 0,\r\n        [Parameter()]\r\n        $FailedDeployments = @(),\r\n        [Parameter()]\r\n        [int] $HostsToReplace = 0,\r\n        [Parameter()]\r\n        [array] $CachedVMs,\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n        [Parameter()]\r\n        [string] $HostPoolResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n        [Parameter()]\r\n        [string] $TagShutdownTimestamp = (Read-FunctionAppSetting Tag_ShutdownTimestamp)\r\n    )\r\n    \r\n    try {\r\n        # Calculate metrics using the same math as the METRICS log\r\n        $totalHosts = $SessionHosts.Count\r\n        $drainingHosts = ($SessionHosts | Where-Object { -not $_.AllowNewSession }).Count\r\n        \r\n        # Count shutdown hosts (VMs with shutdown timestamp tag) - these are old hosts awaiting deletion\r\n        $shutdownHosts = 0\r\n        try {\r\n            # Use cached VMs if provided, otherwise fetch\r\n            if ($CachedVMs -and $CachedVMs.Count -gt 0) {\r\n                Write-LogEntry -Message \"Using cached VM data for shutdown host count\" -Level Trace\r\n                $allVMs = $CachedVMs\r\n            }\r\n            else {\r\n                $vmSubscriptionId = Read-FunctionAppSetting VirtualMachinesSubscriptionId\r\n                $vmResourceGroupName = Read-FunctionAppSetting VirtualMachinesResourceGroupName\r\n                $Uri = \"$ResourceManagerUri/subscriptions/$vmSubscriptionId/resourceGroups/$vmResourceGroupName/providers/Microsoft.Compute/virtualMachines?api-version=2024-07-01\"\r\n                $allVMs = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n            }\r\n            $shutdownVMs = $allVMs | Where-Object { $_.tags -and $_.tags.PSObject.Properties.Name -contains $TagShutdownTimestamp }\r\n            $shutdownHosts = if ($shutdownVMs) { $shutdownVMs.Count } else { 0 }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Could not query shutdown hosts: $($_.Exception.Message)\" -Level Trace\r\n        }\r\n        \r\n        # Up-to-date hosts calculation:\r\n        # - Start with total hosts in host pool\r\n        # - Subtract shutdown hosts (old hosts awaiting deletion, not actively serving users)\r\n        # - Subtract hosts that need replacement (out-of-date active hosts)\r\n        # Result: Active hosts on the latest image version\r\n        $activeHosts = $totalHosts - $shutdownHosts\r\n        $upToDateHosts = $activeHosts - $HostsToReplace\r\n        \r\n        # Determine status (prioritize completion when all hosts are up-to-date)\r\n        $status = if ($FailedDeployments.Count -gt 0) {\r\n            \"Recovery\"\r\n        }\r\n        elseif ($upToDateHosts -eq $activeHosts -and $shutdownHosts -eq 0 -and $RunningDeployments -eq 0 -and $HostsToReplace -eq 0) {\r\n            # All active hosts up-to-date, no shutdown hosts, no deployments, no replacements needed = complete\r\n            # Draining hosts (manually drained by admin) don't block completion status\r\n            \"Complete\"\r\n        }\r\n        elseif ($RunningDeployments -gt 0 -or $HostsToReplace -gt 0) {\r\n            \"Updating\"\r\n        }\r\n        elseif ($drainingHosts -gt 0) {\r\n            \"Draining\"\r\n        }\r\n        else {\r\n            \"Updating\"\r\n        }\r\n        \r\n        # Build composite status string - show active hosts (excluding shutdown) in the ratio\r\n        $statusParts = @(\"$status`: $upToDateHosts/$activeHosts up-to-date\")\r\n        \r\n        if ($drainingHosts -gt 0) {\r\n            $statusParts += \"$drainingHosts draining\"\r\n        }\r\n        \r\n        if ($shutdownHosts -gt 0) {\r\n            $statusParts += \"$shutdownHosts shutdown\"\r\n        }\r\n        \r\n        if ($RunningDeployments -gt 0) {\r\n            $statusParts += \"$RunningDeployments deploying\"\r\n        }\r\n        \r\n        $statusValue = $statusParts -join \" | \"\r\n        \r\n        Write-LogEntry -Message \"Updating host pool status tag: $statusValue\" -Level Trace\r\n        \r\n        # Update host pool tags\r\n        $Uri = \"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$HostPoolResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName/providers/Microsoft.Resources/tags/default?api-version=2021-04-01\"\r\n        $Body = @{\r\n            properties = @{\r\n                tags = @{ \r\n                    'SessionHostReplacerStatus' = $statusValue\r\n                    'SessionHostReplacerLastRun' = (Get-Date -AsUTC -Format 'o')\r\n                }\r\n            }\r\n            operation  = 'Merge'\r\n        }\r\n        \r\n        Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $Uri | Out-Null\r\n        \r\n        Write-LogEntry -Message \"Successfully updated host pool status tag\"\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Failed to update host pool status tag: $($_.Exception.Message)\" -Level Warning\r\n    }\r\n}\r\n\r\n#EndRegion Monitoring\r\n\r\n# Export function\r\nExport-ModuleMember -Function Update-HostPoolStatus\r\n",
    "$fxv#12": "# SessionHostReplacer PowerShell Module\r\n# This module imports all sub-modules. Function exports are controlled by SessionHostReplacer.psd1\r\n\r\n# Import all sub-modules in dependency order\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Core.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Deployment.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.ImageManagement.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Planning.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.DeviceCleanup.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Lifecycle.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Monitoring.psm1\" -Force",
    "$fxv#13": "@{\r\n    # Script module or binary module file associated with this manifest.\r\n    RootModule = 'SessionHostReplacer.psm1'\r\n\r\n    # Version number of this module.\r\n    ModuleVersion = '1.0.0'\r\n\r\n    # ID used to uniquely identify this module\r\n    GUID = 'a7f8e3b2-c4d1-4e9a-8b6c-f2d5e7a9c1b3'\r\n\r\n    # Author of this module\r\n    Author = 'Azure AVD Team'\r\n\r\n    # Company or vendor of this module\r\n    CompanyName = 'Microsoft'\r\n\r\n    # Copyright statement for this module\r\n    Copyright = '(c) Microsoft Corporation. All rights reserved.'\r\n\r\n    # Description of the functionality provided by this module\r\n    Description = 'Session Host Replacer Module - Provides core functions for AVD session host lifecycle management including authentication, configuration, logging, and Azure Table Storage operations.'\r\n\r\n    # Minimum version of the PowerShell engine required by this module\r\n    PowerShellVersion = '7.2'\r\n\r\n    # Functions to export from this module\r\n    FunctionsToExport = @(\r\n        # Core utilities (from SessionHostReplacer.Core.psm1)\r\n        'Get-ResourceManagerUri'\r\n        'Get-GraphEndpoint'\r\n        'Get-AccessToken'\r\n        'Read-FunctionAppSetting'\r\n        'Write-LogEntry'\r\n        'Invoke-AzureRestMethod'\r\n        'Invoke-AzureRestMethodWithRetry'\r\n        'Invoke-GraphRestMethod'\r\n        'Invoke-GraphApiWithRetry'\r\n        'ConvertTo-CaseInsensitiveHashtable'\r\n        'Get-VMPowerStates'\r\n        \r\n        # Deployment functions (from SessionHostReplacer.Deployment.psm1)\r\n        'Get-DeploymentState'\r\n        'Get-LastDeploymentStatus'\r\n        'Save-DeploymentState'\r\n        'Deploy-SessionHosts'\r\n        'Get-Deployments'\r\n        'Get-TemplateSpecVersionResourceId'\r\n        'Remove-FailedDeploymentArtifacts'\r\n        \r\n        # Image Management functions (from SessionHostReplacer.ImageManagement.psm1)\r\n        'Compare-ImageVersion'\r\n        'Get-LatestImageVersion'\r\n        \r\n        # Planning functions (from SessionHostReplacer.Planning.psm1)\r\n        'Get-SessionHostReplacementPlan'\r\n        'Get-SessionHosts'\r\n        'Get-ScalingPlanCurrentTarget'\r\n        \r\n        # Lifecycle functions (from SessionHostReplacer.Lifecycle.psm1)\r\n        'Remove-SessionHosts'\r\n        'Remove-VirtualMachine'\r\n        'Remove-ExpiredShutdownVMs'\r\n        'Send-DrainNotification'\r\n        'Test-NewSessionHostsAvailable'\r\n        \r\n        # Device Cleanup functions (from SessionHostReplacer.DeviceCleanup.psm1)\r\n        'Remove-DeviceFromDirectories'\r\n        'Remove-EntraDevice'\r\n        'Remove-IntuneDevice'\r\n        'Confirm-SessionHostDeletions'\r\n        \r\n        # Monitoring functions (from SessionHostReplacer.Monitoring.psm1)\r\n        'Update-HostPoolStatus'\r\n    )\r\n\r\n    # Cmdlets to export from this module\r\n    CmdletsToExport = @()\r\n\r\n    # Variables to export from this module\r\n    VariablesToExport = @()\r\n\r\n    # Aliases to export from this module\r\n    AliasesToExport = @()\r\n\r\n    # Private data to pass to the module specified in RootModule/ModuleToProcess\r\n    PrivateData = @{\r\n        PSData = @{\r\n            # Tags applied to this module\r\n            Tags = @('Azure', 'AVD', 'SessionHost', 'Automation', 'Functions')\r\n\r\n            # ReleaseNotes of this module\r\n            ReleaseNotes = 'Initial release - Core helper functions for Session Host Replacer'\r\n        }\r\n    }\r\n}\r\n",
    "$fxv#2": "# Input bindings are passed in via param block.\r\nparam($Timer)\r\n\r\n# The 'IsPastDue' property is 'true' when the current function invocation is later than scheduled.\r\nif ($Timer.IsPastDue) {\r\n    Write-Host \"PowerShell timer is running late!\"\r\n}\r\n\r\nWrite-LogEntry -Message \"SessionHostReplacer function started at {0}\" -StringValues (Get-Date -AsUTC -Format 'o')\r\n\r\n# Log configuration settings for workbook visibility\r\n$enableShutdownRetention = Read-FunctionAppSetting EnableShutdownRetention -AsBoolean\r\n$replacementMode = Read-FunctionAppSetting ReplacementMode\r\n$minimumDrainMinutes = Read-FunctionAppSetting MinimumDrainMinutes\r\n$drainGracePeriodHours = Read-FunctionAppSetting DrainGracePeriodHours\r\n$minimumCapacityPercentage = Read-FunctionAppSetting MinimumCapacityPercentage\r\n$maxDeletionsPerCycle = Read-FunctionAppSetting MaxDeletionsPerCycle\r\n$enableProgressiveScaleUp = Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean\r\n$initialDeploymentPercentage = Read-FunctionAppSetting InitialDeploymentPercentage\r\n$scaleUpIncrementPercentage = Read-FunctionAppSetting ScaleUpIncrementPercentage\r\n$successfulRunsBeforeScaleUp = Read-FunctionAppSetting SuccessfulRunsBeforeScaleUp\r\n$maxDeploymentBatchSize = Read-FunctionAppSetting MaxDeploymentBatchSize\r\n$minimumHostIndex = Read-FunctionAppSetting MinimumHostIndex\r\n$shutdownRetentionDays = Read-FunctionAppSetting ShutdownRetentionDays\r\n$targetSessionHostCount = Read-FunctionAppSetting TargetSessionHostCount\r\n$enableProgressiveScaleUp = Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean\r\n$removeEntraDevice = Read-FunctionAppSetting RemoveEntraDevice -AsBoolean\r\n$removeIntuneDevice = Read-FunctionAppSetting RemoveIntuneDevice -AsBoolean\r\n\r\n# Build settings log with N/A for non-applicable values based on replacement mode\r\n$settingsLog = @{\r\n    ReplacementMode             = $replacementMode\r\n    MinimumDrainMinutes         = $minimumDrainMinutes\r\n    DrainGracePeriodHours       = $drainGracePeriodHours\r\n    MinimumCapacityPercent      = if ($replacementMode -eq 'DeleteFirst') { \"$minimumCapacityPercentage (static)\" } else { 'N/A' }\r\n    MaxDeletionsPerCycle        = if ($replacementMode -eq 'DeleteFirst') { $maxDeletionsPerCycle } else { 'N/A' }\r\n    EnableProgressiveScaleUp    = $enableProgressiveScaleUp\r\n    InitialDeploymentPercent    = if ($enableProgressiveScaleUp) { $initialDeploymentPercentage } else { 'N/A' }\r\n    ScaleUpIncrementPercent     = if ($enableProgressiveScaleUp) { $scaleUpIncrementPercentage } else { 'N/A' }\r\n    SuccessfulRunsBeforeScaleUp = if ($enableProgressiveScaleUp) { $successfulRunsBeforeScaleUp } else { 'N/A' }\r\n    MaxDeploymentBatchSize      = if ($replacementMode -eq 'SideBySide') { $maxDeploymentBatchSize } else { 'N/A' }\r\n    MinimumHostIndex            = $minimumHostIndex\r\n    EnableShutdownRetention     = if ($replacementMode -eq 'SideBySide') { $enableShutdownRetention } else { 'N/A' }\r\n    ShutdownRetentionDays       = if ($replacementMode -eq 'SideBySide' -and $enableShutdownRetention -eq 'True') { $shutdownRetentionDays } else { 'N/A' }\r\n    TargetSessionHostCount      = if ($targetSessionHostCount -eq 0) { 'Auto' } else { $targetSessionHostCount }\r\n    DynamicCapacityEnabled      = if ($replacementMode -eq 'DeleteFirst') { 'Yes' } else { 'N/A' }\r\n}\r\n\r\nWrite-LogEntry -Message \"SETTINGS | ReplacementMode: {0} | MinimumDrainMinutes: {1} | DrainGracePeriodHours: {2} | MinimumCapacityPercent: {3} | MaxDeletionsPerCycle: {4} | EnableProgressiveScaleUp: {5} | InitialDeploymentPercent: {6} | ScaleUpIncrementPercent: {7} | SuccessfulRunsBeforeScaleUp: {8} | MaxDeploymentBatchSize: {9} | MinimumHostIndex: {10} | EnableShutdownRetention: {11} | ShutdownRetentionDays: {12} | TargetSessionHostCount: {13} | DynamicCapacity: {14}\" -StringValues $settingsLog.ReplacementMode, $settingsLog.MinimumDrainMinutes, $settingsLog.DrainGracePeriodHours, $settingsLog.MinimumCapacityPercent, $settingsLog.MaxDeletionsPerCycle, $settingsLog.EnableProgressiveScaleUp, $settingsLog.InitialDeploymentPercent, $settingsLog.ScaleUpIncrementPercent, $settingsLog.SuccessfulRunsBeforeScaleUp, $settingsLog.MaxDeploymentBatchSize, $settingsLog.MinimumHostIndex, $settingsLog.EnableShutdownRetention, $settingsLog.ShutdownRetentionDays, $settingsLog.TargetSessionHostCount, $settingsLog.DynamicCapacityEnabled\r\n\r\n# Acquire ARM access token\r\ntry {\r\n    $ARMToken = Get-AccessToken -ResourceUri (Get-ResourceManagerUri)\r\n    if ([string]::IsNullOrEmpty($ARMToken)) {\r\n        throw \"Get-AccessToken returned null or empty token\"\r\n    }\r\n}\r\ncatch {\r\n    Write-Error \"Failed to acquire ARM access token: $_\"\r\n    Write-LogEntry -Message \"Token acquisition error details: {0}\" -StringValues $_.Exception.Message\r\n    throw\r\n}\r\n\r\n# Fetch ALL VMs in the resource group once to avoid redundant queries throughout the run\r\n# Power state will be queried lazily for deletion candidates only\r\nWrite-LogEntry -Message \"Fetching all VMs in resource group for caching\"\r\n$virtualMachinesSubscriptionId = Read-FunctionAppSetting VirtualMachinesSubscriptionId\r\n$virtualMachinesResourceGroupName = Read-FunctionAppSetting VirtualMachinesResourceGroupName\r\n$resourceManagerUri = Get-ResourceManagerUri\r\n$Uri = \"$resourceManagerUri/subscriptions/$virtualMachinesSubscriptionId/resourceGroups/$virtualMachinesResourceGroupName/providers/Microsoft.Compute/virtualMachines?api-version=2024-07-01\"\r\n$cachedVMs = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\nWrite-LogEntry -Message \"Cached {0} VMs from resource group\" -StringValues $cachedVMs.Count\r\n\r\n# Check for and cleanup expired shutdown VMs BEFORE fetching session hosts (so the list is already clean)\r\nif ($enableShutdownRetention) {\r\n    Write-LogEntry -Message \"Shutdown retention is enabled - checking for expired shutdown VMs\"\r\n    \r\n    # Acquire Graph token for device cleanup if enabled\r\n    $GraphToken = $null\r\n    \r\n    if ($removeEntraDevice -or $removeIntuneDevice) {\r\n        try {\r\n            $graphEndpoint = Get-GraphEndpoint\r\n            $GraphToken = Get-AccessToken -ResourceUri $graphEndpoint\r\n            \r\n            if ([string]::IsNullOrEmpty($GraphToken)) {\r\n                Write-LogEntry -Message \"Warning: Could not acquire Graph token for device cleanup\" -Level Warning\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Warning: Failed to acquire Graph token for device cleanup: $_\" -Level Warning\r\n        }\r\n    }\r\n    \r\n    # Cleanup expired shutdown VMs\r\n    $cleanupResults = Remove-ExpiredShutdownVMs -ARMToken $ARMToken -GraphToken $GraphToken -CachedVMs $cachedVMs\r\n    \r\n    if ($cleanupResults.CleanedUpCount -gt 0) {\r\n        Write-LogEntry -Message \"Cleaned up {0} expired shutdown VM(s)\" -StringValues $cleanupResults.CleanedUpCount\r\n        \r\n        # Remove deleted VMs from cache (more efficient than re-querying all VMs)\r\n        if ($cleanupResults.DeletedVMNames -and $cleanupResults.DeletedVMNames.Count -gt 0) {\r\n            Write-LogEntry -Message \"Removing {0} deleted VM(s) from cache\" -StringValues $cleanupResults.DeletedVMNames.Count -Level Trace\r\n            $cachedVMs = $cachedVMs | Where-Object { $_.name -notin $cleanupResults.DeletedVMNames }\r\n            Write-LogEntry -Message \"Cache updated: {0} VMs remaining\" -StringValues $cachedVMs.Count -Level Trace\r\n        }\r\n    }\r\n}\r\n\r\n# Get session hosts and update tags if needed (pass cached VMs)\r\n$sessionHosts = Get-SessionHosts -ARMToken $ARMToken -CachedVMs $cachedVMs\r\nWrite-LogEntry -Message \"Found {0} session hosts\" -StringValues $sessionHosts.Count\r\n\r\n# Check previous deployment status and pending host mappings\r\n$previousDeploymentStatus = $null\r\n\r\n# Get deployment state if needed (for progressive scale-up OR DeleteFirst mode)\r\nif ($enableProgressiveScaleUp -or $replacementMode -eq 'DeleteFirst') {\r\n    $deploymentState = Get-DeploymentState\r\n    \r\n    if (-not [string]::IsNullOrEmpty($deploymentState.LastDeploymentName)) {\r\n        Write-LogEntry -Message \"Checking status of previous deployment: {0}\" -StringValues $deploymentState.LastDeploymentName\r\n        $previousDeploymentStatus = Get-LastDeploymentStatus -DeploymentName $deploymentState.LastDeploymentName -ARMToken $ARMToken\r\n        \r\n        if ($previousDeploymentStatus) {\r\n            if ($previousDeploymentStatus.Succeeded) {\r\n                # Verify hosts from pending mappings actually registered before counting as success (DeleteFirst mode)\r\n                $allHostsRegistered = $true\r\n                if ($replacementMode -eq 'DeleteFirst' -and $deploymentState.PendingHostMappings -and $deploymentState.PendingHostMappings -ne '{}') {\r\n                    $pendingMappings = $deploymentState.PendingHostMappings | ConvertFrom-Json\r\n                    $expectedHostNames = $pendingMappings.PSObject.Properties.Name\r\n                    $registeredHostNames = $sessionHosts.SessionHostName\r\n                    $missingHosts = $expectedHostNames | Where-Object { $_ -notin $registeredHostNames }\r\n                    \r\n                    if ($missingHosts.Count -eq 0) {\r\n                        Write-LogEntry -Message \"All {0} pending host(s) successfully registered - clearing mappings\" -StringValues $expectedHostNames.Count -Level Trace\r\n                        $deploymentState.PendingHostMappings = '{}'\r\n                        $allHostsRegistered = $true\r\n                    }\r\n                    else {\r\n                        Write-LogEntry -Message \"Deployment succeeded but {0} host(s) not yet registered: {1} - keeping mappings and NOT counting as successful run\" -StringValues $missingHosts.Count, ($missingHosts -join ', ') -Level Warning\r\n                        $allHostsRegistered = $false\r\n                        # Keep mappings and don't increment success counter - hosts may still be registering or there may be a registration issue\r\n                    }\r\n                }\r\n                \r\n                # Only increment consecutive successes and update scale-up percentage if progressive scale-up is enabled AND hosts registered\r\n                if ($enableProgressiveScaleUp) {\r\n                    if ($allHostsRegistered) {\r\n                        $deploymentState.ConsecutiveSuccesses++\r\n                        $deploymentState.LastStatus = 'Success'\r\n                        \r\n                        # Calculate next percentage\r\n                        $successfulRunsBeforeScaleUp = (Read-FunctionAppSetting SuccessfulRunsBeforeScaleUp)\r\n                        $scaleUpIncrementPercentage = (Read-FunctionAppSetting ScaleUpIncrementPercentage)\r\n                        $initialDeploymentPercentage = (Read-FunctionAppSetting InitialDeploymentPercentage)\r\n                        \r\n                        $scaleUpMultiplier = [Math]::Floor($deploymentState.ConsecutiveSuccesses / $successfulRunsBeforeScaleUp)\r\n                        $deploymentState.CurrentPercentage = [Math]::Min(\r\n                            $initialDeploymentPercentage + ($scaleUpMultiplier * $scaleUpIncrementPercentage),\r\n                            100\r\n                        )                \r\n                        Write-LogEntry -Message \"Previous deployment succeeded with all hosts registered. ConsecutiveSuccesses: $($deploymentState.ConsecutiveSuccesses), CurrentPercentage: $($deploymentState.CurrentPercentage)%\"\r\n                    }\r\n                    else {\r\n                        # Deployment succeeded but hosts didn't register - don't count as success or scale up\r\n                        $deploymentState.LastStatus = 'PendingRegistration'\r\n                        Write-LogEntry -Message \"Deployment succeeded but hosts not yet registered - NOT incrementing success counter or scaling up\" -Level Warning\r\n                    }\r\n                }\r\n                elseif ($allHostsRegistered) {\r\n                    # Progressive scale-up disabled, but still track success for DeleteFirst mode\r\n                    $deploymentState.LastStatus = 'Success'\r\n                    Write-LogEntry -Message \"Previous deployment succeeded with all hosts registered (progressive scale-up disabled)\"\r\n                }\r\n            }\r\n            elseif ($previousDeploymentStatus.Failed) {\r\n                Write-LogEntry -Message \"Previous deployment failed. Cleaning up partial resources before redeployment.\" -Level Warning\r\n                \r\n                # Acquire Graph token for device cleanup if enabled\r\n                $GraphToken = $null\r\n                \r\n                if ($removeEntraDevice -or $removeIntuneDevice) {\r\n                    try {\r\n                        $graphEndpoint = Get-GraphEndpoint\r\n                        $GraphToken = Get-AccessToken -ResourceUri $graphEndpoint\r\n                        \r\n                        if ([string]::IsNullOrEmpty($GraphToken)) {\r\n                            Write-LogEntry -Message \"Warning: Could not acquire Graph token for device cleanup\" -Level Warning\r\n                        }\r\n                    }\r\n                    catch {\r\n                        Write-LogEntry -Message \"Warning: Failed to acquire Graph token for device cleanup: $_\" -Level Warning\r\n                    }\r\n                }\r\n                \r\n                # Clean up the failed deployment and its partial resources\r\n                $failedDeploymentInfo = @([PSCustomObject]@{\r\n                        DeploymentName = $deploymentState.LastDeploymentName\r\n                    })\r\n                \r\n                try {\r\n                    Remove-FailedDeploymentArtifacts -ARMToken $ARMToken -GraphToken $GraphToken -FailedDeployments $failedDeploymentInfo -RegisteredSessionHostNames $sessionHosts.SessionHostName -RemoveEntraDevice $removeEntraDevice -RemoveIntuneDevice $removeIntuneDevice -CachedVMs $cachedVMs\r\n                    Write-LogEntry -Message \"Completed cleanup of failed deployment artifacts\"\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"Error during failed deployment cleanup: $_\" -Level Error\r\n                }\r\n                \r\n                # DO NOT clear pending host mappings - those hosts still need deployment after cleanup\r\n                # PendingHostMappings will persist until deployment succeeds and VMs register\r\n                Write-LogEntry -Message \"Keeping {0} pending host mapping(s) for retry after cleanup\" -StringValues (($deploymentState.PendingHostMappings | ConvertFrom-Json).Count) -Level Trace\r\n                \r\n                # Reset progressive scale-up on failure (if enabled)\r\n                if ($enableProgressiveScaleUp) {\r\n                    $deploymentState.ConsecutiveSuccesses = 0\r\n                    $initialDeploymentPercentage = (Read-FunctionAppSetting InitialDeploymentPercentage)\r\n                    $deploymentState.CurrentPercentage = $initialDeploymentPercentage\r\n                    Write-LogEntry -Message \"Reset consecutive successes to 0, CurrentPercentage: $($deploymentState.CurrentPercentage)%\" -Level Warning\r\n                }\r\n                $deploymentState.LastStatus = 'Failed'\r\n            }\r\n            elseif ($previousDeploymentStatus.Running) {\r\n                Write-LogEntry -Message \"Previous deployment is still running. Will check again on next run.\" -Level Warning\r\n                # Don't update state yet - wait until it completes\r\n            }\r\n            \r\n            # Clear LastDeploymentName after checking (succeeded or failed), but keep it if still running\r\n            if ($previousDeploymentStatus.Succeeded -or $previousDeploymentStatus.Failed) {\r\n                $deploymentState.LastDeploymentName = ''\r\n            }\r\n            \r\n            # Save updated state\r\n            Save-DeploymentState -DeploymentState $deploymentState\r\n        }\r\n    }\r\n}\r\n\r\n# Filter to Session hosts that are included in auto replace\r\n$sessionHostsFiltered = $sessionHosts | Where-Object { $_.IncludeInAutomation }\r\nWrite-LogEntry -Message \"Filtered to {0} session hosts enabled for automatic replacement: {1}\" -StringValues $sessionHostsFiltered.Count, ($sessionHostsFiltered.SessionHostName -join ',')\r\n\r\n# Further filter out VMs that are already in shutdown retention (to avoid redundant shutdown operations)\r\nif ($enableShutdownRetention) {\r\n    $shutdownRetentionTag = Read-FunctionAppSetting Tag_ShutdownTimestamp\r\n    $hostsInShutdownRetention = @()\r\n    \r\n    Write-LogEntry -Message \"Checking for session hosts already in shutdown retention using tag: $shutdownRetentionTag\" -Level Trace\r\n    \r\n    foreach ($sessionHost in $sessionHostsFiltered) {\r\n        $vmName = $sessionHost.ResourceId.Split('/')[-1]\r\n        $vm = $cachedVMs | Where-Object { $_.name -eq $vmName } | Select-Object -First 1\r\n        \r\n        if ($vm) {\r\n            $hasRetentionTag = $vm.tags -and ($vm.tags.PSObject.Properties.Name -contains $shutdownRetentionTag)\r\n            Write-LogEntry -Message \"VM ${vmName}: Has tags=$($null -ne $vm.tags), Has retention tag=$hasRetentionTag\" -Level Trace\r\n            \r\n            if ($hasRetentionTag) {\r\n                $hostsInShutdownRetention += $sessionHost\r\n                Write-LogEntry -Message \"VM $vmName is in shutdown retention - will exclude from replacement processing\" -Level Trace\r\n            }\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"VM $vmName not found in cached VMs\" -Level Trace\r\n        }\r\n    }\r\n    \r\n    if ($hostsInShutdownRetention.Count -gt 0) {\r\n        $shutdownRetentionNames = $hostsInShutdownRetention.SessionHostName -join ', '\r\n        Write-LogEntry -Message \"Excluding {0} session host(s) already in shutdown retention from replacement processing: {1}\" -StringValues $hostsInShutdownRetention.Count, $shutdownRetentionNames\r\n        $sessionHostsFiltered = $sessionHostsFiltered | Where-Object { $_.SessionHostName -notin $hostsInShutdownRetention.SessionHostName }\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"No session hosts found in shutdown retention\" -Level Trace\r\n    }\r\n}\r\n\r\n# Get running and failed deployments\r\n$deploymentsInfo = Get-Deployments -ARMToken $ARMToken\r\n$runningDeployments = $deploymentsInfo.RunningDeployments\r\n$failedDeployments = $deploymentsInfo.FailedDeployments\r\nWrite-LogEntry -Message \"Found {0} running deployments and {1} failed deployments\" -StringValues $runningDeployments.Count, $failedDeployments.Count\r\n\r\n# Clean up failed deployments and orphaned VMs\r\nif ($failedDeployments.Count -gt 0) {\r\n    Write-LogEntry -Message \"Processing {0} failed deployments for cleanup\" -StringValues $failedDeployments.Count\r\n    Remove-FailedDeploymentArtifacts -ARMToken $ARMToken -FailedDeployments $failedDeployments -RegisteredSessionHostNames $sessionHostsFiltered.SessionHostName -CachedVMs $cachedVMs\r\n}\r\n\r\n# Load session host parameters\r\n$sessionHostParameters = [hashtable]::new([System.StringComparer]::InvariantCultureIgnoreCase)\r\n$sessionHostParameters += (Read-FunctionAppSetting SessionHostParameters)\r\n\r\n# Get latest version of session host image\r\nWrite-LogEntry -Message \"Getting latest image version using Image Reference.\"\r\n$latestImageVersion = Get-LatestImageVersion -ARMToken $ARMToken -ImageReference $sessionHostParameters.ImageReference -Location $sessionHostParameters.Location\r\n\r\n# Read AllowImageVersionRollback setting with default of false\r\n$allowImageVersionRollback = Read-FunctionAppSetting AllowImageVersionRollback -AsBoolean\r\n\r\n# CRITICAL: Check if we're starting a new update cycle and reset progressive scale-up if needed\r\n# This MUST happen BEFORE Get-SessionHostReplacementPlan so the reset state is used\r\nif (Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean) {\r\n    $deploymentState = Get-DeploymentState\r\n    $currentImageVersion = if ($latestImageVersion.Version) { $latestImageVersion.Version } else { 'N/A' }\r\n    \r\n    # Log current state for debugging\r\n    $lastToReplace = if ($null -eq $deploymentState.LastImageVersion) { 0 } else { $deploymentState.LastTotalToReplace }\r\n    Write-LogEntry -Message \"New cycle detection - Current: ImageVersion='$currentImageVersion', LastTotalToReplace=$lastToReplace\"\r\n    Write-LogEntry -Message \"New cycle detection - Previous: LastImageVersion='$($deploymentState.LastImageVersion)' (IsNull: $($null -eq $deploymentState.LastImageVersion)), LastStatus='$($deploymentState.LastStatus)'\"\r\n    \r\n    # Check if image version changed AND we were previously up to date (not already in a cycle)\r\n    # This prevents repeatedly triggering new cycle on every run while hosts are still being replaced\r\n    # Treat null/missing LastTotalToReplace as 0 (up to date) for backward compatibility\r\n    \r\n    # Evaluate each condition separately for visibility\r\n    $hasLastImageVersion = -not [string]::IsNullOrEmpty($deploymentState.LastImageVersion)\r\n    $imageVersionChanged = $deploymentState.LastImageVersion -ne $currentImageVersion\r\n    $currentVersionValid = $currentImageVersion -ne \"N/A\"\r\n    $wasUpToDate = $lastToReplace -eq 0\r\n    \r\n    Write-LogEntry -Message \"New cycle detection conditions - HasLastImageVersion: $hasLastImageVersion, ImageVersionChanged: $imageVersionChanged, CurrentVersionValid: $currentVersionValid, WasUpToDate: $wasUpToDate\"\r\n    \r\n    if ($hasLastImageVersion -and $imageVersionChanged -and $currentVersionValid -and $wasUpToDate) {\r\n        Write-LogEntry -Message \"New cycle detection - Image version changed from $($deploymentState.LastImageVersion) to $currentImageVersion (was previously up to date)\"\r\n        Write-LogEntry -Message \"Resetting progressive scale-up to initial percentage\"\r\n        $deploymentState.ConsecutiveSuccesses = 0\r\n        $deploymentState.CurrentPercentage = (Read-FunctionAppSetting InitialDeploymentPercentage)\r\n        $deploymentState.LastStatus = 'NewCycle'\r\n        $deploymentState.LastDeploymentName = ''\r\n        # Update LastImageVersion immediately so we don't trigger new cycle on every subsequent run\r\n        $deploymentState.LastImageVersion = $currentImageVersion\r\n        Save-DeploymentState -DeploymentState $deploymentState\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"New cycle detection - Conditions not met, no new cycle triggered\" -Level Trace\r\n    }\r\n}\r\n\r\n# OPTIMIZATION: Lightweight pre-check to determine if host pool is up to date\r\n# This avoids expensive operations (scaling plan query, full replacement plan calculation) when no work is needed\r\nWrite-LogEntry -Message \"Performing lightweight up-to-date check\" -Level Trace\r\n\r\n$isUpToDate = $false\r\n$replaceSessionHostOnNewImageVersionDelayDays = (Read-FunctionAppSetting ReplaceSessionHostOnNewImageVersionDelayDays)\r\n$latestImageAge = (New-TimeSpan -Start $latestImageVersion.Date -End (Get-Date -AsUTC)).TotalDays\r\n\r\n# Check for work in progress that requires full processing\r\n$skipLightweightCheck = $false\r\n\r\n# DeleteFirst mode: Check for pending host mappings or hosts in drain mode\r\nif ($replacementMode -eq 'DeleteFirst') {\r\n    $deploymentState = Get-DeploymentState\r\n    $hasPendingMappings = $deploymentState.PendingHostMappings -and $deploymentState.PendingHostMappings -ne '{}'\r\n    \r\n    if ($hasPendingMappings) {\r\n        Write-LogEntry -Message \"Lightweight check: Found pending host mappings from previous deletion - proceeding with full processing\" -Level Trace\r\n        $skipLightweightCheck = $true\r\n    }\r\n    # Check if there are hosts in drain mode (work in progress)\r\n    elseif (($sessionHostsFiltered | Where-Object { -not $_.AllowNewSession }).Count -gt 0) {\r\n        $hostsInDrainMode = ($sessionHostsFiltered | Where-Object { -not $_.AllowNewSession }).Count\r\n        Write-LogEntry -Message \"Lightweight check: Found $hostsInDrainMode host(s) in drain mode - proceeding with full processing\" -Level Trace\r\n        $skipLightweightCheck = $true\r\n    }\r\n}\r\n\r\n# Check if there are any running or failed deployments (both modes)\r\nif ($runningDeployments.Count -gt 0 -or $failedDeployments.Count -gt 0) {\r\n    Write-LogEntry -Message \"Lightweight check: Found $($runningDeployments.Count) running and $($failedDeployments.Count) failed deployments - proceeding with full processing\" -Level Trace\r\n    $skipLightweightCheck = $true\r\n}\r\n\r\n# If no work in progress, perform quick image version check\r\nif (-not $skipLightweightCheck) {\r\n    # Check if image is old enough to trigger replacements\r\n    if ($latestImageAge -ge $replaceSessionHostOnNewImageVersionDelayDays) {\r\n        \r\n        # Quick version comparison - check if all hosts are on latest version\r\n        $hostsNeedingReplacement = 0\r\n        foreach ($sh in $sessionHostsFiltered) {\r\n            if ($sh.ImageVersion -ne $latestImageVersion.Version) {\r\n                # Check if image definition changed (not a rollback scenario)\r\n                $imageDefinitionChanged = $false\r\n                if ($sh.ImageDefinition -and $latestImageVersion.Definition) {\r\n                    $imageDefinitionChanged = ($sh.ImageDefinition -ne $latestImageVersion.Definition)\r\n                }\r\n                \r\n                if ($imageDefinitionChanged) {\r\n                    # Image definition changed - needs replacement\r\n                    $hostsNeedingReplacement++\r\n                    break  # Found at least one, no need to check more\r\n                }\r\n                else {\r\n                    # Same image definition, check version comparison\r\n                    $versionComparison = Compare-ImageVersion -Version1 $sh.ImageVersion -Version2 $latestImageVersion.Version\r\n                    \r\n                    if ($versionComparison -lt 0) {\r\n                        # VM version is older - needs replacement\r\n                        $hostsNeedingReplacement++\r\n                        break  # Found at least one, no need to check more\r\n                    }\r\n                    elseif ($versionComparison -gt 0 -and $allowImageVersionRollback) {\r\n                        # VM version is newer but rollback is allowed - needs replacement\r\n                        $hostsNeedingReplacement++\r\n                        break  # Found at least one, no need to check more\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if ($hostsNeedingReplacement -eq 0) {\r\n            $isUpToDate = $true\r\n            Write-LogEntry -Message \"Lightweight check: All session hosts are on latest image version $($latestImageVersion.Version)\" -Level Trace\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Lightweight check: Found hosts needing replacement - proceeding with full replacement plan\" -Level Trace\r\n        }\r\n    }\r\n    else {\r\n        # Image is too new - no replacements will be triggered\r\n        $isUpToDate = $true\r\n        Write-LogEntry -Message \"Lightweight check: Latest image is only $([Math]::Round($latestImageAge, 1)) days old (delay: $replaceSessionHostOnNewImageVersionDelayDays days) - no replacements needed\" -Level Trace\r\n    }\r\n}\r\n\r\n# If up to date, skip expensive operations and go straight to early exit path\r\nif ($isUpToDate) {\r\n    Write-LogEntry -Message \"Host pool is UP TO DATE - skipping replacement plan calculation and scaling plan query\"\r\n    \r\n    # Create a minimal replacement plan for early exit logic\r\n    $hostPoolReplacementPlan = [PSCustomObject]@{\r\n        PossibleDeploymentsCount       = 0\r\n        PossibleSessionHostDeleteCount = 0\r\n        SessionHostsPendingDelete      = @()\r\n        ExistingSessionHostNames       = $sessionHostsFiltered.SessionHostName\r\n        TargetSessionHostCount         = $sessionHostsFiltered.Count\r\n        TotalSessionHostsToReplace     = 0\r\n    }\r\n    \r\n    # Skip scaling plan query (not needed when up to date)\r\n    $scalingPlanTarget = $null\r\n}\r\nelse {\r\n    # Host pool needs work - run full replacement plan calculation\r\n    Write-LogEntry -Message \"Host pool requires updates - running full replacement plan calculation\"\r\n    \r\n    # Query scaling plan for dynamic minimum capacity (DeleteFirst mode only)\r\n    # This is ONLY needed when we're actually going to delete hosts\r\n    $scalingPlanTarget = $null\r\n    if ($replacementMode -ieq 'DeleteFirst') {\r\n        try {\r\n            $hostPoolSubscriptionId = Read-FunctionAppSetting HostPoolSubscriptionId\r\n            $hostPoolResourceGroupName = Read-FunctionAppSetting HostPoolResourceGroupName\r\n            $hostPoolName = Read-FunctionAppSetting HostPoolName\r\n            $hostPoolResourceId = \"/subscriptions/$hostPoolSubscriptionId/resourceGroups/$hostPoolResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$hostPoolName\"\r\n            \r\n            Write-LogEntry -Message \"DeleteFirst mode: Querying scaling plan for dynamic minimum capacity target\"\r\n            $scalingPlanTarget = Get-ScalingPlanCurrentTarget -ARMToken $ARMToken -HostPoolResourceId $hostPoolResourceId\r\n            \r\n            if ($scalingPlanTarget -and $scalingPlanTarget.CapacityPercentage) {\r\n                Write-LogEntry -Message \"Dynamic capacity from scaling plan: $($scalingPlanTarget.CapacityPercentage)% (Plan: $($scalingPlanTarget.ScalingPlanName), Schedule: $($scalingPlanTarget.ScheduleName), Phase: $($scalingPlanTarget.Phase))\"\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"No active scaling plan schedule found - will use static MinimumCapacityPercentage setting\"\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to query scaling plan (will use static capacity): $($_.Exception.Message)\" -Level Warning\r\n            $scalingPlanTarget = $null\r\n        }\r\n    }\r\n    \r\n    # Get full replacement plan with all calculations\r\n    $hostPoolReplacementPlan = Get-SessionHostReplacementPlan `\r\n        -ARMToken $ARMToken `\r\n        -SessionHosts $sessionHostsFiltered `\r\n        -RunningDeployments $runningDeployments `\r\n        -LatestImageVersion $latestImageVersion `\r\n        -AllowImageVersionRollback $allowImageVersionRollback `\r\n        -ScalingPlanTarget $scalingPlanTarget `\r\n        -GraphToken $GraphToken `\r\n        -RemoveEntraDevice $removeEntraDevice `\r\n        -RemoveIntuneDevice $removeIntuneDevice\r\n}\r\n\r\n# EARLY EXIT: Check if host pool is up to date (nothing to do)\r\nif ($hostPoolReplacementPlan.TotalSessionHostsToReplace -eq 0 -and \r\n    $hostPoolReplacementPlan.PossibleDeploymentsCount -eq 0 -and \r\n    $hostPoolReplacementPlan.PossibleSessionHostDeleteCount -eq 0 -and\r\n    $runningDeployments.Count -eq 0 -and\r\n    $failedDeployments.Count -eq 0) {\r\n    \r\n    Write-LogEntry -Message \"Host pool is UP TO DATE - all session hosts are on the latest image version and no work is needed.\"\r\n    \r\n    # Update LastImageVersion now that the cycle is complete\r\n    if (Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean) {\r\n        $deploymentState = Get-DeploymentState\r\n        $currentImageVersion = if ($latestImageVersion.Version) { $latestImageVersion.Version } else { 'N/A' }\r\n        \r\n        # Only update if it changed (to avoid unnecessary writes)\r\n        if ($deploymentState.LastImageVersion -ne $currentImageVersion) {\r\n            Write-LogEntry -Message \"Cycle complete - updating LastImageVersion from $($deploymentState.LastImageVersion) to $currentImageVersion\" -Level Trace\r\n            $deploymentState.LastImageVersion = $currentImageVersion\r\n            Save-DeploymentState -DeploymentState $deploymentState\r\n        }\r\n    }\r\n    \r\n    # CRITICAL: Check if scaling exclusion tags need to be removed before exiting\r\n    # This handles the case where tags were set in a previous run but the cycle just completed\r\n    $hostsInDrainMode = ($sessionHostsFiltered | Where-Object { -not $_.AllowNewSession }).Count\r\n    $shutdownRetentionCount = if ($enableShutdownRetention -and $hostsInShutdownRetention) { $hostsInShutdownRetention.Count } else { 0 }\r\n    \r\n    # Check if cycle is truly complete (no hosts in drain mode)\r\n    $cycleComplete = $hostsInDrainMode -eq 0\r\n    \r\n    # In SideBySide mode with shutdown retention: also remove tags from new hosts if old hosts are in retention\r\n    $sideBySideRetentionTransition = $replacementMode -eq 'SideBySide' -and $enableShutdownRetention -and $shutdownRetentionCount -gt 0\r\n    \r\n    if ($cycleComplete -or $sideBySideRetentionTransition) {\r\n        if ($cycleComplete) {\r\n            Write-LogEntry -Message \"Update cycle complete - removing scaling exclusion tags (preserving tags on shutdown retention VMs).\"\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"SideBySide mode with shutdown retention - removing scaling exclusion tags from new active hosts.\"\r\n        }\r\n        \r\n        $tagScalingPlanExclusionTag = Read-FunctionAppSetting Tag_ScalingPlanExclusionTag\r\n        $resourceManagerUri = Get-ResourceManagerUri\r\n        \r\n        # Get list of VMs currently in shutdown retention\r\n        $shutdownRetentionVMs = @()\r\n        if ($enableShutdownRetention) {\r\n            $shutdownRetentionTag = Read-FunctionAppSetting Tag_ShutdownTimestamp\r\n            foreach ($vm in $cachedVMs) {\r\n                if ($vm.tags -and ($vm.tags.PSObject.Properties.Name -contains $shutdownRetentionTag)) {\r\n                    $shutdownRetentionVMs += $vm.name\r\n                }\r\n            }\r\n        }\r\n        \r\n        # Only proceed if a scaling exclusion tag is configured\r\n        if ($tagScalingPlanExclusionTag -and $tagScalingPlanExclusionTag -ne ' ') {\r\n            $hostsWithExclusionTag = 0\r\n            \r\n            foreach ($sessionHost in $sessionHostsFiltered) {\r\n                try {\r\n                    $vmName = $sessionHost.ResourceId.Split('/')[-1]\r\n                    \r\n                    # Skip if this VM is in shutdown retention\r\n                    if ($shutdownRetentionVMs -contains $vmName) {\r\n                        Write-LogEntry -Message \"Preserving scaling exclusion tag on shutdown retention VM: $vmName\" -Level Trace\r\n                        continue\r\n                    }\r\n                    \r\n                    # Check if exclusion tag exists with SessionHostReplacer value\r\n                    $vmTags = $sessionHost.Tags\r\n                    if ($vmTags.ContainsKey($tagScalingPlanExclusionTag) -and $vmTags[$tagScalingPlanExclusionTag] -eq 'SessionHostReplacer') {\r\n                        Write-LogEntry -Message \"Removing scaling exclusion tag from $($sessionHost.SessionHostName)\" -Level Trace\r\n                        \r\n                        $tagsUri = \"$resourceManagerUri$($sessionHost.ResourceId)/providers/Microsoft.Resources/tags/default?api-version=2021-04-01\"\r\n                        $Body = @{\r\n                            operation  = 'Delete'\r\n                            properties = @{\r\n                                tags = @{ $tagScalingPlanExclusionTag = '' }\r\n                            }\r\n                        }\r\n                        \r\n                        Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $tagsUri | Out-Null\r\n                        $hostsWithExclusionTag++\r\n                    }\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"Error removing scaling exclusion tag from $($sessionHost.SessionHostName): $($_.Exception.Message)\" -Level Warning\r\n                }\r\n            }\r\n            \r\n            if ($hostsWithExclusionTag -gt 0) {\r\n                Write-LogEntry -Message \"Removed scaling exclusion tags from {0} session host(s)\" -StringValues $hostsWithExclusionTag\r\n            }\r\n        }\r\n    }\r\n    \r\n    # Log basic metrics for monitoring dashboard\r\n    $metricsLog = @{\r\n        TotalSessionHosts    = $sessionHosts.Count\r\n        EnabledForAutomation = $sessionHostsFiltered.Count\r\n        TargetCount          = if ($hostPoolReplacementPlan.TargetSessionHostCount) { $hostPoolReplacementPlan.TargetSessionHostCount } else { 0 }\r\n        ToReplace            = 0\r\n        ToReplacePercentage  = 0\r\n        InDrain              = $hostsInDrainMode\r\n        PendingDelete        = 0\r\n        ShutdownRetention    = $shutdownRetentionCount\r\n        ToDeployNow          = 0\r\n        RunningDeployments   = 0\r\n        LatestImageVersion   = if ($latestImageVersion.Version) { $latestImageVersion.Version } else { \"N/A\" }\r\n        LatestImageDate      = $latestImageVersion.Date\r\n        Status               = if ($cycleComplete) { \"UpToDate\" } else { \"Draining\" }\r\n    }\r\n    \r\n    # Log image metadata for workbook visibility\r\n    if ($latestImageVersion.Definition -like \"marketplace:*\") {\r\n        $marketplaceParts = $latestImageVersion.Definition -replace \"^marketplace:\", \"\" -split \"/\"\r\n        Write-LogEntry -Message \"IMAGE_INFO | Type: Marketplace | Publisher: {0} | Offer: {1} | Sku: {2} | Version: {3}\" `\r\n            -StringValues $marketplaceParts[0], $marketplaceParts[1], $marketplaceParts[2], $latestImageVersion.Version\r\n    }\r\n    else {\r\n        $galleryMatch = [regex]::Match($latestImageVersion.Definition, \"/galleries/([^/]+)/images/([^/]+)\")\r\n        $galleryName = $galleryMatch.Groups[1].Value\r\n        $imageDefinition = $galleryMatch.Groups[2].Value\r\n        Write-LogEntry -Message \"IMAGE_INFO | Type: Gallery | Gallery: {0} | ImageDefinition: {1} | Version: {2}\" `\r\n            -StringValues $galleryName, $imageDefinition, $latestImageVersion.Version\r\n    }\r\n    \r\n    Write-LogEntry -Message \"METRICS | Total: {0} | Enabled: {1} | Target: {2} | ToReplace: {3} ({4}%) | InDrain: {5} | PendingDelete: {6} | ShutdownRetention: {7} | ToDeployNow: {8} | RunningDeployments: {9} | LatestImage: {10} | Status: {11}\" `\r\n        -StringValues $metricsLog.TotalSessionHosts, $metricsLog.EnabledForAutomation, $metricsLog.TargetCount, $metricsLog.ToReplace, $metricsLog.ToReplacePercentage, $metricsLog.InDrain, $metricsLog.PendingDelete, $metricsLog.ShutdownRetention, $metricsLog.ToDeployNow, $metricsLog.RunningDeployments, $metricsLog.LatestImageVersion, $metricsLog.Status\r\n    \r\n    # Update host pool status tag with current state\r\n    try {\r\n        Update-HostPoolStatus `\r\n            -ARMToken $ARMToken `\r\n            -SessionHosts $sessionHostsFiltered `\r\n            -RunningDeployments 0 `\r\n            -FailedDeployments @() `\r\n            -HostsToReplace 0 `\r\n            -CachedVMs $cachedVMs\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Failed to update host pool status tag: $($_.Exception.Message)\" -Level Warning\r\n    }\r\n    \r\n    # Log completion timestamp for workbook visibility\r\n    Write-LogEntry -Message \"SCHEDULE | Function execution completed at: {0}\" -StringValues (Get-Date -AsUTC -Format 'o')\r\n    Write-LogEntry -Message \"SessionHostReplacer function completed - host pool is up to date\"\r\n    \r\n    return\r\n}\r\n\r\n# Host pool needs work - continue with normal processing\r\nWrite-LogEntry -Message \"Host pool requires updates - proceeding with replacement operations\"\r\n\r\n# Check availability of new session hosts (hosts already on the latest image version)\r\n# This provides metrics for monitoring and is used as a safety check before removing old hosts\r\n# ONLY run this check if there are actually hosts to replace - otherwise shutdown hosts trigger false positives\r\nif ($hostPoolReplacementPlan.TotalSessionHostsToReplace -gt 0) {\r\n    $newHostAvailability = Test-NewSessionHostsAvailable -ARMToken $ARMToken -SessionHosts $sessionHosts -LatestImageVersion $latestImageVersion\r\n}\r\nelse {\r\n    # No hosts need replacement - all hosts are on latest image\r\n    # For metrics purposes, count all enabled hosts as \"new\" (on latest image)\r\n    $hostsOnLatestImage = $sessionHosts | Where-Object { \r\n        $_.ImageVersion -eq $latestImageVersion.Version -and \r\n        -not $_.IsUnavailable\r\n    }\r\n    $availableOnLatest = $hostsOnLatestImage | Where-Object { $_.Status -eq 'Available' }\r\n    \r\n    Write-LogEntry -Message \"All {0} enabled session hosts are on latest image version {1}\" -StringValues $hostsOnLatestImage.Count, $latestImageVersion.Version -Level Trace\r\n    $newHostAvailability = [PSCustomObject]@{\r\n        TotalNewHosts       = $hostsOnLatestImage.Count\r\n        AvailableCount      = $availableOnLatest.Count\r\n        AvailablePercentage = if ($hostsOnLatestImage.Count -gt 0) { [Math]::Round(($availableOnLatest.Count / $hostsOnLatestImage.Count) * 100) } else { 0 }\r\n        SafeToProceed       = $true  # Always safe when no replacements needed\r\n        Message             = \"All session hosts up to date\"\r\n    }\r\n}\r\n\r\n# New cycle detection will now happen earlier in the flow, before replacement plan calculation\r\n\r\n# Check replacement mode to determine execution order\r\n$replacementMode = Read-FunctionAppSetting ReplacementMode\r\nWrite-LogEntry -Message \"Replacement Mode: {0}\" -StringValues $replacementMode\r\n\r\nif ($replacementMode -eq 'DeleteFirst') {\r\n    # ================================================================================================\r\n    # DELETE-FIRST MODE: Delete idle hosts first, then deploy replacements\r\n    # ================================================================================================\r\n    Write-LogEntry -Message \"Using DELETE-FIRST mode: will delete idle hosts before deploying replacements\"\r\n    \r\n    # STEP 1: Delete session hosts first\r\n    $deletedSessionHostNames = @()\r\n    $hostPropertyMapping = @{}\r\n    $deletionResults = $null\r\n    \r\n    # Check if there's a pending host mapping from a previous failed deployment or registration issue\r\n    # PendingHostMappings is essential for DeleteFirst mode to track deleted hosts for name reuse\r\n    $hasPendingUnresolvedHosts = $false\r\n    $deploymentState = Get-DeploymentState\r\n    if ($deploymentState.PendingHostMappings -and $deploymentState.PendingHostMappings -ne '{}') {\r\n        try {\r\n            $hostPropertyMapping = $deploymentState.PendingHostMappings | ConvertFrom-Json -AsHashtable\r\n            Write-LogEntry -Message \"Loaded {0} pending host mapping(s) from previous run\" -StringValues $hostPropertyMapping.Count\r\n                \r\n            # Check if any pending hosts are still unresolved (deleted but not registered)\r\n            $pendingHostNames = $hostPropertyMapping.Keys\r\n            $registeredHostNames = $sessionHosts.SessionHostName\r\n            $unresolvedHosts = $pendingHostNames | Where-Object { $_ -notin $registeredHostNames }\r\n                \r\n            if ($unresolvedHosts.Count -gt 0) {\r\n                $hasPendingUnresolvedHosts = $true\r\n                Write-LogEntry -Message \"CRITICAL: {0} host(s) were previously deleted but not yet registered: {1}\" -StringValues $unresolvedHosts.Count, ($unresolvedHosts -join ', ') -Level Warning\r\n                Write-LogEntry -Message \"BLOCKING new deletions until pending hosts are resolved (deployment failure or registration issue)\" -Level Warning\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"All pending hosts are now registered - clearing mappings\" -Level Trace\r\n                $deploymentState.PendingHostMappings = '{}'\r\n                Save-DeploymentState -DeploymentState $deploymentState\r\n                $hostPropertyMapping = @{}\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to parse pending host mappings: $_\" -Level Warning\r\n            $hostPropertyMapping = @{}\r\n        }\r\n    }\r\n    \r\n    # SAFETY CHECK: Verify any previously deployed new hosts are available before deleting more old capacity\r\n    # This prevents cascading capacity loss if previous deployments created VMs that didn't register properly\r\n    if (-not $newHostAvailability.SafeToProceed -and $newHostAvailability.TotalNewHosts -gt 0) {\r\n        Write-LogEntry -Message \"SAFETY CHECK FAILED: {0}\" -StringValues $newHostAvailability.Message -Level Warning\r\n        Write-LogEntry -Message \"Halting DeleteFirst mode - will not delete old hosts until existing new hosts become available\" -Level Warning\r\n        Write-LogEntry -Message \"This prevents further capacity loss when previous deployments have hosts that aren't accessible\" -Level Warning\r\n        # Skip the entire delete/deploy cycle - exit DeleteFirst flow\r\n    }\r\n    elseif ($hasPendingUnresolvedHosts) {\r\n        Write-LogEntry -Message \"SAFETY CHECK FAILED: Cannot delete more hosts while previous deletions have unresolved deployments or registration issues\" -Level Warning\r\n        Write-LogEntry -Message \"Will retry deployment of pending hosts without deleting additional capacity\" -Level Warning\r\n        # Skip deletion but allow deployment retry below\r\n    }\r\n    else {\r\n        if ($newHostAvailability.TotalNewHosts -gt 0) {\r\n            Write-LogEntry -Message \"SAFETY CHECK PASSED: {0}\" -StringValues $newHostAvailability.Message\r\n        }\r\n\r\n        if ($hostPoolReplacementPlan.PossibleSessionHostDeleteCount -gt 0 -and $hostPoolReplacementPlan.SessionHostsPendingDelete.Count -gt 0) {\r\n            Write-LogEntry -Message \"We can decommission {0} session hosts from this list: {1}\" -StringValues $hostPoolReplacementPlan.SessionHostsPendingDelete.Count, ($hostPoolReplacementPlan.SessionHostsPendingDelete.SessionHostName -join ',')\r\n        \r\n            # Capture the names and dedicated host properties of hosts being deleted so we can reuse them\r\n            $deletedSessionHostNames = $hostPoolReplacementPlan.SessionHostsPendingDelete.SessionHostName\r\n            Write-LogEntry -Message \"Deleted host names will be available for reuse: {0}\" -StringValues ($deletedSessionHostNames -join ',') -Level Trace\r\n        \r\n            # Build mapping of hostname to dedicated host properties for reuse (merge with existing from previous run)\r\n            # IMPORTANT: Include ALL hosts being deleted (even those without dedicated host properties)\r\n            # This ensures we track which hosts need deployment even if deployment fails\r\n            foreach ($sessionHost in $hostPoolReplacementPlan.SessionHostsPendingDelete) {\r\n                # Only add if not already in mapping (preserve previous mappings)\r\n                if (-not $hostPropertyMapping.ContainsKey($sessionHost.SessionHostName)) {\r\n                    $hostPropertyMapping[$sessionHost.SessionHostName] = @{\r\n                        HostId      = $sessionHost.HostId\r\n                        HostGroupId = $sessionHost.HostGroupId\r\n                        Zones       = $sessionHost.Zones\r\n                    }\r\n                    \r\n                    if ($sessionHost.HostId -or $sessionHost.HostGroupId) {\r\n                        Write-LogEntry -Message \"Captured dedicated host properties for {0}: HostId={1}, HostGroupId={2}, Zones={3}\" -StringValues $sessionHost.SessionHostName, $sessionHost.HostId, $sessionHost.HostGroupId, ($sessionHost.Zones -join ', ') -Level Trace\r\n                    }\r\n                    else {\r\n                        Write-LogEntry -Message \"Captured {0} for tracking (no dedicated host properties)\" -StringValues $sessionHost.SessionHostName -Level Trace\r\n                    }\r\n                }\r\n            }\r\n        \r\n            # Save host property mapping to deployment state BEFORE deletion attempt (for recovery if deletion succeeds but deployment fails)\r\n            # This is critical for DeleteFirst mode to track which hosts need deployment\r\n            $deploymentState = Get-DeploymentState\r\n            if ($hostPropertyMapping.Count -gt 0) {\r\n                $deploymentState.PendingHostMappings = ($hostPropertyMapping | ConvertTo-Json -Compress)\r\n                Write-LogEntry -Message \"Saved {0} host property mapping(s) to deployment state before deletion\" -StringValues $hostPropertyMapping.Count -Level Trace\r\n            }\r\n            else {\r\n                $deploymentState.PendingHostMappings = '{}'\r\n            }\r\n            Save-DeploymentState -DeploymentState $deploymentState\r\n\r\n            # Acquire Graph token if device cleanup is enabled\r\n            $GraphToken = $null\r\n            if ($removeEntraDevice -or $removeIntuneDevice) {\r\n                Try {\r\n                    $graphEndpoint = Get-GraphEndpoint\r\n                    $GraphToken = Get-AccessToken -ResourceUri $graphEndpoint\r\n                \r\n                    if ([string]::IsNullOrEmpty($GraphToken)) {\r\n                        Write-LogEntry -Message \"CRITICAL ERROR: Get-AccessToken returned null or empty Graph token but device cleanup is enabled.\" -Level Error\r\n                        Write-LogEntry -Message \"HINT: Ensure the managed identity has Directory.ReadWrite.All (for Entra ID) and DeviceManagementManagedDevices.ReadWrite.All (for Intune) permissions\" -Level Error\r\n                        Write-LogEntry -Message \"Delete-First mode cannot proceed without device cleanup capability - hostname reuse will fail\" -Level Error\r\n                        throw \"Graph token acquisition failed but device cleanup is required in DeleteFirst mode\"\r\n                    }\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"CRITICAL ERROR: Failed to acquire Graph access token but device cleanup is enabled: $_\" -Level Error\r\n                    Write-LogEntry -Message \"HINT: Ensure the managed identity has Cloud Device Administrator role (for Entra ID) and DeviceManagementManagedDevices.ReadWrite.All (for Intune)\" -Level Error\r\n                    Write-LogEntry -Message \"Delete-First mode cannot proceed without device cleanup capability - hostname reuse will fail\" -Level Error\r\n                    throw \"Graph token acquisition failed but device cleanup is required in Delete-First mode\"\r\n                }\r\n            }\r\n        \r\n            # Perform deletion\r\n            $deletionResults = Remove-SessionHosts -ARMToken $ARMToken -GraphToken $GraphToken -SessionHostsPendingDelete $hostPoolReplacementPlan.SessionHostsPendingDelete -RemoveEntraDevice $removeEntraDevice -RemoveIntuneDevice $removeIntuneDevice\r\n        \r\n            # Check deletion results\r\n            if ($deletionResults.FailedDeletions.Count -gt 0) {\r\n                Write-LogEntry -Message \"CRITICAL ERROR: {0} session host deletion(s) failed in Delete-First mode\" -StringValues $deletionResults.FailedDeletions.Count -Level Error\r\n                foreach ($failure in $deletionResults.FailedDeletions) {\r\n                    Write-LogEntry -Message \"  - {0}: {1}\" -StringValues $failure.SessionHostName, $failure.Reason -Level Error\r\n                }\r\n                Write-LogEntry -Message \"Delete-First mode cannot proceed with deployments - hostname conflicts will occur if we try to reuse failed deletion names\" -Level Error\r\n                Write-LogEntry -Message \"Successful deletions: {0}\" -StringValues ($deletionResults.SuccessfulDeletions -join ', ') -Level Trace\r\n                throw \"Session host deletion failures in Delete-First mode prevent safe hostname reuse\"\r\n            }\r\n        \r\n            Write-LogEntry -Message \"Successfully deleted {0} session host(s): {1}\" -StringValues $deletionResults.SuccessfulDeletions.Count, ($deletionResults.SuccessfulDeletions -join ', ')\r\n        \r\n            # Update pending delete list to reflect successful deletions\r\n            if ($deletionResults.SuccessfulDeletions.Count -gt 0) {\r\n                $hostPoolReplacementPlan.SessionHostsPendingDelete = @($hostPoolReplacementPlan.SessionHostsPendingDelete | Where-Object { $_ -notin $deletionResults.SuccessfulDeletions })\r\n                Write-LogEntry -Message \"Updated pending delete count to {0} after removing successfully deleted hosts\" -StringValues $hostPoolReplacementPlan.SessionHostsPendingDelete.Count -Level Trace\r\n            \r\n                # Validate complete deletion (VM, Entra ID, Intune) - BLOCKING in DeleteFirst mode\r\n                $verificationResults = Confirm-SessionHostDeletions `\r\n                    -ARMToken $ARMToken `\r\n                    -GraphToken $GraphToken `\r\n                    -DeletedHostNames $deletionResults.SuccessfulDeletions `\r\n                    -SessionHosts $sessionHosts `\r\n                    -RemoveEntraDevice $removeEntraDevice `\r\n                    -RemoveIntuneDevice $removeIntuneDevice\r\n                \r\n                # In DeleteFirst mode, device cleanup MUST succeed for hostname reuse\r\n                # Check if any hosts have incomplete device cleanup\r\n                $deviceCleanupRequired = $removeEntraDevice -or $removeIntuneDevice\r\n                if ($deviceCleanupRequired -and $verificationResults.IncompleteHosts.Count -gt 0) {\r\n                    Write-LogEntry -Message \"CRITICAL ERROR: Device cleanup incomplete for {0} host(s) in Delete-First mode\" -StringValues $verificationResults.IncompleteHosts.Count -Level Error\r\n                    \r\n                    foreach ($incompleteHost in $verificationResults.IncompleteHosts) {\r\n                        $failures = @()\r\n                        if (-not $incompleteHost.EntraIDConfirmed -and $removeEntraDevice) { $failures += \"Entra ID\" }\r\n                        if (-not $incompleteHost.IntuneConfirmed -and $removeIntuneDevice) { $failures += \"Intune\" }\r\n                        \r\n                        if ($failures.Count -gt 0) {\r\n                            Write-LogEntry -Message \"  - {0}: Device cleanup failed for {1}\" -StringValues $incompleteHost.Name, ($failures -join ', ') -Level Error\r\n                        }\r\n                    }\r\n                    \r\n                    Write-LogEntry -Message \"Delete-First mode cannot proceed - hostname reuse will fail if devices still exist in Entra ID/Intune\" -Level Error\r\n                    Write-LogEntry -Message \"TROUBLESHOOTING: Verify managed identity has Graph API permissions (Device.ReadWrite.All, DeviceManagementManagedDevices.ReadWrite.All)\" -Level Error\r\n                    throw \"Device cleanup verification failed in Delete-First mode - cannot safely reuse hostnames\"\r\n                }\r\n                \r\n                Write-LogEntry -Message \"Device cleanup verification passed - safe to reuse hostnames\" -Level Trace\r\n            }\r\n        \r\n            $deletedSessionHostNames = $deletionResults.SuccessfulDeletions\r\n        \r\n            # Calculate how many net-new hosts we're adding (growing the pool)\r\n            # Example: Current=8, Target=10, Need to replace=1  Deploy 3 (1 replacement + 2 net-new), Delete 1\r\n            # In progressive scale-up scenarios, originalDeployCount may be less than hostsToReplace (batch sizing)\r\n            # Net-new should never be negative - if we're doing batch replacements, net-new = 0\r\n            $hostsToReplace = $hostPoolReplacementPlan.TotalSessionHostsToReplace\r\n            $originalDeployCount = $hostPoolReplacementPlan.PossibleDeploymentsCount\r\n            $netNewHosts = [Math]::Max(0, $originalDeployCount - $hostsToReplace)\r\n            \r\n            # Only limit REPLACEMENT deployments to match successful deletions (don't limit net-new growth)\r\n            # If hosts were drained but not deleted yet, they're still taking up space for replacements\r\n            $maxReplacements = $deletionResults.SuccessfulDeletions.Count\r\n            $actualDeployCount = $maxReplacements + $netNewHosts\r\n            \r\n            if ($actualDeployCount -lt $originalDeployCount) {\r\n                Write-LogEntry -Message \"Delete-First mode: Reducing deployments from {0} to {1} (limited to {2} replacements + {3} net-new, some hosts still draining)\" -StringValues $originalDeployCount, $actualDeployCount, $maxReplacements, $netNewHosts -Level Warning\r\n                $hostPoolReplacementPlan.PossibleDeploymentsCount = $actualDeployCount\r\n            }\r\n        }\r\n    \r\n        # STEP 2: Deploy replacement session hosts\r\n        if ($hostPoolReplacementPlan.PossibleDeploymentsCount -gt 0) {\r\n            Write-LogEntry -Message \"We will deploy {0} replacement session hosts\" -StringValues $hostPoolReplacementPlan.PossibleDeploymentsCount\r\n        \r\n            # In DeleteFirst mode: exclude deleted host names so they can be reused\r\n            # Calculate existing names: all current hosts + running deployments - just deleted hosts\r\n            $currentExistingNames = (@($sessionHosts.SessionHostName) + @($hostPoolReplacementPlan.ExistingSessionHostNames)) | Sort-Object | Select-Object -Unique\r\n            $existingSessionHostNames = $currentExistingNames | Where-Object { $_ -notin $deletedSessionHostNames }\r\n        \r\n            Write-LogEntry -Message \"Excluded {0} deleted host name(s) from existing list to allow reuse\" -StringValues $deletedSessionHostNames.Count -Level Trace\r\n            Write-LogEntry -Message \"Available for reuse: {0}\" -StringValues ($deletedSessionHostNames -join ',') -Level Trace\r\n        \r\n            try {\r\n                $deploymentResult = Deploy-SessionHosts -ARMToken $ARMToken -NewSessionHostsCount $hostPoolReplacementPlan.PossibleDeploymentsCount -ExistingSessionHostNames $existingSessionHostNames -PreferredSessionHostNames $deletedSessionHostNames -PreferredHostProperties $hostPropertyMapping\r\n            \r\n                # Log deployment submission immediately for workbook visibility\r\n                Write-LogEntry -Message \"Deployment submitted: {0} VMs requested, deployment name: {1}\" -StringValues $deploymentResult.SessionHostCount, $deploymentResult.DeploymentName\r\n            \r\n                # Update deployment state for progressive scale-up tracking\r\n                if (Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean) {\r\n                    $deploymentState = Get-DeploymentState               \r\n                    # Save deployment info for checking on next run\r\n                    $deploymentState.LastDeploymentName = $deploymentResult.DeploymentName\r\n                    $deploymentState.LastDeploymentCount = $deploymentResult.SessionHostCount\r\n                    $deploymentState.LastDeploymentNeeded = $hostPoolReplacementPlan.PossibleDeploymentsCount\r\n                    $deploymentState.LastDeploymentPercentage = if ($hostPoolReplacementPlan.PossibleDeploymentsCount -gt 0) { [Math]::Round(($deploymentResult.SessionHostCount / $hostPoolReplacementPlan.PossibleDeploymentsCount) * 100) } else { 0 }\r\n                    $deploymentState.LastTimestamp = Get-Date -AsUTC -Format 'o'                \r\n                    Write-LogEntry -Message \"Deployment submitted: $($deploymentResult.DeploymentName). Status will be checked on next run.\"\r\n                \r\n                    # Save state\r\n                    Save-DeploymentState -DeploymentState $deploymentState\r\n                }\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Deployment failed with error: $_\" -Level Error\r\n            \r\n                # Update state to reflect immediate failure (submission error) if progressive scale-up is enabled\r\n                if ($enableProgressiveScaleUp) {\r\n                    $deploymentState = Get-DeploymentState\r\n                    $deploymentState.ConsecutiveSuccesses = 0\r\n                    $deploymentState.CurrentPercentage = (Read-FunctionAppSetting InitialDeploymentPercentage)\r\n                    $deploymentState.LastStatus = 'Failed'\r\n                    $deploymentState.LastDeploymentName = '' # Clear deployment name since submission failed\r\n                    $deploymentState.LastTimestamp = Get-Date -AsUTC -Format 'o'\r\n                    Save-DeploymentState -DeploymentState $deploymentState\r\n                }            \r\n                throw\r\n            }\r\n        }\r\n    } # End of safety check else block\r\n} # End of DeleteFirst mode\r\nelse {\r\n    # ================================================================================================\r\n    # SIDE-BY-SIDE MODE: Deploy new hosts first, then delete old ones\r\n    # ================================================================================================\r\n    Write-LogEntry -Message \"Using SIDE-BY-SIDE mode: will deploy new hosts before deleting old ones\"\r\n    \r\n    # STEP 1: Deploy new session hosts first\r\n    $deploymentResult = $null\r\n    if ($hostPoolReplacementPlan.PossibleDeploymentsCount -gt 0) {\r\n        Write-LogEntry -Message \"We will deploy {0} session hosts\" -StringValues $hostPoolReplacementPlan.PossibleDeploymentsCount\r\n        # Deploy session hosts - use SessionHostName (hostname from FQDN) not VMName (Azure VM resource name)\r\n        $existingSessionHostNames = (@($sessionHosts.SessionHostName) + @($hostPoolReplacementPlan.ExistingSessionHostNames)) | Sort-Object | Select-Object -Unique\r\n        \r\n        try {\r\n            $deploymentResult = Deploy-SessionHosts -ARMToken $ARMToken -NewSessionHostsCount $hostPoolReplacementPlan.PossibleDeploymentsCount -ExistingSessionHostNames $existingSessionHostNames\r\n            \r\n            # Log deployment submission immediately for workbook visibility\r\n            Write-LogEntry -Message \"Deployment submitted: {0} VMs requested, deployment name: {1}\" -StringValues $deploymentResult.SessionHostCount, $deploymentResult.DeploymentName\r\n            \r\n            # Update deployment state for progressive scale-up tracking\r\n            if (Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean) {\r\n                $deploymentState = Get-DeploymentState\r\n                \r\n                # Save deployment info for checking on next run\r\n                $deploymentState.LastDeploymentName = $deploymentResult.DeploymentName\r\n                $deploymentState.LastDeploymentCount = $deploymentResult.SessionHostCount\r\n                $deploymentState.LastDeploymentNeeded = $hostPoolReplacementPlan.PossibleDeploymentsCount\r\n                $deploymentState.LastDeploymentPercentage = if ($hostPoolReplacementPlan.PossibleDeploymentsCount -gt 0) {\r\n                    [Math]::Round(($deploymentResult.SessionHostCount / $hostPoolReplacementPlan.PossibleDeploymentsCount) * 100)\r\n                }\r\n                else { 0 }\r\n                $deploymentState.LastTimestamp = Get-Date -AsUTC -Format 'o'\r\n                \r\n                Write-LogEntry -Message \"Deployment submitted: $($deploymentResult.DeploymentName). Status will be checked on next run.\"\r\n                \r\n                # Save state\r\n                Save-DeploymentState -DeploymentState $deploymentState\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Deployment failed with error: $_\" -Level Error\r\n            \r\n            # Update state to reflect immediate failure (submission error) if progressive scale-up is enabled\r\n            if ($enableProgressiveScaleUp) {\r\n                $deploymentState = Get-DeploymentState\r\n                $deploymentState.ConsecutiveSuccesses = 0\r\n                $deploymentState.CurrentPercentage = (Read-FunctionAppSetting InitialDeploymentPercentage)\r\n                $deploymentState.LastStatus = 'Failed'\r\n                $deploymentState.LastDeploymentName = '' # Clear deployment name since submission failed\r\n                $deploymentState.LastTimestamp = Get-Date -AsUTC -Format 'o'\r\n                Save-DeploymentState -DeploymentState $deploymentState\r\n            }            \r\n            throw\r\n        }\r\n    }\r\n\r\n    # STEP 2: Verify new session hosts are available before removing old ones (safety check)\r\n    # This prevents capacity loss if newly deployed hosts fail to register or pass health checks\r\n    if (-not $newHostAvailability.SafeToProceed -and $newHostAvailability.TotalNewHosts -gt 0) {\r\n        Write-LogEntry -Message \"SAFETY CHECK FAILED: {0}\" -StringValues $newHostAvailability.Message -Level Warning\r\n        Write-LogEntry -Message \"Skipping old host removal to preserve capacity until new hosts become available\" -Level Warning\r\n        # Don't proceed with deletion - exit the SideBySide flow here\r\n    }\r\n    elseif ($newHostAvailability.TotalNewHosts -gt 0) {\r\n        Write-LogEntry -Message \"SAFETY CHECK PASSED: {0}\" -StringValues $newHostAvailability.Message\r\n    }\r\n\r\n    # STEP 3: Delete session hosts (only if safety check passed or no new hosts to verify)\r\n    if (($newHostAvailability.SafeToProceed -or $newHostAvailability.TotalNewHosts -eq 0) -and $hostPoolReplacementPlan.PossibleSessionHostDeleteCount -gt 0 -and $hostPoolReplacementPlan.SessionHostsPendingDelete.Count -gt 0) {\r\n        Write-LogEntry -Message \"We will decommission {0} session hosts from this list: {1}\" -StringValues $hostPoolReplacementPlan.SessionHostsPendingDelete.Count, ($hostPoolReplacementPlan.SessionHostsPendingDelete.SessionHostName -join ',') -Level Trace\r\n               \r\n        # Acquire Graph token if device cleanup is enabled\r\n        if ($removeEntraDevice -or $removeIntuneDevice) {\r\n            Try {\r\n                $graphEndpoint = Get-GraphEndpoint\r\n                $GraphToken = Get-AccessToken -ResourceUri $graphEndpoint\r\n                \r\n                if ([string]::IsNullOrEmpty($GraphToken)) {\r\n                    Write-Warning \"Get-AccessToken returned null or empty Graph token. Device cleanup will be skipped.\"\r\n                    Write-LogEntry -Message \"HINT: Ensure the managed identity has Directory.ReadWrite.All (for Entra ID) and DeviceManagementManagedDevices.ReadWrite.All (for Intune) permissions\" -Level Warning\r\n                    $GraphToken = $null\r\n                }\r\n            }\r\n            catch {\r\n                Write-Warning \"Failed to acquire Graph access token: $_. Device cleanup will be skipped.\"\r\n                Write-LogEntry -Message \"HINT: Ensure the managed identity has Cloud Device Administrator role (for Entra ID) and DeviceManagementManagedDevices.ReadWrite.All (for Intune)\" -Level Warning\r\n                $GraphToken = $null\r\n            }\r\n        }\r\n        \r\n        # Perform deletion and log results (SideBySide mode doesn't halt on failures since name reuse isn't critical)\r\n        $deletionResults = $null\r\n        If ($GraphToken) {\r\n            $deletionResults = Remove-SessionHosts -ARMToken $ARMToken -GraphToken $GraphToken -SessionHostsPendingDelete $hostPoolReplacementPlan.SessionHostsPendingDelete -RemoveEntraDevice $removeEntraDevice -RemoveIntuneDevice $removeIntuneDevice\r\n        }\r\n        Else {\r\n            $deletionResults = Remove-SessionHosts -ARMToken $ARMToken -GraphToken $null -SessionHostsPendingDelete $hostPoolReplacementPlan.SessionHostsPendingDelete -RemoveEntraDevice $false -RemoveIntuneDevice $false\r\n        }\r\n        \r\n        # Log results (but don't halt in SideBySide mode)\r\n        if ($deletionResults) {\r\n            if ($deletionResults.FailedDeletions.Count -gt 0) {\r\n                Write-LogEntry -Message \"Warning: {0} session host deletion(s) failed\" -StringValues $deletionResults.FailedDeletions.Count -Level Warning\r\n                foreach ($failure in $deletionResults.FailedDeletions) {\r\n                    Write-LogEntry -Message \"  - {0}: {1}\" -StringValues $failure.SessionHostName, $failure.Reason -Level Warning\r\n                }\r\n            }\r\n            if ($deletionResults.SuccessfulDeletions.Count -gt 0) {\r\n                Write-LogEntry -Message \"Deleted {0} session host(s): {1}\" -StringValues $deletionResults.SuccessfulDeletions.Count, ($deletionResults.SuccessfulDeletions -join ', ')\r\n                \r\n                # Update pending delete list to reflect successful deletions\r\n                $hostPoolReplacementPlan.SessionHostsPendingDelete = @($hostPoolReplacementPlan.SessionHostsPendingDelete | Where-Object { $_ -notin $deletionResults.SuccessfulDeletions })\r\n                Write-LogEntry -Message \"Updated pending delete count to {0} after removing successfully deleted hosts\" -StringValues $hostPoolReplacementPlan.SessionHostsPendingDelete.Count -Level Trace\r\n                \r\n                # Validate complete deletion (VM, Entra ID, Intune)\r\n                Confirm-SessionHostDeletions `\r\n                    -ARMToken $ARMToken `\r\n                    -GraphToken $GraphToken `\r\n                    -DeletedHostNames $deletionResults.SuccessfulDeletions `\r\n                    -SessionHosts $sessionHosts `\r\n                    -RemoveEntraDevice $removeEntraDevice `\r\n                    -RemoveIntuneDevice $removeIntuneDevice | Out-Null\r\n            }\r\n            if ($deletionResults.SuccessfulShutdowns.Count -gt 0) {\r\n                Write-LogEntry -Message \"Successfully shutdown {0} session host(s) for retention: {1}\" -StringValues $deletionResults.SuccessfulShutdowns.Count, ($deletionResults.SuccessfulShutdowns -join ', ')\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n# Log comprehensive metrics for monitoring dashboard (after all operations complete)\r\n$hostsInDrainMode = ($sessionHostsFiltered | Where-Object { -not $_.AllowNewSession }).Count\r\n\r\n# Calculate current deployment status accounting for just-submitted deployments\r\n$currentlyDeploying = $runningDeployments.Count\r\n$remainingToDeploy = $hostPoolReplacementPlan.PossibleDeploymentsCount\r\nif ($deploymentResult) {\r\n    # A deployment was just submitted this run, so it's now running\r\n    $currentlyDeploying += $deploymentResult.SessionHostCount\r\n    # Reduce the remaining count by what was just deployed\r\n    $remainingToDeploy = [Math]::Max(0, $remainingToDeploy - $deploymentResult.SessionHostCount)\r\n}\r\n\r\n# Count VMs in shutdown retention for metrics (use count from earlier calculation to avoid stale cache issues)\r\n$shutdownRetentionCount = if ($enableShutdownRetention -and $hostsInShutdownRetention) { $hostsInShutdownRetention.Count } else { 0 }\r\n\r\n# Calculate actual current counts by subtracting completed deletions from initial counts\r\n$completedDeletionsCount = if ($deletionResults -and $deletionResults.SuccessfulDeletions) { $deletionResults.SuccessfulDeletions.Count } else { 0 }\r\n$completedShutdownsCount = if ($deletionResults -and $deletionResults.SuccessfulShutdowns) { $deletionResults.SuccessfulShutdowns.Count } else { 0 }\r\n$currentSessionHostCount = $sessionHosts.Count - $completedDeletionsCount\r\n$currentEnabledCount = $sessionHostsFiltered.Count - $completedDeletionsCount\r\n\r\n# Adjust ToReplace to reflect completed deletions AND shutdowns in BOTH modes\r\n# Once hosts are deleted OR shutdown (regardless of mode), they no longer need replacement\r\n# - SuccessfulDeletions: Hosts fully removed (VM + devices deleted)\r\n# - SuccessfulShutdowns: Hosts powered off for retention (effectively replaced, kept as backup)\r\n# DeleteFirst: Deletes first, then deploys replacements with name reuse\r\n# SideBySide: Deploys first, then deletes/shuts down old hosts (both reduce ToReplace count)\r\n$totalReplacementOperations = $completedDeletionsCount + $completedShutdownsCount\r\n$remainingToReplace = $hostPoolReplacementPlan.TotalSessionHostsToReplace\r\nif ($totalReplacementOperations -gt 0) {\r\n    $remainingToReplace = [Math]::Max(0, $hostPoolReplacementPlan.TotalSessionHostsToReplace - $totalReplacementOperations)\r\n}\r\n\r\n$metricsLog = @{\r\n    TotalSessionHosts     = $currentSessionHostCount\r\n    EnabledForAutomation  = $currentEnabledCount\r\n    TargetCount           = if ($hostPoolReplacementPlan.TargetSessionHostCount) { $hostPoolReplacementPlan.TargetSessionHostCount } else { 0 }\r\n    ToReplace             = $remainingToReplace\r\n    ToReplacePercentage   = if ($hostPoolReplacementPlan.TargetSessionHostCount -gt 0) { [math]::Round(($remainingToReplace / $hostPoolReplacementPlan.TargetSessionHostCount) * 100, 1) } else { 0 }\r\n    InDrain               = $hostsInDrainMode\r\n    PendingDelete         = [Math]::Max(0, $hostPoolReplacementPlan.SessionHostsPendingDelete.Count - $totalReplacementOperations)\r\n    ShutdownRetention     = $shutdownRetentionCount\r\n    ToDeployNow           = $remainingToDeploy\r\n    RunningDeployments    = $currentlyDeploying\r\n    NewHostsTotal         = $newHostAvailability.TotalNewHosts\r\n    NewHostsAvailable     = $newHostAvailability.AvailableCount\r\n    NewHostsAvailablePct  = $newHostAvailability.AvailablePercentage\r\n    NewHostsSafeToProceed = $newHostAvailability.SafeToProceed\r\n    LatestImageVersion    = if ($latestImageVersion.Version) { $latestImageVersion.Version } else { \"N/A\" }\r\n    LatestImageDate       = $latestImageVersion.Date\r\n}\r\n\r\n# Log image metadata for workbook visibility\r\nif ($latestImageVersion.Definition -like \"marketplace:*\") {\r\n    # Parse marketplace identifier: \"marketplace:publisher/offer/sku\"\r\n    $marketplaceParts = $latestImageVersion.Definition -replace \"^marketplace:\", \"\" -split \"/\"\r\n    Write-LogEntry -Message \"IMAGE_INFO | Type: Marketplace | Publisher: {0} | Offer: {1} | Sku: {2} | Version: {3}\" `\r\n        -StringValues $marketplaceParts[0], $marketplaceParts[1], $marketplaceParts[2], $latestImageVersion.Version\r\n}\r\nelse {\r\n    # Parse gallery path: /subscriptions/.../resourceGroups/.../providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}\r\n    $galleryMatch = [regex]::Match($latestImageVersion.Definition, \"/galleries/([^/]+)/images/([^/]+)\")\r\n    $galleryName = $galleryMatch.Groups[1].Value\r\n    $imageDefinition = $galleryMatch.Groups[2].Value\r\n    Write-LogEntry -Message \"IMAGE_INFO | Type: Gallery | Gallery: {0} | ImageDefinition: {1} | Version: {2}\" `\r\n        -StringValues $galleryName, $imageDefinition, $latestImageVersion.Version\r\n}\r\n\r\n# Check if cycle is complete (no hosts to replace, no hosts in drain, no pending deletions, no running deployments)\r\n# If complete, remove scaling exclusion tags from all hosts (EXCEPT shutdown retention VMs)\r\n$cycleComplete = $metricsLog.ToReplace -eq 0 -and $metricsLog.InDrain -eq 0 -and $metricsLog.PendingDelete -eq 0 -and $metricsLog.RunningDeployments -eq 0\r\n\r\n# In SideBySide mode with shutdown retention: also remove tags from new hosts if old hosts are in retention (even if cycle not fully complete)\r\n# This allows scaling plan to manage new capacity while old hosts remain protected during retention period\r\n$sideBySideRetentionTransition = $replacementMode -eq 'SideBySide' -and $enableShutdownRetention -and $shutdownRetentionCount -gt 0 -and $metricsLog.ToReplace -eq 0 -and $metricsLog.RunningDeployments -eq 0\r\n\r\nif ($cycleComplete -or $sideBySideRetentionTransition) {\r\n    if ($cycleComplete) {\r\n        Write-LogEntry -Message \"Update cycle complete - all hosts are up to date. Removing scaling exclusion tags (preserving tags on shutdown retention VMs).\"\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"SideBySide mode with shutdown retention - removing scaling exclusion tags from new active hosts (preserving tags on shutdown retention VMs).\"\r\n    }\r\n    \r\n    $tagScalingPlanExclusionTag = Read-FunctionAppSetting Tag_ScalingPlanExclusionTag\r\n    $resourceManagerUri = Get-ResourceManagerUri\r\n    \r\n    # Get list of VMs currently in shutdown retention (deallocated with retention tag)\r\n    $shutdownRetentionVMs = @()\r\n    if ($enableShutdownRetention) {\r\n        $shutdownRetentionTag = Read-FunctionAppSetting Tag_ShutdownTimestamp\r\n        foreach ($vm in $cachedVMs) {\r\n            if ($vm.tags -and ($vm.tags.PSObject.Properties.Name -contains $shutdownRetentionTag)) {\r\n                $vmName = $vm.name\r\n                $shutdownRetentionVMs += $vmName\r\n                Write-LogEntry -Message \"VM $vmName has shutdown retention tag - will preserve scaling exclusion tag\" -Level Trace\r\n            }\r\n        }\r\n    }\r\n    \r\n    # Only proceed if a scaling exclusion tag is configured\r\n    if ($tagScalingPlanExclusionTag -and $tagScalingPlanExclusionTag -ne ' ') {\r\n        $hostsWithExclusionTag = 0\r\n        \r\n        foreach ($sessionHost in $sessionHostsFiltered) {\r\n            try {\r\n                # Get VM name from session host\r\n                $vmName = $sessionHost.ResourceId.Split('/')[-1]\r\n                \r\n                # Skip if this VM is in shutdown retention\r\n                if ($shutdownRetentionVMs -contains $vmName) {\r\n                    Write-LogEntry -Message \"Preserving scaling exclusion tag on shutdown retention VM: $vmName\" -Level Trace\r\n                    continue\r\n                }\r\n                \r\n                # Use cached tags from session host object (already fetched in Get-SessionHosts)\r\n                $vmTags = $sessionHost.Tags\r\n                \r\n                # If the exclusion tag exists and has the SessionHostReplacer value (function-set), remove it\r\n                if ($vmTags.ContainsKey($tagScalingPlanExclusionTag)) {\r\n                    $tagValue = $vmTags[$tagScalingPlanExclusionTag]\r\n                    \r\n                    # Only remove if the tag value is 'SessionHostReplacer' (set by this function)\r\n                    # This prevents removing admin-set tags which typically have blank values or custom strings\r\n                    if ($tagValue -eq 'SessionHostReplacer') {\r\n                        Write-LogEntry -Message \"Removing scaling exclusion tag from $($sessionHost.SessionHostName) (value: $tagValue)\"\r\n                        \r\n                        # Remove the tag using Delete operation\r\n                        $tagsUri = \"$resourceManagerUri$($sessionHost.ResourceId)/providers/Microsoft.Resources/tags/default?api-version=2021-04-01\"\r\n                        $Body = @{\r\n                            operation  = 'Delete'\r\n                            properties = @{\r\n                                tags = @{ $tagScalingPlanExclusionTag = '' }\r\n                            }\r\n                        }\r\n                        \r\n                        Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $tagsUri | Out-Null\r\n                        $hostsWithExclusionTag++\r\n                        \r\n                        Write-LogEntry -Message \"Successfully removed scaling exclusion tag from $($sessionHost.SessionHostName)\" -Level Trace\r\n                    }\r\n                    else {\r\n                        Write-LogEntry -Message \"Skipping removal of scaling exclusion tag from $($sessionHost.SessionHostName) - appears to be admin-set (value: '$tagValue')\"\r\n                    }\r\n                }\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Error removing scaling exclusion tag from $($sessionHost.SessionHostName): $($_.Exception.Message)\" -Level Warning\r\n            }\r\n        }\r\n        \r\n        if ($hostsWithExclusionTag -gt 0) {\r\n            Write-LogEntry -Message \"Removed scaling exclusion tags from {0} session host(s)\" -StringValues $hostsWithExclusionTag\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"No scaling exclusion tags found to remove\" -Level Trace\r\n        }\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"No scaling exclusion tag configured - skipping tag cleanup\" -Level Trace\r\n    }\r\n}\r\n\r\nWrite-LogEntry -Message \"METRICS | Total: {0} | Enabled: {1} | Target: {2} | ToReplace: {3} ({4}%) | InDrain: {5} | PendingDelete: {6} | ShutdownRetention: {7} | ToDeployNow: {8} | RunningDeployments: {9} | NewHosts: {10}/{11} ({12}%) Available | LatestImage: {13}\" `\r\n    -StringValues $metricsLog.TotalSessionHosts, $metricsLog.EnabledForAutomation, $metricsLog.TargetCount, $metricsLog.ToReplace, $metricsLog.ToReplacePercentage, $metricsLog.InDrain, $metricsLog.PendingDelete, $metricsLog.ShutdownRetention, $metricsLog.ToDeployNow, $metricsLog.RunningDeployments, $metricsLog.NewHostsAvailable, $metricsLog.NewHostsTotal, $metricsLog.NewHostsAvailablePct, $metricsLog.LatestImageVersion\r\n\r\n# Update host pool status tag with current state\r\ntry {\r\n    Update-HostPoolStatus `\r\n        -ARMToken $ARMToken `\r\n        -SessionHosts $sessionHostsFiltered `\r\n        -RunningDeployments $currentlyDeploying `\r\n        -FailedDeployments $failedDeployments `\r\n        -HostsToReplace $metricsLog.ToReplace `\r\n        -CachedVMs $cachedVMs\r\n}\r\ncatch {\r\n    Write-LogEntry -Message \"Failed to update host pool status tag: $($_.Exception.Message)\" -Level Warning\r\n}\r\n\r\n# Update deployment state with current ToReplace count for new cycle detection\r\nif (Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean) {\r\n    try {\r\n        $deploymentState = Get-DeploymentState\r\n        $deploymentState.LastTotalToReplace = $metricsLog.ToReplace\r\n        Save-DeploymentState -DeploymentState $deploymentState\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Failed to update LastTotalToReplace in deployment state: $($_.Exception.Message)\" -Level Warning\r\n    }\r\n}\r\n\r\n# Log completion timestamp for workbook visibility\r\nWrite-LogEntry -Message \"SCHEDULE | Function execution completed at: {0}\" -StringValues (Get-Date -AsUTC -Format 'o')",
    "$fxv#3": "# Azure Functions profile.ps1\r\n#\r\n# This profile is loaded at function app startup. Keep it minimal - use modules for heavy lifting.\r\n#\r\n\r\n# Configure TLS 1.2 and 1.3 support for secure connections\r\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 -bor [Net.SecurityProtocolType]::Tls13\r\n\r\n# Determine the correct path to the Modules directory\r\n# In Azure Functions, profile.ps1 is in the parent directory, so modules are at ./Modules\r\n\r\n$ModulePath = (Get-ChildItem -Path $PSScriptRoot -Filter SessionHostReplacer.psd1 -Recurse).FullName\r\n\r\nif ($modulePath) {\r\n    Import-Module $modulePath -Force -ErrorAction Stop\r\n    Write-Information \"SessionHostReplacer module loaded successfully from $modulePath\" -InformationAction Continue\r\n} else {\r\n    Write-Error \"Module not found\"\r\n    throw \"Failed to load SessionHostReplacer module\"\r\n}\r\n",
    "$fxv#4": "# This file enables modules to be automatically managed by the Functions service.\r\n# See https://aka.ms/functionsmanageddependency for additional information.\r\n#\r\n@{\r\n    # For latest supported version, go to 'https://www.powershellgallery.com/packages/Az'. \r\n    # To use the Az module in your function app, uncomment the line below.\r\n    # 'Az' = '17.*'\r\n}\r\n",
    "$fxv#5": "# SessionHostReplacer Core Utility Module\r\n# This module contains core utility functions for AVD Session Host Replacer\r\n# Imported by SessionHostReplacer.psm1\r\n\r\n#Region Module-Level Variables\r\n\r\n# Setting cache to avoid repeated environment variable reads\r\n$Script:SettingCache = @{}\r\n\r\n# Cached and normalized ResourceManagerUri without trailing slash\r\n$script:ResourceManagerUri = $null\r\n\r\n# Cached and normalized GraphEndpoint without trailing slash\r\n$script:GraphEndpoint = $null\r\n\r\n#EndRegion Module-Level Variables\r\n\r\n#Region Helper Functions\r\n\r\nfunction ConvertTo-CaseInsensitiveHashtable {\r\n    <#\r\n    .SYNOPSIS\r\n        Converts objects to case-insensitive hashtables.\r\n    .DESCRIPTION\r\n        Converts hashtables, PSCustomObjects, OrderedDictionaries, and JSON strings to case-insensitive hashtables.\r\n    .PARAMETER InputObject\r\n        The object to convert.\r\n    .EXAMPLE\r\n        $params = @{Name='Test'; Value='123'} | ConvertTo-CaseInsensitiveHashtable\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]\r\n        $InputObject\r\n    )\r\n    \r\n    process {\r\n        if ($null -eq $InputObject) {\r\n            return $null\r\n        }\r\n        \r\n        # If already a hashtable, convert to case-insensitive\r\n        if ($InputObject -is [hashtable]) {\r\n            $ciHashtable = New-Object 'System.Collections.Hashtable' -ArgumentList ([System.StringComparer]::OrdinalIgnoreCase)\r\n            foreach ($key in $InputObject.Keys) {\r\n                $value = $InputObject[$key]\r\n                # Recursively convert nested hashtables\r\n                if ($value -is [hashtable] -or $value -is [PSCustomObject]) {\r\n                    $ciHashtable[$key] = ConvertTo-CaseInsensitiveHashtable -InputObject $value\r\n                }\r\n                else {\r\n                    $ciHashtable[$key] = $value\r\n                }\r\n            }\r\n            return $ciHashtable\r\n        }\r\n        \r\n        # If PSCustomObject or OrderedDictionary, convert to case-insensitive hashtable\r\n        if ($InputObject -is [PSCustomObject] -or $InputObject -is [System.Collections.Specialized.OrderedDictionary]) {\r\n            $ciHashtable = New-Object 'System.Collections.Hashtable' -ArgumentList ([System.StringComparer]::OrdinalIgnoreCase)\r\n            foreach ($property in $InputObject.PSObject.Properties) {\r\n                $value = $property.Value\r\n                # Recursively convert nested objects\r\n                if ($value -is [hashtable] -or $value -is [PSCustomObject]) {\r\n                    $ciHashtable[$property.Name] = ConvertTo-CaseInsensitiveHashtable -InputObject $value\r\n                }\r\n                else {\r\n                    $ciHashtable[$property.Name] = $value\r\n                }\r\n            }\r\n            return $ciHashtable\r\n        }\r\n        \r\n        # If JSON string, parse and convert\r\n        if ($InputObject -is [string]) {\r\n            try {\r\n                $parsed = $InputObject | ConvertFrom-Json\r\n                return ConvertTo-CaseInsensitiveHashtable -InputObject $parsed\r\n            }\r\n            catch {\r\n                Write-Error \"Unable to parse string as JSON: $_\"\r\n                return $null\r\n            }\r\n        }\r\n        \r\n        # Return as-is if cannot convert\r\n        Write-Warning \"InputObject type [$($InputObject.GetType().Name)] cannot be converted to case-insensitive hashtable\"\r\n        return $InputObject\r\n    }\r\n}\r\n\r\nfunction Get-ResourceManagerUri {\r\n    <#\r\n    .SYNOPSIS\r\n        Gets the ResourceManagerUri without trailing slash.\r\n    .DESCRIPTION\r\n        Retrieves ResourceManagerUri from configuration and ensures it never ends with a trailing slash\r\n        for consistent URI building across all functions. Value is cached for performance.\r\n    .EXAMPLE\r\n        $uri = Get-ResourceManagerUri\r\n    #>\r\n    if ($null -eq $script:ResourceManagerUri) {\r\n        $uri = Read-FunctionAppSetting ResourceManagerUri\r\n        # Remove trailing slash for consistent URI building\r\n        $script:ResourceManagerUri = if ($uri -and $uri[-1] -eq '/') { $uri.TrimEnd('/') } else { $uri }\r\n    }\r\n    return $script:ResourceManagerUri\r\n}\r\n\r\nfunction Get-GraphEndpoint {\r\n    <#\r\n    .SYNOPSIS\r\n        Gets the Microsoft Graph endpoint without trailing slash.\r\n    .DESCRIPTION\r\n        Retrieves GraphEndpoint from configuration and ensures it never ends with a trailing slash\r\n        for consistent URI building. Value is cached for performance.\r\n    .EXAMPLE\r\n        $endpoint = Get-GraphEndpoint\r\n    #>\r\n    if ($null -eq $script:GraphEndpoint) {\r\n        $endpoint = Read-FunctionAppSetting GraphEndpoint\r\n        # Remove trailing slash for consistent URI building\r\n        $script:GraphEndpoint = if ($endpoint -and $endpoint[-1] -eq '/') { $endpoint.TrimEnd('/') } else { $endpoint }\r\n    }\r\n    return $script:GraphEndpoint\r\n}\r\n\r\n#EndRegion Helper Functions\r\n\r\n#Region Authentication Functions\r\n\r\nfunction Get-AccessToken {\r\n    <#\r\n    .SYNOPSIS\r\n        Retrieves Azure access token using Managed Identity.\r\n    .DESCRIPTION\r\n        Acquires an access token for Azure services using the function app's managed identity.\r\n        Supports both system-assigned and user-assigned managed identities.\r\n        - If ClientId is provided (or UserAssignedIdentityClientId setting is configured), uses user-assigned identity\r\n        - If ClientId is null/empty, uses system-assigned identity\r\n        Tokens are requested fresh on each call to avoid caching complexity.\r\n    .PARAMETER ResourceUri\r\n        The Azure resource endpoint URL (e.g., https://management.azure.com/, https://graph.microsoft.com).\r\n    .PARAMETER ClientId\r\n        Optional. The client ID of the user-assigned managed identity. \r\n        If not specified, attempts to read from UserAssignedIdentityClientId app setting.\r\n        If still null/empty, uses system-assigned managed identity.\r\n    .EXAMPLE\r\n        # Use system-assigned managed identity\r\n        $token = Get-AccessToken -ResourceUri 'https://management.azure.com/' -ClientId ''\r\n    .EXAMPLE\r\n        # Use user-assigned managed identity with explicit ClientId\r\n        $token = Get-AccessToken -ResourceUri 'https://graph.microsoft.com' -ClientId 'abc123...'\r\n    .EXAMPLE\r\n        # Use user-assigned managed identity from app settings (default behavior)\r\n        $token = Get-AccessToken -ResourceUri 'https://management.azure.com/'\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ResourceUri,\r\n        \r\n        [Parameter(Mandatory = $false)]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    # Determine token type for logging\r\n    $isARMToken = $ResourceUri -like \"*management*\"\r\n    $isGraphToken = $ResourceUri -like \"*graph*\"\r\n    $isStorageToken = $ResourceUri -like \"*storage*\" -or $ResourceUri -like \"*.table.*\" -or $ResourceUri -like \"*.blob.*\"\r\n    \r\n    # ARM tokens require trailing slash, Graph and Storage tokens should NOT have trailing slash\r\n    $tokenResourceUri = if ($isARMToken) {\r\n        # ARM: requires trailing slash\r\n        $uri = if ($ResourceUri[-1] -ne '/') { \"$ResourceUri/\" } else { $ResourceUri }\r\n        Write-Verbose \"Requesting ARM token for resource: $uri (with trailing slash)\"\r\n        $uri\r\n    }\r\n    else {        \r\n        # Graph and Storage: NO trailing slash\r\n        $uri = if ($ResourceUri[-1] -eq '/') { $ResourceUri.TrimEnd('/') } else { $ResourceUri }\r\n        $tokenType = if ($isGraphToken) { \"Graph\" } elseif ($isStorageToken) { \"Storage\" } else { \"Other\" }\r\n        Write-Verbose \"Requesting $tokenType token for resource: $uri (no trailing slash)\"\r\n        $uri\r\n    }\r\n    \r\n    # Acquire token from managed identity\r\n    # Build token URI - only include client_id parameter for user-assigned identity\r\n    if ([string]::IsNullOrEmpty($ClientId)) {\r\n        # System-assigned managed identity\r\n        Write-Verbose \"Acquiring token using system-assigned managed identity for resource: $tokenResourceUri\"\r\n        $TokenAuthURI = $env:IDENTITY_ENDPOINT + '?resource=' + $tokenResourceUri + '&api-version=2019-08-01'\r\n    }\r\n    else {\r\n        # User-assigned managed identity\r\n        Write-Verbose \"Acquiring token using user-assigned managed identity (ClientId: $ClientId) for resource: $tokenResourceUri\"\r\n        $TokenAuthURI = $env:IDENTITY_ENDPOINT + '?resource=' + $tokenResourceUri + \"&client_id=$ClientId\" + '&api-version=2019-08-01'\r\n    }\r\n       \r\n    # Add cache-busting headers to force fresh token acquisition\r\n    $headers = @{\r\n        \"X-IDENTITY-HEADER\" = $env:IDENTITY_HEADER\r\n    }\r\n    \r\n    $TokenResponse = Invoke-RestMethod -Method Get -Headers $headers -Uri $TokenAuthURI -DisableKeepAlive\r\n    \r\n    Write-Verbose \"Successfully acquired token for $tokenResourceUri\"\r\n    \r\n    return $TokenResponse.access_token\r\n}\r\n\r\n#EndRegion Authentication Functions\r\n\r\n#Region Configuration Functions\r\n\r\nfunction Read-FunctionAppSetting {\r\n    <#\r\n    .SYNOPSIS\r\n        Retrieves configuration values from Azure Function App Settings with caching.\r\n    .DESCRIPTION\r\n        Reads values from environment variables with automatic type conversion and caching\r\n        to avoid repeated environment variable reads during execution.\r\n    .PARAMETER ConfigKey\r\n        The name of the configuration key to retrieve from environment variables.\r\n    .PARAMETER NoCache\r\n        Optional. Bypass the cache and read directly from environment variable.\r\n    .PARAMETER AsBoolean\r\n        Optional. Process the value as a boolean.\r\n    .EXAMPLE\r\n        $hostPoolName = Read-FunctionAppSetting HostPoolName\r\n    .EXAMPLE\r\n        $value = Read-FunctionAppSetting 'SomeSetting' -NoCache\r\n    .EXAMPLE\r\n        $enabled = Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true, Position = 0)]\r\n        [string] $SettingKey,\r\n        \r\n        [Parameter(Mandatory = $false)]\r\n        [switch] $NoCache,\r\n        \r\n        [Parameter(Mandatory = $false)]\r\n        [switch] $AsBoolean\r\n    )\r\n    \r\n    # Check cache first unless NoCache is specified\r\n    if (-not $NoCache -and $Script:SettingCache.ContainsKey($SettingKey)) {\r\n        Write-Verbose \"Using cached value for $SettingKey\"\r\n        return $Script:SettingCache[$SettingKey]\r\n    }\r\n    \r\n    # Get the value from environment variable\r\n    $value = [System.Environment]::GetEnvironmentVariable($SettingKey)\r\n    \r\n    # Return null or false if value is null or empty\r\n    if ([string]::IsNullOrWhiteSpace($value)) {\r\n        If ( $AsBoolean ) {\r\n            $Script:SettingCache[$SettingKey] = $false\r\n            return $false\r\n        }\r\n        Else {\r\n            $Script:SettingCache[$SettingKey] = $null\r\n            return $null\r\n        }\r\n    }\r\n    Else {\r\n        If ( $AsBoolean ) {\r\n            if ($value.ToLower() -eq 'true') {\r\n                $Script:SettingCache[$SettingKey] = $true\r\n                return $true\r\n            }\r\n            else {\r\n                $Script:SettingCache[$SettingKey] = $false\r\n                return $false\r\n            }\r\n        }\r\n        if ($value -match '^\\d+$') {\r\n            [int]$intValue = [int]$value\r\n            $Script:SettingCache[$SettingKey] = $intValue\r\n            return $intValue\r\n        }\r\n        if ($value.StartsWith('{') -or $value.StartsWith('[')) {\r\n            Try {\r\n                If ($value.StartsWith('{')) {\r\n                    $parsed = $value | ConvertFrom-Json -AsHashtable -ErrorAction Stop\r\n                    $Script:SettingCache[$SettingKey] = $parsed\r\n                    return $parsed\r\n                }\r\n                Else {\r\n                    $parsed = $value | ConvertFrom-Json -ErrorAction Stop\r\n                    $Script:SettingCache[$SettingKey] = $parsed\r\n                    return $parsed\r\n                }\r\n            }\r\n            catch {\r\n                Write-Warning \"Failed to parse JSON for $SettingKey : $_\"\r\n                $Script:SettingCache[$SettingKey] = $value\r\n                return $value\r\n            }\r\n        }\r\n        else {\r\n            $Script:SettingCache[$SettingKey] = $value\r\n            return $value\r\n        }\r\n    }        \r\n}\r\n\r\n#EndRegion Configuration Functions\r\n\r\n#Region Logging and Error Handling\r\n\r\nfunction Write-LogEntry {\r\n    <#\r\n    .SYNOPSIS\r\n        Enhanced logging function with level support.\r\n    .DESCRIPTION\r\n        Writes detailed log messages function app levels.\r\n    .PARAMETER Message\r\n        The message to log.\r\n    .PARAMETER Level\r\n        The function app monitoring level (Trace, Debug, Information, Warning, Error, Critical).\r\n    .PARAMETER StringValues\r\n        Array of values to format into the message using -f operator.\r\n    .EXAMPLE\r\n        Write-LogEntry -Message \"Processing {0} items\" -StringValues 10 -Level Host\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n\r\n        [Parameter(Mandatory = $true, Position = 0)]\r\n        [string] $Message,\r\n        \r\n        [Parameter(Mandatory = $false)]\r\n        [ValidateSet('Trace', 'Debug', 'Information', 'Warning', 'Error', 'Critical')]\r\n        [string] $Level = 'Information',\r\n        \r\n        [Parameter(Mandatory = $false)]\r\n        [object[]] $StringValues\r\n    )\r\n    \r\n    # Format message with string values if provided\r\n    if ($StringValues -and $StringValues.Count -gt 0) {\r\n        try {\r\n            $formattedMessage = $Message -f $StringValues\r\n        }\r\n        catch {\r\n            $formattedMessage = $Message\r\n            Write-Warning \"Failed to format message with provided string values\"\r\n        }\r\n    }\r\n    else {\r\n        $formattedMessage = $Message\r\n    }\r\n    \r\n    # Build output message (Azure Functions already adds timestamp and level)\r\n    $output = if ($hostPoolName) { \"[$hostPoolName] $formattedMessage\".Trim() } else { $formattedMessage.Trim() }\r\n    \r\n    # Output based on level\r\n    switch ($Level) {\r\n        'Trace' {\r\n            Write-Verbose $output\r\n        }\r\n        'Debug' {\r\n            Write-Debug $output\r\n        }\r\n        'Error' {\r\n            Write-Error $output\r\n        }\r\n        'Warning' {\r\n            Write-Warning $output\r\n        }\r\n        'Information' {\r\n            # Use Write-Host for Information level to ensure proper display in Azure Functions\r\n            Write-Host $output\r\n        }\r\n    }\r\n}\r\n\r\n#EndRegion Logging and Error Handling\r\n\r\n#Region REST API Helper Functions\r\n\r\nfunction Invoke-AzureRestMethod {\r\n    <#\r\n        .SYNOPSIS\r\n            Run an Azure REST call with paging support.           \r\n        .PARAMETER ARMToken\r\n            An access token for Azure Resource Manager.\r\n        .PARAMETER Method\r\n            The HTTP method for the REST call, like GET, POST, PUT, PATCH, DELETE. Default is GET.\r\n        .PARAMETER Uri\r\n            The Azure Resource Manager URI for the query.\r\n        .PARAMETER Body\r\n            The request body of the REST call. This is often used with methods like POST, PUT and PATCH.\r\n        .PARAMETER AdditionalHeaders\r\n            Optional additional headers to include in the request.\r\n        .EXAMPLE\r\n            Invoke-AzureRestMethod -ARMToken $ARMToken -Method 'GET' -Uri 'https://management.azure.com/...'\r\n    #>\r\n\r\n    param (\r\n        [parameter(Mandatory = $true)]\r\n        [string]$ARMToken,\r\n\r\n        [parameter(Mandatory = $false)]\r\n        [string]$Method = 'GET',\r\n\r\n        [parameter(Mandatory = $true)]\r\n        [string]$Uri,\r\n\r\n        [parameter(Mandatory = $false)]\r\n        [string]$Body = '',\r\n\r\n        [parameter(Mandatory = $false)]\r\n        [hashtable]$AdditionalHeaders\r\n    )\r\n\r\n    # Check if authentication was successful.\r\n    if ($ARMToken) {\r\n        # Format headers.\r\n        $HeaderParams = @{\r\n            'Content-Type'  = \"application/json\"\r\n            'Authorization' = \"Bearer $ARMToken\"\r\n        }\r\n        If ($AdditionalHeaders) {\r\n            $HeaderParams += $AdditionalHeaders\r\n        }\r\n\r\n        # Create an empty array to store the result.\r\n        $QueryRequest = @()\r\n        $dataToUpload = @()\r\n\r\n        # Run the first query.\r\n        if ($Method -eq 'GET') {\r\n            $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -Method $Method -Verbose:$false\r\n        }\r\n        else {\r\n            $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -Method $Method -Body $Body -Verbose:$false\r\n        }\r\n        \r\n        # Check if response is a direct array or has a value property\r\n        if ($QueryRequest -is [array]) {\r\n            # Direct array response (e.g., marketplace images API)\r\n            $dataToUpload += $QueryRequest\r\n        }\r\n        elseif ($QueryRequest.value) {\r\n            # Paged response with value property\r\n            $dataToUpload += $QueryRequest.value\r\n        }\r\n        else {\r\n            # Single object response\r\n            $dataToUpload += $QueryRequest\r\n        }\r\n\r\n        # Invoke REST methods and fetch data until there are no pages left.\r\n        if ($Uri -notlike \"*`$top*\") {\r\n            while ($QueryRequest.'@odata.nextLink' -and $QueryRequest.'@odata.nextLink' -is [string]) {\r\n                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $QueryRequest.'@odata.nextLink' -Method $Method -Verbose:$false\r\n                $dataToUpload += $QueryRequest.value\r\n            }\r\n            While ($QueryRequest.nextLink -and $QueryRequest.nextLink -is [string]) {\r\n                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $QueryRequest.nextLink -Method $Method -Verbose:$false\r\n                $dataToUpload += $QueryRequest.value\r\n            }\r\n            While ($QueryRequest.'$skipToken' -and $QueryRequest.'$skipToken' -is [string] -and $Body -ne '') {\r\n                $JsonBody = $Body | ConvertFrom-Json\r\n                $JsonBody | Add-Member -Type NoteProperty -Name '$skipToken' -Value $QueryRequest.'$skipToken' -Force\r\n                $Body = $JsonBody | ConvertTo-Json -Depth 10\r\n                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -Method $Method -Body $Body -Verbose:$false\r\n                $dataToUpload += $QueryRequest.value\r\n            }\r\n        }\r\n        $dataToUpload\r\n    }\r\n    else {\r\n        Write-Error \"No Access Token\"\r\n    }\r\n}\r\n\r\nfunction Invoke-AzureRestMethodWithRetry {\r\n    <#\r\n    .SYNOPSIS\r\n        Invokes Azure REST API with automatic retry logic for transient failures.\r\n    .DESCRIPTION\r\n        Wraps Invoke-AzureRestMethod with exponential backoff retry for 429 and 5xx errors.\r\n    .PARAMETER ARMToken\r\n        Azure access token for authentication.\r\n    .PARAMETER Method\r\n        HTTP method (GET, POST, PUT, PATCH, DELETE).\r\n    .PARAMETER Uri\r\n        The REST API endpoint URI.\r\n    .PARAMETER Body\r\n        Optional request body.\r\n    .PARAMETER MaxRetries\r\n        Maximum number of retry attempts (default: 3).\r\n    .PARAMETER RetryDelaySeconds\r\n        Initial retry delay in seconds (default: 5).\r\n    .EXAMPLE\r\n        Invoke-AzureRestMethodWithRetry -ARMToken $token -Method Get -Uri $uri -MaxRetries 5\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [ValidateSet('Get', 'Post', 'Put', 'Patch', 'Delete')]\r\n        [string] $Method,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [string] $Uri,\r\n        \r\n        [Parameter()]\r\n        [string] $Body,\r\n        \r\n        [Parameter()]\r\n        [int] $MaxRetries = 3,\r\n        \r\n        [Parameter()]\r\n        [int] $RetryDelaySeconds = 5\r\n    )\r\n    \r\n    $attempt = 0\r\n    $success = $false\r\n    $result = $null\r\n    \r\n    while (-not $success -and $attempt -lt $MaxRetries) {\r\n        $attempt++\r\n        try {\r\n            $result = Invoke-AzureRestMethod -ARMToken $ARMToken -Method $Method -Uri $Uri -Body $Body\r\n            $success = $true\r\n        }\r\n        catch {\r\n            $statusCode = $_.Exception.Response.StatusCode.value__\r\n            $retryable = $statusCode -in @(429, 500, 502, 503, 504)\r\n            \r\n            if ($retryable -and $attempt -lt $MaxRetries) {\r\n                $delay = $RetryDelaySeconds * [Math]::Pow(2, $attempt - 1)\r\n                Write-LogEntry -Message \"Request failed with status $statusCode. Retrying in $delay seconds (attempt $attempt of $MaxRetries)\" -Level Warning\r\n                Start-Sleep -Seconds $delay\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"Request failed: $_\" -Level Error\r\n                throw $_\r\n            }\r\n        }\r\n    }\r\n    \r\n    return $result\r\n}\r\n\r\nfunction Invoke-GraphRestMethod {\r\n    <#\r\n    .SYNOPSIS\r\n        Invokes Microsoft Graph API with retry support for DoD endpoint.\r\n    .DESCRIPTION\r\n        Attempts to call the Graph API with the provided endpoint. If the call fails with\r\n        authentication/forbidden errors, automatically retries with the DoD Graph endpoint.\r\n    .PARAMETER GraphToken\r\n        Bearer token for authentication.\r\n    .PARAMETER Method\r\n        HTTP method (GET, POST, PATCH, DELETE, PUT).\r\n    .PARAMETER Uri\r\n        The full Graph API URI (e.g., https://graph.microsoft.us/v1.0/devices).\r\n    .PARAMETER Body\r\n        Optional request body for POST/PATCH operations.\r\n    .EXAMPLE\r\n        Invoke-GraphRestMethod -GraphToken $token -Method Get -Uri \"https://graph.microsoft.us/v1.0/devices\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $GraphToken,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [ValidateSet('Get', 'Post', 'Patch', 'Delete', 'Put')]\r\n        [string] $Method,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [string] $Uri,\r\n        \r\n        [Parameter()]\r\n        [string] $Body\r\n    )\r\n    \r\n    $headers = @{\r\n        'Authorization' = \"Bearer $GraphToken\"\r\n        'Content-Type'  = 'application/json'\r\n    }\r\n    \r\n    $params = @{\r\n        Uri     = $Uri\r\n        Method  = $Method\r\n        Headers = $headers\r\n    }\r\n    \r\n    if ($Body) {\r\n        $params['Body'] = $Body\r\n    }\r\n    \r\n    try {\r\n        $result = Invoke-RestMethod @params -ErrorAction Stop\r\n        return $result\r\n    }\r\n    catch {\r\n        $statusCode = $_.Exception.Response.StatusCode.value__\r\n        \r\n        # If using GCCH endpoint and got auth error, try DoD endpoint\r\n        if ($Uri -like \"*graph.microsoft.us*\" -and $statusCode -in @(401, 403)) {\r\n            Write-LogEntry -Message \"Graph API call to GCCH failed with status $statusCode. Trying DoD endpoint...\" -Level Warning\r\n            \r\n            # Replace GCCH endpoint with DoD\r\n            $dodUri = $Uri -replace 'graph\\.microsoft\\.us', 'dod-graph.microsoft.us'\r\n            \r\n            try {\r\n                # Acquire new token for DoD endpoint\r\n                $dodToken = Get-AccessToken -ResourceUri 'https://dod-graph.microsoft.us'\r\n                $headers['Authorization'] = \"Bearer $dodToken\"\r\n                $params['Uri'] = $dodUri\r\n                $params['Headers'] = $headers\r\n                \r\n                $result = Invoke-RestMethod @params -ErrorAction Stop\r\n                return $result\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Graph API call to DoD endpoint also failed: $_\" -Level Error\r\n                throw $_\r\n            }\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Graph API call failed: $_\" -Level Error\r\n            throw $_\r\n        }\r\n    }\r\n}\r\n\r\nfunction Invoke-GraphApiWithRetry {\r\n    <#\r\n    .SYNOPSIS\r\n        Invokes Microsoft Graph API with automatic retry for DoD endpoint if GCCH fails.\r\n    .DESCRIPTION\r\n        Attempts to call the Graph API with the provided endpoint. If the call fails with\r\n        authentication/forbidden errors, automatically retries with the DoD Graph endpoint\r\n        and acquires a fresh token for that endpoint.\r\n    .PARAMETER GraphEndpoint\r\n        The initial Graph endpoint to try (e.g., https://graph.microsoft.us).\r\n    .PARAMETER GraphToken\r\n        Bearer token for authentication (for the GraphEndpoint).\r\n    .PARAMETER Method\r\n        HTTP method (GET, POST, PATCH, DELETE, PUT).\r\n    .PARAMETER Uri\r\n        The relative URI path (e.g., /v1.0/devices). Will be appended to GraphEndpoint.\r\n    .PARAMETER Body\r\n        Optional request body for POST/PATCH operations.\r\n    .PARAMETER Headers\r\n        Optional custom headers. Authorization header will be added automatically.\r\n    .PARAMETER ClientId\r\n        Optional client ID for user-assigned managed identity (needed to acquire new token for DoD endpoint).\r\n    .EXAMPLE\r\n        Invoke-GraphApiWithRetry -GraphEndpoint $env:GraphEndpoint -GraphToken $token -Method Get -Uri \"/v1.0/devices?`$filter=displayName eq 'VM01'\" -ClientId $clientId\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $GraphEndpoint,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [string] $GraphToken,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [ValidateSet('Get', 'Post', 'Patch', 'Delete', 'Put')]\r\n        [string] $Method,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [string] $Uri,\r\n        \r\n        [Parameter()]\r\n        [string] $Body,\r\n        \r\n        [Parameter()]\r\n        [hashtable] $Headers = @{},\r\n        \r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    # Ensure GraphEndpoint doesn't have trailing slash\r\n    $graphBase = if ($GraphEndpoint[-1] -eq '/') { \r\n        $GraphEndpoint.Substring(0, $GraphEndpoint.Length - 1) \r\n    }\r\n    else { \r\n        $GraphEndpoint \r\n    }\r\n    \r\n    # Ensure Uri has leading slash\r\n    $uriPath = if ($Uri[0] -ne '/') { \"/$Uri\" } else { $Uri }  \r\n    \r\n    # List of endpoints to try\r\n    $endpointsToTry = @(\r\n        @{ Endpoint = $graphBase; Token = $GraphToken }\r\n    )\r\n    \r\n    # If we're using GCCH endpoint, also try DoD with a fresh token\r\n    if ($graphBase -eq 'https://graph.microsoft.us') {\r\n        $endpointsToTry += @{ \r\n            Endpoint = 'https://dod-graph.microsoft.us'\r\n            Token    = $null  # Will acquire fresh token if needed\r\n        }\r\n    }\r\n    \r\n    $lastError = $null\r\n    foreach ($endpointConfig in $endpointsToTry) {\r\n        $endpoint = $endpointConfig.Endpoint\r\n        $token = $endpointConfig.Token\r\n        \r\n        # If no token provided for this endpoint, acquire one\r\n        if (-not $token) {\r\n            try {\r\n                $token = Get-AccessToken -ResourceUri $endpoint -ClientId $ClientId\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Failed to acquire token for $endpoint : $_\" -Level Warning\r\n                continue\r\n            }\r\n        }\r\n        \r\n        try {\r\n            $currentUri = \"$endpoint$uriPath\"\r\n            \r\n            # Setup headers with correct token for this endpoint\r\n            $requestHeaders = $Headers.Clone()\r\n            $requestHeaders['Authorization'] = \"Bearer $token\"\r\n            if (-not $requestHeaders.ContainsKey('Content-Type')) {\r\n                $requestHeaders['Content-Type'] = 'application/json'\r\n            }\r\n            \r\n            $params = @{\r\n                Uri     = $currentUri\r\n                Method  = $Method\r\n                Headers = $requestHeaders\r\n            }\r\n            \r\n            if ($Body) {\r\n                $params['Body'] = $Body\r\n            }\r\n            \r\n            $result = Invoke-RestMethod @params -ErrorAction Stop\r\n            return $result\r\n        }\r\n        catch {\r\n            $lastError = $_\r\n            \r\n            if ($_.Exception.Response) {\r\n                $statusCode = $_.Exception.Response.StatusCode.value__\r\n                \r\n                # Try to get detailed error message from response body\r\n                try {\r\n                    $errorStream = $_.Exception.Response.GetResponseStream()\r\n                    $reader = New-Object System.IO.StreamReader($errorStream)\r\n                    $errorBody = $reader.ReadToEnd()\r\n                    $reader.Close()\r\n                    \r\n                    if ($errorBody) {\r\n                        Write-LogEntry -Message \"Graph API error response: $errorBody\" -Level Error\r\n                    }\r\n                }\r\n                catch {\r\n                    # Ignore errors reading error stream\r\n                }\r\n            }\r\n            \r\n            # Retry on authentication/authorization errors (401, 403) or if endpoint not found (404 on base endpoint)\r\n            if ($statusCode -in @(401, 403, 404) -and $endpoint -ne $endpointsToTry[-1].Endpoint) {\r\n                Write-LogEntry -Message \"Graph API call to $endpoint failed with status $statusCode. Trying next endpoint...\" -Level Warning\r\n                continue\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"Graph API call failed: $($_.Exception.Message)\" -Level Error\r\n                throw $_\r\n            }\r\n        }\r\n    }\r\n    \r\n    # If we get here, all endpoints failed\r\n    Write-LogEntry -Message \"All Graph API endpoints failed. Last error: $($lastError.Exception.Message)\" -Level Error\r\n    throw $lastError\r\n}\r\n\r\n#EndRegion REST API Helper Functions\r\n\r\n#Region VM Helper Functions\r\n\r\nfunction Get-VMPowerStates {\r\n    <#\r\n    .SYNOPSIS\r\n        Queries power state for specific VMs by resource ID.\r\n    .DESCRIPTION\r\n        Retrieves instanceView with power state for a list of VM resource IDs.\r\n        Used for lazy loading to avoid querying all VMs when only deletion candidates need power state.\r\n    .PARAMETER ARMToken\r\n        Azure Resource Manager access token.\r\n    .PARAMETER VMResourceIds\r\n        Array of VM resource IDs to query.\r\n    .PARAMETER ResourceManagerUri\r\n        The Azure Resource Manager endpoint URI.\r\n    .EXAMPLE\r\n        $powerStates = Get-VMPowerStates -ARMToken $token -VMResourceIds @('/subscriptions/.../vm1', '/subscriptions/.../vm2')\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [array] $VMResourceIds,\r\n        \r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri)\r\n    )\r\n    \r\n    if ($VMResourceIds.Count -eq 0) {\r\n        return @{}\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Querying power state for $($VMResourceIds.Count) VMs\" -Level Trace\r\n    \r\n    $powerStates = @{}\r\n    \r\n    foreach ($resourceId in $VMResourceIds) {\r\n        try {\r\n            $Uri = \"$ResourceManagerUri$resourceId/instanceView?api-version=2024-07-01\"\r\n            $instanceView = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n            \r\n            # Extract power state from statuses\r\n            $powerStateCode = ($instanceView.statuses | Where-Object { $_.code -like 'PowerState/*' }).code\r\n            $isPoweredOff = $powerStateCode -like 'PowerState/deallocated' -or $powerStateCode -like 'PowerState/stopped'\r\n            \r\n            $powerStates[$resourceId] = $isPoweredOff\r\n            Write-LogEntry -Message \"VM $resourceId power state: $powerStateCode (PoweredOff=$isPoweredOff)\" -Level Trace\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to get power state for VM $resourceId : $_\" -Level Warning\r\n            $powerStates[$resourceId] = $false  # Assume powered on if query fails\r\n        }\r\n    }\r\n    \r\n    return $powerStates\r\n}\r\n\r\n#EndRegion VM Helper Functions\r\n\r\n# Export functions\r\nExport-ModuleMember -Function ConvertTo-CaseInsensitiveHashtable, Get-ResourceManagerUri, Get-GraphEndpoint, Get-AccessToken, Read-FunctionAppSetting, Write-LogEntry, Invoke-AzureRestMethod, Invoke-AzureRestMethodWithRetry, Invoke-GraphRestMethod, Invoke-GraphApiWithRetry, Get-VMPowerStates\r\n",
    "$fxv#6": "# SessionHostReplacer Deployment Module\r\n# Contains deployment and progressive scale-up functions\r\n\r\n# Import Core utilities\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Core.psm1\" -Force\r\n\r\n#Region Progressive Scale-Up State Management\r\n\r\nfunction Get-DeploymentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Retrieves the deployment state from Azure Table Storage for progressive scale-up tracking.\r\n    .DESCRIPTION\r\n        Reads deployment history from the function app's storage account table to track\r\n        consecutive successful deployments and current scale-up percentage.\r\n    .PARAMETER HostPoolName\r\n        Name of the host pool to retrieve state for.\r\n    .EXAMPLE\r\n        $state = Get-DeploymentState -HostPoolName 'hp-prod-001'\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n\r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    try {\r\n        # Parse storage account name from AzureWebJobsStorage if not provided\r\n\r\n        $storageUri = $env:AzureWebJobsStorage__blobServiceUri\r\n        if ($storageUri -match 'https://([^.]+)\\.') {\r\n            $StorageAccountName = $Matches[1]\r\n        }\r\n        else {\r\n            throw \"Unable to determine storage account name from environment variables\"\r\n        }\r\n        \r\n        $tableName = 'sessionHostDeploymentState'\r\n        $partitionKey = $HostPoolName\r\n        $rowKey = 'DeploymentState'\r\n        $storageSuffix = $env:StorageSuffix\r\n        $tableEndpoint = \"https://$StorageAccountName.table.$storageSuffix\"\r\n        \r\n        # Get storage access token using user-assigned managed identity\r\n        # Storage tokens should NOT have trailing slash (fixed from original code which had trailing slash)\r\n        $storageToken = Get-AccessToken -ResourceUri \"https://$StorageAccountName.table.$storageSuffix\" -ClientId $ClientId\r\n        \r\n        $headers = @{\r\n            'Authorization' = \"Bearer $storageToken\"\r\n            'Accept'        = 'application/json;odata=nometadata'\r\n            'x-ms-version'  = '2019-02-02'\r\n            'x-ms-date'     = [DateTime]::UtcNow.ToString('R')\r\n        }\r\n        \r\n        # Check if table exists, create if not\r\n        $tablesUri = \"$tableEndpoint/Tables\"\r\n        try {\r\n            $existingTables = Invoke-RestMethod -Uri $tablesUri -Headers $headers -Method Get -ContentType 'application/json' -ErrorAction SilentlyContinue\r\n            $tableExists = $existingTables.value | Where-Object { $_.TableName -eq $tableName }\r\n            \r\n            if (-not $tableExists) {\r\n                Write-LogEntry -Message \"Creating deployment state table '$tableName'\" -Level Trace\r\n                $createTableBody = @{ TableName = $tableName } | ConvertTo-Json\r\n                $headers['Content-Type'] = 'application/json'\r\n                Invoke-RestMethod -Uri $tablesUri -Headers $headers -Method Post -Body $createTableBody -ErrorAction Stop | Out-Null\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Error checking/creating table: $_\" -Level Warning\r\n        }\r\n        \r\n        # Query entity\r\n        $entityUri = \"$tableEndpoint/$tableName(PartitionKey='$partitionKey',RowKey='$rowKey')\"\r\n        \r\n        try {\r\n            $entity = Invoke-RestMethod -Uri $entityUri -Headers $headers -Method Get -ContentType 'application/json' -ErrorAction Stop\r\n            \r\n            Write-LogEntry -Message \"Retrieved deployment state: ConsecutiveSuccesses=$($entity.ConsecutiveSuccesses), CurrentPercentage=$($entity.CurrentPercentage)%\" -Level Trace\r\n            return [PSCustomObject]@{\r\n                LastDeploymentName       = $entity.LastDeploymentName\r\n                LastDeploymentCount      = [int]$entity.LastDeploymentCount\r\n                LastDeploymentNeeded     = [int]$entity.LastDeploymentNeeded\r\n                LastDeploymentPercentage = [int]$entity.LastDeploymentPercentage\r\n                LastStatus               = $entity.LastStatus\r\n                LastTimestamp            = $entity.LastTimestamp\r\n                ConsecutiveSuccesses     = [int]$entity.ConsecutiveSuccesses\r\n                CurrentPercentage        = [int]$entity.CurrentPercentage\r\n                TargetSessionHostCount   = [int]$entity.TargetSessionHostCount\r\n                LastImageVersion         = $entity.LastImageVersion\r\n                LastTotalToReplace       = [int]$entity.LastTotalToReplace\r\n                PendingHostMappings      = if ($entity.PendingHostMappings) { $entity.PendingHostMappings } else { '{}' }\r\n            }\r\n        }\r\n        catch {\r\n            if ($_.Exception.Response.StatusCode -eq 404) {\r\n                Write-LogEntry -Message \"No deployment state found, initializing new state\" -Level Trace\r\n                return [PSCustomObject]@{\r\n                    LastDeploymentName       = ''\r\n                    LastDeploymentCount      = 0\r\n                    LastDeploymentNeeded     = 0\r\n                    LastDeploymentPercentage = 0\r\n                    LastStatus               = 'None'\r\n                    LastTimestamp            = (Get-Date -AsUTC -Format 'o')\r\n                    ConsecutiveSuccesses     = 0\r\n                    CurrentPercentage        = (Read-FunctionAppSetting InitialDeploymentPercentage)\r\n                    TargetSessionHostCount   = 0\r\n                    LastImageVersion         = ''\r\n                    LastTotalToReplace       = 0\r\n                    PendingHostMappings      = '{}'\r\n                }\r\n            }\r\n            else {\r\n                throw $_\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Failed to retrieve deployment state: $_\" -Level Error\r\n        # Return default state on error\r\n        return [PSCustomObject]@{\r\n            LastDeploymentName       = ''\r\n            LastDeploymentCount      = 0\r\n            LastDeploymentNeeded     = 0\r\n            LastDeploymentPercentage = 0\r\n            LastStatus               = 'Error'\r\n            LastTimestamp            = (Get-Date -AsUTC -Format 'o')\r\n            ConsecutiveSuccesses     = 0\r\n            CurrentPercentage        = (Read-FunctionAppSetting InitialDeploymentPercentage)\r\n            TargetSessionHostCount   = 0\r\n            LastImageVersion         = ''\r\n            LastTotalToReplace       = 0\r\n            PendingHostMappings      = '{}'\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-LastDeploymentStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Checks the status of the last deployment from the previous function run.\r\n    .DESCRIPTION\r\n        Queries Azure Resource Manager to determine if the deployment from the previous\r\n        run succeeded or failed. This allows the function to track deployment outcomes\r\n        without polling synchronously, avoiding function timeout issues.\r\n    .PARAMETER DeploymentName\r\n        Name of the deployment to check.\r\n    .PARAMETER ARMToken\r\n        Azure Resource Manager access token.\r\n    .PARAMETER ResourceManagerUri\r\n        Resource Manager URI.\r\n    .PARAMETER SubscriptionId\r\n        Subscription ID containing the deployment.\r\n    .PARAMETER ResourceGroupName\r\n        Resource group name containing the deployment.\r\n    .EXAMPLE\r\n        $status = Get-LastDeploymentStatus -DeploymentName 'shr-abc123-20231230-120000' -ARMToken $token\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $DeploymentName,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n\r\n        [Parameter()]\r\n        [string] $SubscriptionId = (Read-FunctionAppSetting VirtualMachinesSubscriptionId),\r\n\r\n        [Parameter()]\r\n        [string] $ResourceGroupName = (Read-FunctionAppSetting VirtualMachinesResourceGroupName)\r\n    )\r\n\r\n    if ([string]::IsNullOrEmpty($DeploymentName)) {\r\n        Write-LogEntry -Message \"No previous deployment name provided\"\r\n        return $null\r\n    }\r\n\r\n    try {\r\n        $Uri = \"$ResourceManagerUri/subscriptions/$SubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.Resources/deployments/$DeploymentName`?api-version=2021-04-01\"\r\n        Write-LogEntry -Message \"Checking status of previous deployment: $DeploymentName\" -Level Trace\r\n        \r\n        $deployment = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n        \r\n        if ($deployment) {\r\n            $provisioningState = $deployment.properties.provisioningState\r\n            Write-LogEntry -Message \"Previous deployment status: $provisioningState\" -Level Trace\r\n            \r\n            $result = [PSCustomObject]@{\r\n                DeploymentName    = $DeploymentName\r\n                ProvisioningState = $provisioningState\r\n                Succeeded         = $provisioningState -eq 'Succeeded'\r\n                Failed            = $provisioningState -eq 'Failed'\r\n                Running           = $provisioningState -in @('Running', 'Accepted')\r\n                ErrorMessage      = $deployment.properties.error.message\r\n                Timestamp         = $deployment.properties.timestamp\r\n            }\r\n            \r\n            if ($result.Failed) {\r\n                Write-LogEntry -Message \"Previous deployment failed with error: $($result.ErrorMessage)\" -Level Error\r\n            }\r\n            elseif ($result.Running) {\r\n                Write-LogEntry -Message \"Previous deployment is still running\" -Level Warning\r\n            }\r\n            \r\n            return $result\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Previous deployment not found: $DeploymentName\" -Level Warning\r\n            return $null\r\n        }\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Failed to check previous deployment status: $_\" -Level Warning\r\n        return $null\r\n    }\r\n}\r\n\r\n\r\nfunction Save-DeploymentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Saves the deployment state to Azure Table Storage for progressive scale-up tracking.\r\n    .DESCRIPTION\r\n        Writes deployment history to the function app's storage account table to track\r\n        consecutive successful deployments and update scale-up percentage.\r\n    .PARAMETER DeploymentState\r\n        The deployment state object to save.\r\n    .PARAMETER HostPoolName\r\n        Name of the host pool.\r\n    .EXAMPLE\r\n        Save-DeploymentState -DeploymentState $state -HostPoolName 'hp-prod-001'\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [PSCustomObject] $DeploymentState,\r\n        \r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n        \r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    try {\r\n        # Parse storage account name from AzureWebJobsStorage if not provided\r\n        $storageUri = $env:AzureWebJobsStorage__blobServiceUri\r\n        if ($storageUri -match 'https://([^.]+)\\.') {\r\n            $StorageAccountName = $Matches[1]\r\n        }\r\n        else {\r\n            throw \"Unable to determine storage account name from environment variables\"\r\n        }\r\n                \r\n        $tableName = 'sessionHostDeploymentState'\r\n        $partitionKey = $HostPoolName\r\n        $rowKey = 'DeploymentState'\r\n        $storageSuffix = $env:StorageSuffix\r\n        $tableEndpoint = \"https://$StorageAccountName.table.$storageSuffix\"\r\n        \r\n        # Get storage access token using user-assigned managed identity\r\n        # Storage tokens should NOT have trailing slash (fixed from original code which had trailing slash)\r\n        $storageToken = Get-AccessToken -ResourceUri \"https://$StorageAccountName.table.$storageSuffix\" -ClientId $ClientId\r\n        \r\n        $headers = @{\r\n            'Authorization' = \"Bearer $storageToken\"\r\n            'Accept'        = 'application/json;odata=nometadata'\r\n            'x-ms-version'  = '2019-02-02'\r\n            'x-ms-date'     = [DateTime]::UtcNow.ToString('R')\r\n            'Content-Type'  = 'application/json'\r\n        }\r\n        \r\n        # Check if table exists, create if not\r\n        $tablesUri = \"$tableEndpoint/Tables\"\r\n        try {\r\n            $existingTables = Invoke-RestMethod -Uri $tablesUri -Headers $headers -Method Get -ContentType 'application/json' -ErrorAction SilentlyContinue\r\n            $tableExists = $existingTables.value | Where-Object { $_.TableName -eq $tableName }\r\n            \r\n            if (-not $tableExists) {\r\n                Write-LogEntry -Message \"Creating deployment state table '$tableName'\" -Level Trace\r\n                $createTableBody = @{ TableName = $tableName } | ConvertTo-Json\r\n                Invoke-RestMethod -Uri $tablesUri -Headers $headers -Method Post -Body $createTableBody -ErrorAction Stop | Out-Null\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Error checking/creating table: $_\" -Level Warning\r\n        }\r\n        \r\n        # Prepare entity data\r\n        $entityData = @{\r\n            PartitionKey             = $partitionKey\r\n            RowKey                   = $rowKey\r\n            LastDeploymentName       = $DeploymentState.LastDeploymentName\r\n            LastDeploymentCount      = $DeploymentState.LastDeploymentCount\r\n            LastDeploymentNeeded     = $DeploymentState.LastDeploymentNeeded\r\n            LastDeploymentPercentage = $DeploymentState.LastDeploymentPercentage\r\n            LastStatus               = $DeploymentState.LastStatus\r\n            LastTimestamp            = $DeploymentState.LastTimestamp\r\n            ConsecutiveSuccesses     = $DeploymentState.ConsecutiveSuccesses\r\n            CurrentPercentage        = $DeploymentState.CurrentPercentage\r\n            TargetSessionHostCount   = $DeploymentState.TargetSessionHostCount\r\n            LastImageVersion         = if ($DeploymentState.LastImageVersion) { $DeploymentState.LastImageVersion } else { '' }\r\n            LastTotalToReplace       = $DeploymentState.LastTotalToReplace\r\n            PendingHostMappings      = if ($DeploymentState.PendingHostMappings) { $DeploymentState.PendingHostMappings } else { '{}' }\r\n        }\r\n        \r\n        # Check if entity exists\r\n        $entityUri = \"$tableEndpoint/$tableName(PartitionKey='$partitionKey',RowKey='$rowKey')\"\r\n        $entityExists = $false\r\n        \r\n        try {\r\n            Invoke-RestMethod -Uri $entityUri -Headers $headers -Method Get -ErrorAction Stop | Out-Null\r\n            $entityExists = $true\r\n        }\r\n        catch {\r\n            if ($_.Exception.Response.StatusCode -ne 404) {\r\n                throw $_\r\n            }\r\n        }\r\n        \r\n        if ($entityExists) {\r\n            # Update existing entity using MERGE\r\n            $updateHeaders = $headers.Clone()\r\n            $updateHeaders['If-Match'] = '*'\r\n            $body = $entityData | ConvertTo-Json\r\n            Invoke-RestMethod -Uri $entityUri -Headers $updateHeaders -Method Merge -Body $body -ErrorAction Stop | Out-Null\r\n        }\r\n        else {\r\n            # Insert new entity\r\n            $insertUri = \"$tableEndpoint/$tableName\"\r\n            $body = $entityData | ConvertTo-Json\r\n            Invoke-RestMethod -Uri $insertUri -Headers $headers -Method Post -Body $body -ErrorAction Stop | Out-Null\r\n        }\r\n        \r\n        Write-LogEntry -Message \"Saved deployment state: Status=$($DeploymentState.LastStatus), ConsecutiveSuccesses=$($DeploymentState.ConsecutiveSuccesses), NextPercentage=$($DeploymentState.CurrentPercentage)%\" -Level Trace\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Failed to save deployment state: $_\" -Level Error\r\n    }\r\n}\r\n\r\n#EndRegion Progressive Scale-Up State Management\r\n\r\n#Region Deployment Operations\r\n\r\nfunction Deploy-SessionHosts {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n\r\n        [Parameter()]\r\n        [string[]] $ExistingSessionHostNames = @(),\r\n\r\n        [Parameter()]\r\n        [string[]] $PreferredSessionHostNames = @(),\r\n\r\n        [Parameter()]\r\n        [hashtable] $PreferredHostProperties = @{},\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [int] $NewSessionHostsCount,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string] $HostPoolResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n\r\n        [Parameter()]\r\n        [string] $VirtualMachinesSubscriptionId = (Read-FunctionAppSetting VirtualMachinesSubscriptionId),\r\n\r\n        [Parameter()]\r\n        [string] $VirtualMachinesResourceGroupName = (Read-FunctionAppSetting VirtualMachinesResourceGroupName),\r\n\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n\r\n        [Parameter()]\r\n        [string] $SessionHostNamePrefix = (Read-FunctionAppSetting SessionHostNamePrefix),\r\n\r\n        [Parameter()]\r\n        [int] $SessionHostNameIndexLength = (Read-FunctionAppSetting SessionHostNameIndexLength),\r\n\r\n        [Parameter()]\r\n        [int] $MinimumHostIndex = (Read-FunctionAppSetting MinimumHostIndex),\r\n\r\n        [Parameter()]\r\n        [string] $DeploymentPrefix = (Read-FunctionAppSetting DeploymentPrefix),\r\n\r\n        [Parameter()]\r\n        [hashtable] $SessionHostParameters = (Read-FunctionAppSetting SessionHostParameters | ConvertTo-CaseInsensitiveHashtable),\r\n\r\n        [Parameter()]\r\n        [string] $SessionHostTemplate = (Read-FunctionAppSetting SessionHostTemplate),\r\n\r\n        [Parameter()]\r\n        [string] $TagIncludeInAutomation = (Read-FunctionAppSetting Tag_IncludeInAutomation),\r\n\r\n        [Parameter()]\r\n        [string] $TagDeployTimestamp = (Read-FunctionAppSetting Tag_DeployTimestamp),\r\n\r\n        [Parameter()]\r\n        [string] $TagScalingPlanExclusionTag = (Read-FunctionAppSetting Tag_ScalingPlanExclusionTag)\r\n    )\r\n\r\n    # Check if we have a valid token with sufficient time remaining\r\n    Write-LogEntry -Message \"Checking existing registration token for host pool $HostPoolName\" -Level Trace\r\n    \r\n    try {\r\n        $existingTokens = Invoke-AzureRestMethod `\r\n            -ARMToken $ARMToken `\r\n            -Method Post `\r\n            -Uri (\"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$HostPoolResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$($HostPoolName)/listRegistrationTokens?api-version=2024-04-03\")\r\n        \r\n        if ($existingTokens -and $existingTokens.expirationTime) {\r\n            # Parse expiration time - Azure returns UTC datetime strings\r\n            # Use RoundtripKind to properly parse timezone info (e.g., \"2026-01-19T05:20:00.0000000Z\")\r\n            $tokenExpiration = [DateTime]::Parse($existingTokens.expirationTime, $null, [System.Globalization.DateTimeStyles]::RoundtripKind)\r\n            \r\n            # If timezone info wasn't in the string, assume UTC (Azure always returns UTC)\r\n            if ($tokenExpiration.Kind -eq [System.DateTimeKind]::Unspecified) {\r\n                $tokenExpiration = [DateTime]::SpecifyKind($tokenExpiration, [System.DateTimeKind]::Utc)\r\n            }\r\n            \r\n            # Get current time in UTC\r\n            $currentTimeUtc = [DateTime]::UtcNow\r\n            \r\n            # Calculate remaining time (both times now in UTC)\r\n            $hoursRemaining = ($tokenExpiration - $currentTimeUtc).TotalHours\r\n            \r\n            if ($hoursRemaining -ge 2) {\r\n                Write-LogEntry -Message \"Existing registration token is valid for {0:F1} more hours - reusing token\" -StringValues $hoursRemaining\r\n                $skipTokenGeneration = $true\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"Existing token expires in {0:F1} hours (less than 2 hours) - generating new token\" -StringValues $hoursRemaining -Level Trace\r\n                $skipTokenGeneration = $false\r\n            }\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"No valid token found - generating new token\" -Level Trace\r\n            $skipTokenGeneration = $false\r\n        }\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Could not retrieve existing token: $($_.Exception.Message) - generating new token\" -Level Trace\r\n        $skipTokenGeneration = $false\r\n    }\r\n    \r\n    # Generate new token if needed\r\n    if (-not $skipTokenGeneration) {\r\n        Write-LogEntry -Message \"Generating new registration token for host pool $HostPoolName in Resource Group $HostPoolResourceGroupName\"\r\n        $Body = @{\r\n            properties = @{\r\n                registrationInfo = @{\r\n                    expirationTime             = (Get-Date).AddHours(8)\r\n                    registrationTokenOperation = 'Update'\r\n                }\r\n            }\r\n        }\r\n        \r\n        try {\r\n            $tokenResponse = Invoke-AzureRestMethod `\r\n                -ARMToken $ARMToken `\r\n                -Body ($Body | ConvertTo-Json -depth 10) `\r\n                -Method Patch `\r\n                -Uri (\"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$HostPoolResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$($HostPoolName)?api-version=2024-04-03\")\r\n            \r\n            Write-LogEntry -Message \"Successfully generated new registration token (expires in 8 hours)\"\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to generate registration token: $($_.Exception.Message)\" -Level Error\r\n            throw \"Failed to generate registration token for host pool $HostPoolName. Error: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n    \r\n    # Calculate Session Host Names\r\n    Write-LogEntry -Message \"Existing session host VM names: {0}\" -StringValues ($ExistingSessionHostNames -join ',')\r\n    \r\n    if ($PreferredSessionHostNames -and $PreferredSessionHostNames.Count -gt 0) {\r\n        Write-LogEntry -Message \"Preferred session host names for reuse: {0}\" -StringValues ($PreferredSessionHostNames -join ',')\r\n    }\r\n    \r\n    [array] $sessionHostNames = @()\r\n    [array] $remainingPreferredNames = $PreferredSessionHostNames | Where-Object { $_ -notin $ExistingSessionHostNames }\r\n    \r\n    for ($i = 0; $i -lt $NewSessionHostsCount; $i++) {\r\n        if ($remainingPreferredNames.Count -gt 0) {\r\n            # Use preferred name first (from deleted hosts)\r\n            $shName = $remainingPreferredNames[0]\r\n            $remainingPreferredNames = $remainingPreferredNames | Select-Object -Skip 1\r\n        }\r\n        else {\r\n            # Fall back to gap-filling logic starting from MinimumHostIndex\r\n            $shNumber = $MinimumHostIndex\r\n            While ((\"$SessionHostNamePrefix{0:d$SessionHostNameIndexLength}\" -f $shNumber) -in $ExistingSessionHostNames) {\r\n                $shNumber++\r\n            }\r\n            $shName = \"$SessionHostNamePrefix{0:d$SessionHostNameIndexLength}\" -f $shNumber\r\n        }\r\n        \r\n        $ExistingSessionHostNames += $shName\r\n        $sessionHostNames += $shName\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Creating session host(s) $($sessionHostNames -join ', ')\"\r\n\r\n    # Update Session Host Parameters\r\n    $sessionHostParameters['sessionHostNames'] = $sessionHostNames\r\n    \r\n    # Apply per-VM dedicated host properties if provided\r\n    # Build arrays for dedicatedHostResourceId and dedicatedHostGroupResourceId indexed by VM\r\n    if ($PreferredHostProperties.Count -gt 0) {\r\n        Write-LogEntry -Message \"Applying per-VM dedicated host properties from mapping\"\r\n        \r\n        $dedicatedHostIds = @()\r\n        $dedicatedHostGroupIds = @()\r\n        $preferredZones = @()\r\n        \r\n        foreach ($vmName in $sessionHostNames) {\r\n            if ($PreferredHostProperties.ContainsKey($vmName)) {\r\n                $props = $PreferredHostProperties[$vmName]\r\n                $dedicatedHostIds += if ($props.HostId) { $props.HostId } else { '' }\r\n                $dedicatedHostGroupIds += if ($props.HostGroupId) { $props.HostGroupId } else { '' }\r\n                $preferredZones += if ($props.Zones) { , $props.Zones } else { , @() }\r\n                Write-LogEntry -Message \"Applying dedicated host properties to {0}: HostId={1}, HostGroupId={2}, Zones={3}\" -StringValues $vmName, $props.HostId, $props.HostGroupId, ($props.Zones -join ', ') -Level Trace\r\n            }\r\n            else {\r\n                # Use empty string/array for VMs without specific assignments (will use template default)\r\n                $dedicatedHostIds += ''\r\n                $dedicatedHostGroupIds += ''\r\n                $preferredZones += , @()\r\n            }\r\n        }\r\n        \r\n        # Only set these parameters if we have at least one non-empty value\r\n        $hasHostIds = $dedicatedHostIds | Where-Object { -not [string]::IsNullOrEmpty($_) }\r\n        $hasHostGroupIds = $dedicatedHostGroupIds | Where-Object { -not [string]::IsNullOrEmpty($_) }\r\n        $hasZones = $preferredZones | Where-Object { $_.Count -gt 0 }\r\n        \r\n        if ($hasHostIds) {\r\n            $sessionHostParameters['dedicatedHostResourceIds'] = $dedicatedHostIds\r\n            Write-LogEntry -Message \"Set per-VM dedicatedHostResourceIds: {0}\" -StringValues ($dedicatedHostIds -join ', ') -Level Trace\r\n        }\r\n        if ($hasHostGroupIds) {\r\n            $sessionHostParameters['dedicatedHostGroupResourceIds'] = $dedicatedHostGroupIds\r\n            Write-LogEntry -Message \"Set per-VM dedicatedHostGroupResourceIds: {0}\" -StringValues ($dedicatedHostGroupIds -join ', ') -Level Trace\r\n        }\r\n        if ($hasZones) {\r\n            $sessionHostParameters['preferredZones'] = $preferredZones\r\n            Write-LogEntry -Message \"Set per-VM preferredZones: {0}\" -StringValues (($preferredZones | ForEach-Object { \"[$($_ -join ',')]\" }) -join ', ') -Level Trace\r\n        }\r\n    }\r\n    \r\n    # Ensure Tags hashtable exists and has Microsoft.Compute/virtualMachines section\r\n    if (-not $sessionHostParameters.ContainsKey('Tags') -or $null -eq $sessionHostParameters['Tags']) {\r\n        $sessionHostParameters['Tags'] = @{}\r\n    }\r\n    if (-not $sessionHostParameters['Tags'].ContainsKey('Microsoft.Compute/virtualMachines') -or $null -eq $sessionHostParameters['Tags']['Microsoft.Compute/virtualMachines']) {\r\n        $sessionHostParameters['Tags']['Microsoft.Compute/virtualMachines'] = @{}\r\n    }\r\n    \r\n    # Add automation tags to VM resource type\r\n    $sessionHostParameters['Tags']['Microsoft.Compute/virtualMachines'][$TagIncludeInAutomation] = $true\r\n    $sessionHostParameters['Tags']['Microsoft.Compute/virtualMachines'][$TagDeployTimestamp] = (Get-Date -AsUTC -Format 'o')\r\n    \r\n    # Add scaling exclusion tag to protect newly deployed VMs from scaling plan shutdown during registration\r\n    if ($TagScalingPlanExclusionTag -and $TagScalingPlanExclusionTag -ne ' ') {\r\n        $sessionHostParameters['Tags']['Microsoft.Compute/virtualMachines'][$TagScalingPlanExclusionTag] = 'SessionHostReplacer'\r\n        Write-LogEntry -Message \"Setting scaling exclusion tag on newly deployed VMs to prevent scaling plan interference\" -Level Trace\r\n    }\r\n    \r\n    $deploymentTimestamp = Get-Date -AsUTC -Format 'yyyyMMddHHmmss'\r\n    $deploymentName = \"{0}_Count_{1}_VMs_{2}\" -f $DeploymentPrefix, $sessionHostNames.count, $deploymentTimestamp\r\n    \r\n    Write-LogEntry -Message \"Deployment name: $deploymentName\"\r\n    Write-LogEntry -Message \"Deploying using Template Spec: $sessionHostTemplate\"\r\n    $templateSpecVersionResourceId = Get-TemplateSpecVersionResourceId -ARMToken $ARMToken -ResourceId $SessionHostTemplate\r\n\r\n    Write-LogEntry -Message \"Deploying $NewSessionHostsCount session host(s) to resource group $VirtualMachinesResourceGroupName\" \r\n    \r\n    # ARM deployment parameters need each value wrapped in a 'value' property\r\n    $deploymentParameters = @{}\r\n    foreach ($key in $sessionHostParameters.Keys) {\r\n        $deploymentParameters[$key] = @{\r\n            value = $sessionHostParameters[$key]\r\n        }\r\n    }\r\n    \r\n    $Body = @{\r\n        properties = @{\r\n            mode         = 'Incremental'\r\n            parameters   = $deploymentParameters\r\n            templateLink = @{\r\n                id = $templateSpecVersionResourceId\r\n            }\r\n        }\r\n    }\r\n    $Uri = \"$ResourceManagerUri/subscriptions/$VirtualMachinesSubscriptionId/resourceGroups/$VirtualMachinesResourceGroupName/providers/Microsoft.Resources/deployments/$($deploymentName)?api-version=2021-04-01\"\r\n    $DeploymentJob = Invoke-AzureRestMethod `\r\n        -ARMToken $ARMToken `\r\n        -Body ($Body | ConvertTo-Json -depth 20) `\r\n        -Method Put `\r\n        -Uri $Uri\r\n    \r\n    # Check if deployment submission was accepted\r\n    if ($deploymentJob.Error) {\r\n        Write-LogEntry -Message \"Deployment submission failed: $($deploymentJob.Error)\" -Level Error\r\n        return [PSCustomObject]@{\r\n            DeploymentName   = $deploymentName\r\n            SessionHostCount = $NewSessionHostsCount\r\n            Succeeded        = $false\r\n            Timestamp        = $deploymentTimestamp\r\n            ErrorMessage     = $deploymentJob.Error\r\n        }\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Deployment submitted successfully. Deployment name: $deploymentName\" -Level Trace\r\n    \r\n    # Return deployment information for state tracking\r\n    # Note: Succeeded is initially null - will be determined on next run\r\n    return [PSCustomObject]@{\r\n        DeploymentName   = $deploymentName\r\n        SessionHostCount = $NewSessionHostsCount\r\n        Succeeded        = $null  # Unknown until checked on next run\r\n        Timestamp        = $deploymentTimestamp\r\n        ErrorMessage     = $null\r\n    }\r\n}\r\n\r\nfunction Get-Deployments {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n\r\n        [Parameter()]\r\n        [string] $SubscriptionId = (Read-FunctionAppSetting VirtualMachinesSubscriptionId),\r\n\r\n        [Parameter()]\r\n        [string] $ResourceGroupName = (Read-FunctionAppSetting VirtualMachinesResourceGroupName),\r\n\r\n        [Parameter()]\r\n        [string] $DeploymentPrefix = (Read-FunctionAppSetting DeploymentPrefix),\r\n\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName)\r\n    )\r\n\r\n    Write-LogEntry -Message \"Getting deployments for resource group '$ResourceGroupName'\"\r\n    $Uri = \"$ResourceManagerUri/subscriptions/$SubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.Resources/deployments/?api-version=2021-04-01\"\r\n    $deployments = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n    \r\n    # Filter by deployment prefix\r\n    $deployments = $deployments | Where-Object { $_.name -like \"$DeploymentPrefix*\" }\r\n    \r\n    if ($deployments) {\r\n        Write-LogEntry -Message \"Deployment names: $($deployments.name -join ', ')\" -Level Trace\r\n    }\r\n    \r\n    # Handle failed deployments - don't block automation, but return info for cleanup\r\n    $failedDeployments = $deployments | Where-Object { $_.properties.provisioningState -eq 'Failed' }\r\n    if ($failedDeployments) {\r\n        Write-LogEntry -Message \"Found $($failedDeployments.Count) failed deployments. VMs from these deployments will be marked for cleanup.\" -Level Warning\r\n        foreach ($failedDeploy in $failedDeployments) {\r\n            if ($failedDeploy.properties.parameters) {\r\n                $parameters = $failedDeploy.properties.parameters | ConvertTo-CaseInsensitiveHashtable\r\n                $failedVMs = if ($parameters.ContainsKey('sessionHostNames')) { $parameters['sessionHostNames'].Value } else { @() }\r\n                Write-LogEntry -Message \"Failed deployment '$($failedDeploy.name)' attempted to deploy: $($failedVMs -join ',')\" -Level Warning\r\n            }\r\n        }\r\n    }\r\n    \r\n    $runningDeployments = $deployments | Where-Object { $_.properties.provisioningState -eq 'Running' }\r\n    \r\n    $warningThreshold = (Get-Date -AsUTC).AddHours(-2)\r\n    $longRunningDeployments = $runningDeployments | Where-Object { \r\n        $_.properties.timestamp -and $_.properties.timestamp -lt $warningThreshold\r\n    }\r\n    if ($longRunningDeployments) {\r\n        Write-LogEntry -Message \"Found $($longRunningDeployments.Count) deployments that have been running for more than 2 hours. This could block future deployments\" -Level Warning\r\n    }\r\n\r\n    # Return both running and failed deployments for proper handling\r\n    $output = @{\r\n        RunningDeployments = @()\r\n        FailedDeployments  = @()\r\n    }\r\n    \r\n    $output.RunningDeployments = foreach ($deployment in $runningDeployments) {\r\n        if ($deployment.properties.parameters) {\r\n            $parameters = $deployment.properties.parameters | ConvertTo-CaseInsensitiveHashtable\r\n            Write-LogEntry -Message \"Running deployment '$($deployment.name)' is deploying: $(($parameters['sessionHostNames'].Value -join ','))\" -Level Trace\r\n            [PSCustomObject]@{\r\n                DeploymentName   = $deployment.name\r\n                SessionHostNames = $parameters['sessionHostNames'].Value\r\n                Timestamp        = $deployment.properties.timestamp\r\n                Status           = $deployment.properties.provisioningState\r\n            }\r\n        }\r\n        else {\r\n            # Deployment has no parameters - still count it as running to prevent duplicates\r\n            Write-LogEntry -Message \"Running deployment '$($deployment.name)' has no parameters available - treating as running to prevent duplicate deployment\"\r\n            [PSCustomObject]@{\r\n                DeploymentName   = $deployment.name\r\n                SessionHostNames = @()\r\n                Timestamp        = $deployment.properties.timestamp\r\n                Status           = $deployment.properties.provisioningState\r\n            }\r\n        }\r\n    }\r\n    \r\n    $output.FailedDeployments = foreach ($deployment in $failedDeployments) {\r\n        if ($deployment.properties.parameters) {\r\n            $parameters = $deployment.properties.parameters | ConvertTo-CaseInsensitiveHashtable\r\n            [PSCustomObject]@{\r\n                DeploymentName   = $deployment.name\r\n                SessionHostNames = if ($parameters.ContainsKey('sessionHostNames')) { $parameters['sessionHostNames'].Value } else { @() }\r\n                Timestamp        = $deployment.properties.timestamp\r\n                Status           = $deployment.properties.provisioningState\r\n            }\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Failed deployment '$($deployment.name)' has no parameters available\"\r\n            [PSCustomObject]@{\r\n                DeploymentName   = $deployment.name\r\n                SessionHostNames = @()\r\n                Timestamp        = $deployment.properties.timestamp\r\n                Status           = $deployment.properties.provisioningState\r\n            }\r\n        }\r\n    }\r\n    \r\n    return $output\r\n}\r\n\r\nfunction Get-TemplateSpecVersionResourceId {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory = $true)]\r\n        [string]$ARMToken,\r\n        \r\n        [Parameter()]\r\n        [string]$ResourceManagerUri = (Get-ResourceManagerUri),\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [string]$ResourceId\r\n    )\r\n    $Uri = \"$ResourceManagerUri$($ResourceId)?api-version=2022-02-01\"    \r\n    $response = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n    $azResourceType = $response.type\r\n    Write-LogEntry -Message \"Resource type: $azResourceType\" -Level Trace\r\n    switch ($azResourceType) {\r\n        'Microsoft.Resources/templateSpecs' {\r\n            # List all versions of the template spec\r\n            $Uri = \"$ResourceManagerUri$($ResourceId)/versions?api-version=2022-02-01\"\r\n            Write-LogEntry -Message \"Calling API: $Uri\" -Level Trace\r\n            $templateSpecVersionsResponse = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n            \r\n            # Invoke-AzureRestMethod returns an array directly (handles paging internally)\r\n            # If there's only one version, it might be a single object; ensure it's an array\r\n            if ($templateSpecVersionsResponse -is [array]) {\r\n                $templateSpecVersions = $templateSpecVersionsResponse\r\n            }\r\n            else {\r\n                $templateSpecVersions = @($templateSpecVersionsResponse)\r\n            }\r\n            \r\n            if (-not $templateSpecVersions -or $templateSpecVersions.Count -eq 0) {\r\n                Write-LogEntry -Message \"No versions found in response\" -Level Warning\r\n                throw \"No versions found for Template Spec: $ResourceId\"\r\n            }\r\n            \r\n            Write-LogEntry -Message \"Template Spec has $($templateSpecVersions.count) versions\" -Level Trace\r\n            \r\n            # Filter versions that have a lastModifiedAt timestamp in systemData and sort by it\r\n            $versionsWithTime = $templateSpecVersions | Where-Object { $_.systemData.lastModifiedAt }\r\n            \r\n            if ($versionsWithTime -and $versionsWithTime.Count -gt 0) {\r\n                # Sort by last modified time (most recent first)\r\n                $latestVersion = $versionsWithTime | Sort-Object -Property { [DateTime]$_.systemData.lastModifiedAt } -Descending | Select-Object -First 1\r\n                Write-LogEntry -Message \"Latest version: $($latestVersion.name) Last modified at $($latestVersion.systemData.lastModifiedAt) - Returning Resource Id $($latestVersion.id)\"\r\n            }\r\n            else {\r\n                # Fallback: if no versions have lastModifiedAt, use version name sorting (assumes semantic versioning)\r\n                Write-LogEntry -Message \"No versions with systemData.lastModifiedAt found, sorting by version name\" -Level Warning\r\n                $latestVersion = $templateSpecVersions | Sort-Object -Property name -Descending | Select-Object -First 1\r\n                Write-LogEntry -Message \"Latest version: $($latestVersion.name) (sorted by name) - Returning Resource Id $($latestVersion.id)\"\r\n            }\r\n            \r\n            return $latestVersion.id\r\n        }\r\n        'Microsoft.Resources/templateSpecs/versions' {\r\n            return $ResourceId\r\n        }\r\n        Default {\r\n            throw (\"Supplied value has type '{0}' is not a valid Template Spec or Template Spec version resource Id.\" -f $azResourceType)\r\n        }\r\n    }\r\n}\r\n\r\nfunction Remove-FailedDeploymentArtifacts {\r\n    <#\r\n    .SYNOPSIS\r\n        Cleans up orphaned VMs and failed deployment records from previous failed deployments.\r\n    \r\n    .DESCRIPTION\r\n        Checks for VMs from failed deployments that may not be registered as session hosts,\r\n        deletes any orphaned VMs, and removes failed deployment records from ARM history.\r\n        This prevents the function from getting stuck with repeated failures on the same VM names.\r\n    \r\n    .PARAMETER ARMToken\r\n        The ARM access token for API calls.\r\n    \r\n    .PARAMETER GraphToken\r\n        The Graph access token for device cleanup.\r\n    \r\n    .PARAMETER FailedDeployments\r\n        Array of failed deployment objects from Get-Deployments.\r\n    \r\n    .PARAMETER RegisteredSessionHostNames\r\n        Array of session host names currently registered in the host pool.\r\n    \r\n    .PARAMETER RemoveEntraDevice\r\n        Whether to remove Entra device records.\r\n    \r\n    .PARAMETER RemoveIntuneDevice\r\n        Whether to remove Intune device records.\r\n    \r\n    .EXAMPLE\r\n        Remove-FailedDeploymentArtifacts -ARMToken $token -GraphToken $graphToken -FailedDeployments $failed -RegisteredSessionHostNames $sessionHosts.SessionHostName -RemoveEntraDevice $true -RemoveIntuneDevice $true\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        \r\n        [Parameter()]\r\n        [string] $GraphToken,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [array] $FailedDeployments,\r\n        \r\n        [Parameter()]\r\n        [array] $CachedVMs,\r\n        \r\n        [Parameter()]\r\n        [array] $RegisteredSessionHostNames = @(),\r\n        \r\n        [Parameter()]\r\n        [bool] $RemoveEntraDevice = (Read-FunctionAppSetting RemoveEntraDevice -AsBoolean),\r\n        \r\n        [Parameter()]\r\n        [bool] $RemoveIntuneDevice = (Read-FunctionAppSetting RemoveIntuneDevice -AsBoolean),\r\n        \r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n        \r\n        [Parameter()]\r\n        [string] $VirtualMachinesSubscriptionId = (Read-FunctionAppSetting VirtualMachinesSubscriptionId),\r\n        \r\n        [Parameter()]\r\n        [string] $VirtualMachinesResourceGroupName = (Read-FunctionAppSetting VirtualMachinesResourceGroupName)        \r\n    )\r\n    \r\n    if ($FailedDeployments.Count -eq 0) {\r\n        Write-LogEntry -Message \"No failed deployments to clean up\" -Level Trace\r\n        return\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Processing $($FailedDeployments.Count) failed deployments for cleanup\"\r\n    \r\n    # Use cached VMs if provided, otherwise fetch\r\n    if ($CachedVMs -and $CachedVMs.Count -gt 0) {\r\n        Write-LogEntry -Message \"Using cached VM data for orphaned VM check\" -Level Trace\r\n        $allVMs = $CachedVMs\r\n    }\r\n    else {\r\n        $Uri = \"$ResourceManagerUri/subscriptions/$VirtualMachinesSubscriptionId/resourceGroups/$VirtualMachinesResourceGroupName/providers/Microsoft.Compute/virtualMachines?api-version=2024-07-01\"\r\n        $allVMs = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n    }\r\n    \r\n    $orphanedVMs = @()\r\n    $failedDeploymentNames = @()\r\n    \r\n    foreach ($deployment in $FailedDeployments) {\r\n        $failedDeploymentNames += $deployment.DeploymentName\r\n        \r\n        foreach ($sessionHostName in $deployment.SessionHostNames) {\r\n            # Session host name is like 'avdtest01use201', but actual VM could be:\r\n            # - avdtest01use201 (no CAF naming)\r\n            # - vm-avdtest01use201 (CAF prefix)\r\n            # - avdtest01use201-vm (CAF suffix)\r\n            # \r\n            # Strategy: Find VMs where the session host name is contained in the VM name\r\n            \r\n            $matchingVMs = $allVMs | Where-Object { $_.name -like \"*$sessionHostName*\" }\r\n            \r\n            foreach ($vm in $matchingVMs) {\r\n                # Check if this VM is registered as a session host\r\n                $isRegistered = $RegisteredSessionHostNames | Where-Object { $_ -like \"$sessionHostName*\" }\r\n                \r\n                if (-not $isRegistered) {\r\n                    Write-LogEntry -Message \"Found orphaned VM from failed deployment: $($vm.name) (matches session host name $sessionHostName but not registered)\" -Level Warning\r\n                    $orphanedVMs += [PSCustomObject]@{\r\n                        Name            = $vm.name\r\n                        ResourceId      = $vm.id\r\n                        DeploymentName  = $deployment.DeploymentName\r\n                        SessionHostName = $sessionHostName\r\n                    }\r\n                }\r\n                else {\r\n                    Write-LogEntry -Message \"VM $($vm.name) from failed deployment is registered as session host - will be handled by normal cleanup flow\" -Level Trace\r\n                }\r\n            }\r\n            \r\n            if ($matchingVMs.Count -eq 0) {\r\n                Write-LogEntry -Message \"No VM found matching session host name $sessionHostName (deployment may have rolled back)\" -Level Trace\r\n            }\r\n        }\r\n    }\r\n    \r\n    # Delete orphaned VMs and their device records\r\n    if ($orphanedVMs.Count -gt 0) {\r\n        Write-LogEntry -Message \"Deleting $($orphanedVMs.Count) orphaned VMs from failed deployments\"\r\n        \r\n        foreach ($orphanedVM in $orphanedVMs) {\r\n            try {\r\n                # Delete Entra device if enabled\r\n                if ($RemoveEntraDevice -and $GraphToken) {\r\n                    try {\r\n                        $graphEndpoint = Get-GraphEndpoint\r\n                        $deviceUri = \"$graphEndpoint/v1.0/devices?`$filter=displayName eq '$($orphanedVM.SessionHostName)'\"\r\n                        $device = Invoke-GraphRestMethod -GraphToken $GraphToken -Method Get -Uri $deviceUri\r\n                        \r\n                        if ($device -and $device.Count -gt 0) {\r\n                            $deviceId = $device[0].id\r\n                            $deleteDeviceUri = \"$graphEndpoint/v1.0/devices/$deviceId\"\r\n                            Invoke-GraphRestMethod -GraphToken $GraphToken -Method DELETE -Uri $deleteDeviceUri\r\n                            Write-LogEntry -Message \"Successfully deleted Entra device for orphaned VM: $($orphanedVM.SessionHostName)\"\r\n                        }\r\n                        else {\r\n                            Write-LogEntry -Message \"No Entra device found for orphaned VM: $($orphanedVM.SessionHostName)\" -Level Trace\r\n                        }\r\n                    }\r\n                    catch {\r\n                        Write-LogEntry -Message \"Failed to delete Entra device for $($orphanedVM.SessionHostName): $_\" -Level Warning\r\n                    }\r\n                }\r\n                \r\n                # Delete Intune device if enabled\r\n                if ($RemoveIntuneDevice -and $GraphToken) {\r\n                    try {\r\n                        $graphEndpoint = Get-GraphEndpoint\r\n                        $deviceUri = \"$graphEndpoint/v1.0/deviceManagement/managedDevices?`$filter=deviceName eq '$($orphanedVM.SessionHostName)'\"\r\n                        $device = Invoke-GraphRestMethod -GraphToken $GraphToken -Method Get -Uri $deviceUri\r\n                        \r\n                        if ($device -and $device.Count -gt 0) {\r\n                            $deviceId = $device[0].id\r\n                            $deleteDeviceUri = \"$graphEndpoint/v1.0/deviceManagement/managedDevices/$deviceId\"\r\n                            Invoke-GraphRestMethod -GraphToken $GraphToken -Method DELETE -Uri $deleteDeviceUri\r\n                            Write-LogEntry -Message \"Successfully deleted Intune device for orphaned VM: $($orphanedVM.SessionHostName)\"\r\n                        }\r\n                        else {\r\n                            Write-LogEntry -Message \"No Intune device found for orphaned VM: $($orphanedVM.SessionHostName)\" -Level Trace\r\n                        }\r\n                    }\r\n                    catch {\r\n                        Write-LogEntry -Message \"Failed to delete Intune device for $($orphanedVM.SessionHostName): $_\" -Level Warning\r\n                    }\r\n                }\r\n                \r\n                # Delete the VM\r\n                Write-LogEntry -Message \"Deleting orphaned VM: $($orphanedVM.Name) (session host: $($orphanedVM.SessionHostName), from deployment: $($orphanedVM.DeploymentName))\" -Level Warning\r\n                $Uri = \"$ResourceManagerUri$($orphanedVM.ResourceId)?forceDeletion=true&api-version=2024-07-01\"\r\n                Invoke-AzureRestMethod -ARMToken $ARMToken -Method DELETE -Uri $Uri\r\n                Write-LogEntry -Message \"Successfully deleted orphaned VM: $($orphanedVM.Name)\"\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Failed to delete orphaned VM $($orphanedVM.Name): $_\" -Level Error\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"No orphaned VMs found from failed deployments\" -Level Trace\r\n    }\r\n    \r\n    # Clean up failed deployment records from ARM (including nested deployments)\r\n    Write-LogEntry -Message \"Cleaning up $($failedDeploymentNames.Count) failed deployment records from ARM history\"\r\n    \r\n    foreach ($deploymentName in $failedDeploymentNames) {\r\n        try {\r\n            # Recursively find all nested deployments\r\n            function Get-NestedDeployments {\r\n                param(\r\n                    [string]$DeploymentName,\r\n                    [string]$ARMToken,\r\n                    [string]$ResourceManagerUri,\r\n                    [string]$SubscriptionId,\r\n                    [string]$ResourceGroupName\r\n                )\r\n                \r\n                $allNested = @()\r\n                \r\n                try {\r\n                    # Get this deployment's details\r\n                    $Uri = \"$ResourceManagerUri/subscriptions/$SubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.Resources/deployments/$DeploymentName`?api-version=2021-04-01\"\r\n                    $deployment = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n                    \r\n                    if ($deployment -and $deployment.properties.dependencies) {\r\n                        # Extract nested deployment names from dependencies\r\n                        $nestedNames = $deployment.properties.dependencies | \r\n                        Where-Object { $_.resourceType -eq 'Microsoft.Resources/deployments' } |\r\n                        ForEach-Object { $_.resourceName }\r\n                        \r\n                        if ($nestedNames) {\r\n                            foreach ($nestedName in $nestedNames) {\r\n                                # Add this nested deployment\r\n                                $allNested += $nestedName\r\n                                \r\n                                # Recursively get its nested deployments\r\n                                $childNested = Get-NestedDeployments -DeploymentName $nestedName -ARMToken $ARMToken -ResourceManagerUri $ResourceManagerUri -SubscriptionId $SubscriptionId -ResourceGroupName $ResourceGroupName\r\n                                $allNested += $childNested\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"Warning: Could not retrieve nested deployments for $DeploymentName : $_\" -Level Warning\r\n                }\r\n                \r\n                return $allNested\r\n            }\r\n            \r\n            # Get all nested deployments recursively\r\n            $allNestedDeployments = Get-NestedDeployments -DeploymentName $deploymentName -ARMToken $ARMToken -ResourceManagerUri $ResourceManagerUri -SubscriptionId $VirtualMachinesSubscriptionId -ResourceGroupName $VirtualMachinesResourceGroupName\r\n            \r\n            if ($allNestedDeployments) {\r\n                Write-LogEntry -Message \"Found $($allNestedDeployments.Count) nested deployment(s) (including recursive nesting) from parent deployment\"\r\n                \r\n                # Delete nested deployments in reverse order (deepest first to avoid dependency issues)\r\n                [array]::Reverse($allNestedDeployments)\r\n                \r\n                foreach ($nestedDeploymentName in $allNestedDeployments) {\r\n                    try {\r\n                        Write-LogEntry -Message \"Deleting nested deployment record: $nestedDeploymentName\" -Level Trace\r\n                        $Uri = \"$ResourceManagerUri/subscriptions/$VirtualMachinesSubscriptionId/resourceGroups/$VirtualMachinesResourceGroupName/providers/Microsoft.Resources/deployments/$nestedDeploymentName`?api-version=2021-04-01\"\r\n                        Invoke-AzureRestMethod -ARMToken $ARMToken -Method DELETE -Uri $Uri\r\n                        Write-LogEntry -Message \"Successfully deleted nested deployment record: $nestedDeploymentName\" -Level Trace\r\n                    }\r\n                    catch {\r\n                        Write-LogEntry -Message \"Failed to delete nested deployment record $nestedDeploymentName`: $_\" -Level Warning\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"No nested deployments found for parent deployment\" -Level Trace\r\n            }\r\n            \r\n            # Delete the top-level deployment record last\r\n            Write-LogEntry -Message \"Deleting top-level deployment record: $deploymentName\"\r\n            $Uri = \"$ResourceManagerUri/subscriptions/$VirtualMachinesSubscriptionId/resourceGroups/$VirtualMachinesResourceGroupName/providers/Microsoft.Resources/deployments/$deploymentName`?api-version=2021-04-01\"\r\n            Invoke-AzureRestMethod -ARMToken $ARMToken -Method DELETE -Uri $Uri\r\n            Write-LogEntry -Message \"Successfully deleted deployment record: $deploymentName\"\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to delete deployment record $deploymentName`: $_\" -Level Warning\r\n        }\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Failed deployment cleanup completed\"\r\n}\r\n\r\n#EndRegion Deployment Operations\r\n\r\n# Export functions\r\nExport-ModuleMember -Function Get-DeploymentState, Get-LastDeploymentStatus, Save-DeploymentState, Deploy-SessionHosts, Get-Deployments, Get-TemplateSpecVersionResourceId, Remove-FailedDeploymentArtifacts\r\n",
    "$fxv#7": "# SessionHostReplacer Image Management Module\r\n# Contains image version comparison and retrieval functions\r\n\r\n# Import Core utilities\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Core.psm1\" -Force\r\n\r\n#Region Image Version Functions\r\n\r\nfunction Compare-ImageVersion {\r\n    <#\r\n    .SYNOPSIS\r\n    Compares two image versions to determine their relative order.\r\n    \r\n    .DESCRIPTION\r\n    Compares two image versions using semantic versioning rules (major.minor.patch).\r\n    Returns:\r\n        -1 if version1 < version2\r\n         0 if version1 = version2\r\n         1 if version1 > version2\r\n    \r\n    .PARAMETER Version1\r\n    The first version to compare.\r\n    \r\n    .PARAMETER Version2\r\n    The second version to compare.\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $Version1,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [string] $Version2\r\n    )\r\n    \r\n    # If versions are identical strings, return equal\r\n    if ($Version1 -eq $Version2) {\r\n        return 0\r\n    }\r\n    \r\n    try {\r\n        # Try to parse as semantic versions (e.g., 1.0.0, 2.1.3)\r\n        $v1Parts = $Version1 -split '\\.' | ForEach-Object { \r\n            $num = 0\r\n            if ([int]::TryParse($_, [ref]$num)) { $num } else { 0 }\r\n        }\r\n        $v2Parts = $Version2 -split '\\.' | ForEach-Object { \r\n            $num = 0\r\n            if ([int]::TryParse($_, [ref]$num)) { $num } else { 0 }\r\n        }\r\n        \r\n        # Pad arrays to same length with zeros\r\n        $maxLength = [Math]::Max($v1Parts.Count, $v2Parts.Count)\r\n        while ($v1Parts.Count -lt $maxLength) { $v1Parts += 0 }\r\n        while ($v2Parts.Count -lt $maxLength) { $v2Parts += 0 }\r\n        \r\n        # Compare each part\r\n        for ($i = 0; $i -lt $maxLength; $i++) {\r\n            if ($v1Parts[$i] -lt $v2Parts[$i]) {\r\n                return -1\r\n            }\r\n            elseif ($v1Parts[$i] -gt $v2Parts[$i]) {\r\n                return 1\r\n            }\r\n        }\r\n        \r\n        # All parts equal\r\n        return 0\r\n    }\r\n    catch {\r\n        # If parsing fails, fall back to string comparison\r\n        Write-LogEntry -Message \"Failed to parse versions as semantic versions, using string comparison: $_\" -Level Warning\r\n        if ($Version1 -lt $Version2) { return -1 }\r\n        elseif ($Version1 -gt $Version2) { return 1 }\r\n        else { return 0 }\r\n    }\r\n}\r\n\r\nfunction Get-LatestImageVersion {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n\r\n        [Parameter()]\r\n        [string] $SubscriptionId = (Read-FunctionAppSetting VirtualMachinesSubscriptionId),\r\n\r\n        [Parameter()]\r\n        [hashtable] $ImageReference,\r\n\r\n        [Parameter()]\r\n        [string] $Location\r\n    )\r\n\r\n    # Initialize variables\r\n    $azImageVersion = $null\r\n    $azImageDate = $null\r\n    $azImageDefinition = $null\r\n    \r\n    # Marketplace image\r\n    if ($ImageReference.publisher) {\r\n        # Set marketplace image definition for both latest and specific versions\r\n        $azImageDefinition = \"marketplace:$($ImageReference.publisher)/$($ImageReference.offer)/$($ImageReference.sku)\"\r\n        \r\n        if ($null -ne $ImageReference.version -and $ImageReference.version -ne 'latest') {\r\n            Write-LogEntry  \"Image version is not set to latest. Returning version '$($ImageReference.version)'\"\r\n            $azImageVersion = $ImageReference.version\r\n            # For specific marketplace versions, use current date as fallback since we can't determine actual publish date\r\n            $azImageDate = Get-Date -AsUTC\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Getting latest version of image publisher: $($ImageReference.publisher), offer: $($ImageReference.offer), sku: $($ImageReference.sku) in region: $($Location)\"\r\n                      \r\n            $Uri = \"$ResourceManagerUri/subscriptions/$SubscriptionId/providers/Microsoft.Compute/locations/$Location/publishers/$($ImageReference.publisher)/artifacttypes/vmimage/offers/$($ImageReference.offer)/skus/$($ImageReference.sku)/versions?api-version=2024-07-01\"\r\n            \r\n            $response = Invoke-AzureRestMethod -ARMToken $ARMToken -Uri $Uri -Method Get\r\n            $Versions = @($response)\r\n            \r\n            if (-not $Versions -or $Versions.Count -eq 0) {\r\n                throw \"No image versions found for publisher: $($ImageReference.publisher), offer: $($ImageReference.offer), sku: $($ImageReference.sku)\"\r\n            }\r\n            \r\n            Write-LogEntry -Message \"Found $($Versions.Count) image versions\"\r\n            \r\n            # Sort versions and get the latest (sort by name as string since version format may have 4 components)\r\n            $latestVersion = $Versions | Sort-Object -Property name -Descending | Select-Object -First 1\r\n            \r\n            if ($null -eq $latestVersion) {\r\n                throw \"Failed to sort and select latest version from API response\"\r\n            }\r\n            \r\n            $azImageVersion = $latestVersion.name\r\n            \r\n            if (-not $azImageVersion) {\r\n                throw \"Could not extract version name from latest image version object\"\r\n            }\r\n            \r\n            Write-LogEntry -Message \"Latest version of image is $azImageVersion\" -Level Trace\r\n\r\n            if ($azImageVersion -match \"\\d+\\.\\d+\\.(?<Year>\\d{2})(?<Month>\\d{2})(?<Day>\\d{2})\") {\r\n                $azImageDate = Get-Date -Date (\"20{0}-{1}-{2}\" -f $Matches.Year, $Matches.Month, $Matches.Day)\r\n                Write-LogEntry  \"Image date is $azImageDate\"\r\n            }\r\n            else {\r\n                throw \"Image version does not match expected format. Could not extract image date.\"\r\n            }\r\n        }\r\n    }\r\n    elseif ($ImageReference.id) {\r\n        $imageDefinitionResourceIdPattern = '^\\/subscriptions\\/(?<subscription>[a-z0-9\\-]+)\\/resourceGroups\\/(?<resourceGroup>[^\\/]+)\\/providers\\/Microsoft\\.Compute\\/galleries\\/(?<gallery>[^\\/]+)\\/images\\/(?<image>[^\\/]+)$'\r\n        $imageVersionResourceIdPattern = '^\\/subscriptions\\/(?<subscription>[a-z0-9\\-]+)\\/resourceGroups\\/(?<resourceGroup>[^\\/]+)\\/providers\\/Microsoft\\.Compute\\/galleries\\/(?<gallery>[^\\/]+)\\/images\\/(?<image>[^\\/]+)\\/versions\\/(?<version>[^\\/]+)$'\r\n        if ($ImageReference.id -match $imageDefinitionResourceIdPattern) {\r\n            Write-LogEntry 'Image reference is an Image Definition resource.'\r\n            $imageSubscriptionId = $Matches.subscription\r\n            $imageResourceGroup = $Matches.resourceGroup\r\n            $imageGalleryName = $Matches.gallery\r\n            $imageDefinitionName = $Matches.image\r\n            Write-LogEntry -Message \"Fetching image versions for gallery '$imageGalleryName', image definition '$imageDefinitionName' in resource group '$imageResourceGroup' and subscription '$imageSubscriptionId'.\"\r\n            \r\n            # Store the image definition resource ID for tracking\r\n            $azImageDefinition = $ImageReference.id\r\n\r\n            # First, list all image versions (without replication status)\r\n            $Uri = \"$ResourceManagerUri/subscriptions/$imageSubscriptionId/resourceGroups/$imageResourceGroup/providers/Microsoft.Compute/galleries/$imageGalleryName/images/$imageDefinitionName/versions?api-version=2024-03-03\"\r\n            $imageVersions = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n            \r\n            if (-not $imageVersions -or $imageVersions.Count -eq 0) {\r\n                throw \"No image versions found in gallery '$imageGalleryName' for image '$imageDefinitionName'.\"\r\n            }\r\n            \r\n            Write-LogEntry -Message \"Found $($imageVersions.Count) total image versions in gallery\" -Level Trace\r\n            \r\n            # Normalize location for comparison (Azure returns full names like \"East US 2\")\r\n            $normalizedLocation = $Location -replace '\\s', ''\r\n            \r\n            # Filter candidate versions (exclude flag check and published date check only)\r\n            # We'll check replication status afterwards for the selected candidate\r\n            $candidateVersions = $imageVersions |\r\n            Where-Object { \r\n                $globalExclude = $_.properties.publishingProfile.excludeFromLatest\r\n                $regionalExclude = $false\r\n                \r\n                # Check if this version is excluded in the target region\r\n                $targetRegion = $_.properties.publishingProfile.targetRegions | Where-Object { \r\n                    ($_.name -replace '\\s', '') -eq $normalizedLocation \r\n                }\r\n                if ($targetRegion) {\r\n                    $regionalExclude = $targetRegion.excludeFromLatest\r\n                }\r\n                \r\n                # Include only if NOT excluded globally AND NOT excluded regionally AND has published date\r\n                -not $globalExclude -and -not $regionalExclude -and $_.properties.publishingProfile.publishedDate\r\n            }\r\n            \r\n            if (-not $candidateVersions -or $candidateVersions.Count -eq 0) {\r\n                # Fallback: if no valid candidates, get first non-excluded version\r\n                $candidateVersions = $imageVersions |\r\n                Where-Object { -not $_.properties.publishingProfile.excludeFromLatest }\r\n            }\r\n            \r\n            if (-not $candidateVersions -or $candidateVersions.Count -eq 0) {\r\n                throw \"No available image versions found (all versions are marked as excluded from latest).\"\r\n            }\r\n            \r\n            # Sort candidates by published date and check replication status for each until we find a replicated one\r\n            $sortedCandidates = $candidateVersions |\r\n            Sort-Object -Property { [DateTime]$_.properties.publishingProfile.publishedDate } -Descending\r\n            \r\n            $latestImageVersion = $null\r\n            foreach ($candidate in $sortedCandidates) {\r\n                # Fetch full details with replication status for this specific version\r\n                $versionUri = \"$ResourceManagerUri/subscriptions/$imageSubscriptionId/resourceGroups/$imageResourceGroup/providers/Microsoft.Compute/galleries/$imageGalleryName/images/$imageDefinitionName/versions/$($candidate.name)?`$expand=ReplicationStatus&api-version=2024-03-03\"\r\n                $versionDetails = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $versionUri\r\n                \r\n                # Check replication status for the target region\r\n                $isReplicated = $false\r\n                if ($versionDetails.properties.replicationStatus.summary) {\r\n                    $regionReplicationStatus = $versionDetails.properties.replicationStatus.summary | Where-Object {\r\n                        ($_.region -replace '\\s', '') -eq $normalizedLocation\r\n                    }\r\n                    \r\n                    if ($regionReplicationStatus) {\r\n                        $isReplicated = $regionReplicationStatus.state -eq 'Completed'\r\n                        \r\n                        if ($isReplicated) {\r\n                            Write-LogEntry -Message \"Image version {0} is replicated to region {1}\" `\r\n                                -StringValues $candidate.name, $Location\r\n                            $latestImageVersion = $versionDetails\r\n                            break\r\n                        }\r\n                        else {\r\n                            Write-LogEntry -Message \"Image version {0} is not yet replicated to region {1} (state: {2}, progress: {3}%)\" `\r\n                                -StringValues $candidate.name, $Location, $regionReplicationStatus.state, $regionReplicationStatus.progress `\r\n                                -Level Warning\r\n                        }\r\n                    }\r\n                    else {\r\n                        Write-LogEntry -Message \"Image version {0} does not have replication status for region {1}\" `\r\n                            -StringValues $candidate.name, $Location `\r\n                            -Level Warning\r\n                    }\r\n                }\r\n                else {\r\n                    Write-LogEntry -Message \"Image version {0} does not have replication status information\" `\r\n                        -StringValues $candidate.name `\r\n                        -Level Warning\r\n                }\r\n            }\r\n            \r\n            if (-not $latestImageVersion) {\r\n                throw \"No replicated image versions found for region '$Location'. All candidate versions are either still replicating or missing replication status.\"\r\n            }\r\n            \r\n            $azImageVersion = $latestImageVersion.name\r\n            $azImageDate = [DateTime]$latestImageVersion.properties.publishingProfile.publishedDate\r\n            Write-LogEntry -Message \"Select image version is {0} and date is {1}\" -StringValues $azImageVersion, $azImageDate.ToString('o')\r\n        }\r\n        elseif ($ImageReference.id -match $imageVersionResourceIdPattern ) {\r\n            Write-LogEntry 'Image reference is an Image Version resource.'\r\n            # Extract image definition path (without version)\r\n            if ($ImageReference.id -match '^(?<definition>.+)/versions/[^/]+$') {\r\n                $azImageDefinition = $Matches['definition']\r\n            }\r\n            $Uri = \"$ResourceManagerUri$($ImageReference.id)?api-version=2023-07-03\"\r\n            $imageVersion = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n            $azImageVersion = $imageVersion.name\r\n            \r\n            # Parse published date with null check\r\n            if ($imageVersion.properties.publishingProfile.publishedDate) {\r\n                $azImageDate = [DateTime]$imageVersion.properties.publishingProfile.publishedDate\r\n                Write-LogEntry -Message \"Image version is {0} and date is {1}\" -StringValues $azImageVersion, $azImageDate.ToString('o')\r\n            } else {\r\n                # Fallback to current date if published date not available\r\n                $azImageDate = Get-Date -AsUTC\r\n                Write-LogEntry -Message \"Image version is {0} (published date not available, using current date)\" -StringValues $azImageVersion -Level Warning\r\n            }\r\n        }\r\n        else {\r\n            throw \"Image reference id does not match expected format for an Image Definition resource.\"\r\n        }\r\n    }\r\n    else {\r\n        throw \"Image reference does not contain a publisher or id property. ImageReference, publisher, and id are case sensitive!!\"\r\n    }\r\n    return [PSCustomObject]@{\r\n        Version    = $azImageVersion\r\n        Date       = $azImageDate\r\n        Definition = $azImageDefinition\r\n    }\r\n}\r\n\r\n#EndRegion Image Version Functions\r\n\r\n# Export functions\r\nExport-ModuleMember -Function Compare-ImageVersion, Get-LatestImageVersion",
    "$fxv#8": "# SessionHostReplacer Planning Module\r\n# Contains session host planning and inventory functions\r\n\r\n# Import Core and Deployment utilities\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Core.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Deployment.psm1\" -Force\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.ImageManagement.psm1\" -Force\r\n\r\n#Region Session Host Planning\r\n\r\nfunction Get-ScalingPlanCurrentTarget {\r\n    <#\r\n    .SYNOPSIS\r\n    Queries the scaling plan associated with a host pool and determines the current capacity target percentage based on active schedules.\r\n    \r\n    .DESCRIPTION\r\n    This function retrieves the scaling plan configuration for a host pool and evaluates the current schedule\r\n    to determine what capacity percentage is currently targeted. This can be used as a dynamic minimum capacity\r\n    floor for replacement operations, allowing more aggressive replacements during off-peak hours and more\r\n    conservative behavior during peak hours.\r\n    \r\n    .PARAMETER ARMToken\r\n    ARM access token for Azure API calls\r\n    \r\n    .PARAMETER HostPoolResourceId\r\n    Full resource ID of the host pool\r\n    \r\n    .PARAMETER CurrentDateTime\r\n    Current date/time in UTC (defaults to Get-Date -AsUTC). Used for schedule evaluation.\r\n    \r\n    .RETURNS\r\n    PSCustomObject with properties:\r\n    - CapacityPercentage: Current target capacity percentage (0-100), or $null if no scaling plan found\r\n    - ScalingPlanName: Name of the scaling plan, or $null if not found\r\n    - ScheduleName: Name of the active schedule, or $null if not in a scheduled period\r\n    - Phase: Current phase (RampUp, Peak, RampDown, OffPeak), or $null if not in a scheduled period\r\n    - Source: 'ScalingPlan' if from active schedule, 'LoadBalancing' if from load balancing config, or $null\r\n    \r\n    .EXAMPLE\r\n    $scalingTarget = Get-ScalingPlanCurrentTarget -ARMToken $token -HostPoolResourceId $hostPoolId\r\n    if ($scalingTarget.CapacityPercentage) {\r\n        Write-LogEntry -Message \"Current scaling plan target: {0}%\" -StringValues $scalingTarget.CapacityPercentage\r\n    }\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $HostPoolResourceId,\r\n        [Parameter()]\r\n        [datetime] $CurrentDateTime = (Get-Date -AsUTC),\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri)\r\n    )\r\n    \r\n    try {\r\n        Write-LogEntry -Message \"Querying scaling plan assigned to host pool\" -Level Information\r\n        \r\n        # Query scaling plans assigned to this host pool - returns scaling plan details directly\r\n        $scalingPlansUri = \"$ResourceManagerUri$HostPoolResourceId/scalingPlans?api-version=2024-04-03\"\r\n        $scalingPlansResponse = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $scalingPlansUri\r\n        \r\n        if (-not $scalingPlansResponse -or $scalingPlansResponse.Count -eq 0) {\r\n            Write-LogEntry -Message \"No scaling plan assigned to this host pool\" -Level Information\r\n            return [PSCustomObject]@{\r\n                CapacityPercentage = $null\r\n                ScalingPlanName = $null\r\n                ScheduleName = $null\r\n                Phase = $null\r\n                Source = $null\r\n            }\r\n        }\r\n        \r\n        # Get the first (should be only one) scaling plan\r\n        $scalingPlan = $scalingPlansResponse[0]\r\n        $scalingPlanName = $scalingPlan.name\r\n        \r\n        # Check if scaling plan is enabled for this host pool\r\n        $hostPoolReference = $scalingPlan.properties.hostPoolReferences | Where-Object { \r\n            $_.hostPoolArmPath -eq $HostPoolResourceId \r\n        } | Select-Object -First 1\r\n        \r\n        if (-not $hostPoolReference -or $hostPoolReference.scalingPlanEnabled -ne $true) {\r\n            Write-LogEntry -Message \"Scaling plan '$scalingPlanName' is assigned but NOT enabled for this host pool (scalingPlanEnabled: $($hostPoolReference.scalingPlanEnabled))\" -Level Information\r\n            return [PSCustomObject]@{\r\n                CapacityPercentage = $null\r\n                ScalingPlanName = $scalingPlanName\r\n                ScheduleName = $null\r\n                Phase = $null\r\n                Source = 'Disabled'\r\n            }\r\n        }\r\n        \r\n        Write-LogEntry -Message \"Found enabled scaling plan: $scalingPlanName\" -Level Information\r\n        \r\n        # Get scaling plan time zone and convert current time from UTC\r\n        $scalingPlanTimeZone = $scalingPlan.properties.timeZone\r\n        if (-not $scalingPlanTimeZone) {\r\n            Write-LogEntry -Message \"Scaling plan does not have a time zone configured - cannot evaluate schedules\" -Level Warning\r\n            return [PSCustomObject]@{\r\n                CapacityPercentage = $null\r\n                ScalingPlanName = $scalingPlanName\r\n                ScheduleName = $null\r\n                Phase = $null\r\n                Source = 'NoTimeZone'\r\n            }\r\n        }\r\n        \r\n        Write-LogEntry -Message \"Scaling plan time zone: $scalingPlanTimeZone\" -Level Information\r\n        \r\n        # Convert current UTC time to scaling plan's time zone\r\n        try {\r\n            $timeZoneInfo = [System.TimeZoneInfo]::FindSystemTimeZoneById($scalingPlanTimeZone)\r\n            $currentLocalTime = [System.TimeZoneInfo]::ConvertTimeFromUtc($CurrentDateTime, $timeZoneInfo)\r\n            Write-LogEntry -Message \"Current time: UTC=$($CurrentDateTime.ToString('yyyy-MM-dd HH:mm:ss')), Local($scalingPlanTimeZone)=$($currentLocalTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -Level Information\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to convert time zone '$scalingPlanTimeZone': $($_.Exception.Message)\" -Level Warning\r\n            return [PSCustomObject]@{\r\n                CapacityPercentage = $null\r\n                ScalingPlanName = $scalingPlanName\r\n                ScheduleName = $null\r\n                Phase = $null\r\n                Source = 'TimeZoneError'\r\n            }\r\n        }\r\n        \r\n        # Get current day of week and time for schedule matching (in scaling plan's time zone)\r\n        $currentDayOfWeek = $currentLocalTime.DayOfWeek.ToString()\r\n        $currentTimeSpan = $currentLocalTime.TimeOfDay\r\n        \r\n        # Format current time as HH:mm for display\r\n        $currentTimeDisplay = \"{0:D2}:{1:D2}\" -f $currentTimeSpan.Hours, $currentTimeSpan.Minutes\r\n        \r\n        Write-LogEntry -Message \"Evaluating schedules for: $currentDayOfWeek at $currentTimeDisplay ($scalingPlanTimeZone)\" -Level Trace\r\n        \r\n        # Evaluate schedules to find active one\r\n        $schedules = $scalingPlan.properties.schedules\r\n        $activeSchedule = $null\r\n        $activePhase = $null\r\n        $capacityPercentage = $null\r\n        \r\n        foreach ($schedule in $schedules) {\r\n            # Check if current day is in schedule's days of week\r\n            if ($schedule.daysOfWeek -notcontains $currentDayOfWeek) {\r\n                continue\r\n            }\r\n            \r\n            Write-LogEntry -Message \"Checking schedule: $($schedule.name)\" -Level Trace\r\n            \r\n            # Determine which phase we're in based on time\r\n            # Phases: RampUp -> Peak -> RampDown -> OffPeak (wraps to next day's RampUp)\r\n            # Times are returned as objects with hour/minute properties, not strings\r\n            $rampUpStart = New-TimeSpan -Hours $schedule.rampUpStartTime.hour -Minutes $schedule.rampUpStartTime.minute\r\n            $peakStart = New-TimeSpan -Hours $schedule.peakStartTime.hour -Minutes $schedule.peakStartTime.minute\r\n            $rampDownStart = New-TimeSpan -Hours $schedule.rampDownStartTime.hour -Minutes $schedule.rampDownStartTime.minute\r\n            $offPeakStart = New-TimeSpan -Hours $schedule.offPeakStartTime.hour -Minutes $schedule.offPeakStartTime.minute\r\n            \r\n            # Format TimeSpan as HH:mm for display (TimeSpan.ToString doesn't support custom format strings the same way)\r\n            $rampUpDisplay = \"{0:D2}:{1:D2}\" -f $rampUpStart.Hours, $rampUpStart.Minutes\r\n            $peakDisplay = \"{0:D2}:{1:D2}\" -f $peakStart.Hours, $peakStart.Minutes\r\n            $rampDownDisplay = \"{0:D2}:{1:D2}\" -f $rampDownStart.Hours, $rampDownStart.Minutes\r\n            $offPeakDisplay = \"{0:D2}:{1:D2}\" -f $offPeakStart.Hours, $offPeakStart.Minutes\r\n            $currentDisplay = \"{0:D2}:{1:D2}\" -f $currentTimeSpan.Hours, $currentTimeSpan.Minutes\r\n            \r\n            Write-LogEntry -Message \"Phase times for schedule '$($schedule.name)': RampUp=$rampUpDisplay, Peak=$peakDisplay, RampDown=$rampDownDisplay, OffPeak=$offPeakDisplay, Current=$currentDisplay\" -Level Trace\r\n            \r\n            # Determine current phase and capacity\r\n            if ($currentTimeSpan -ge $rampUpStart -and $currentTimeSpan -lt $peakStart) {\r\n                $activePhase = 'RampUp'\r\n                # During ramp-up, target is minimum healthy host percentage\r\n                $capacityPercentage = $schedule.rampUpMinimumHostsPct\r\n                Write-LogEntry -Message \"Matched phase: RampUp (current $currentDisplay >= $rampUpDisplay AND < $peakDisplay)\" -Level Trace\r\n            }\r\n            elseif ($currentTimeSpan -ge $peakStart -and $currentTimeSpan -lt $rampDownStart) {\r\n                $activePhase = 'Peak'\r\n                # During peak, maintain same conservative floor as ramp-up (highest usage period)\r\n                $capacityPercentage = $schedule.rampUpMinimumHostsPct\r\n                Write-LogEntry -Message \"Matched phase: Peak (current $currentDisplay >= $peakDisplay AND < $rampDownDisplay)\" -Level Trace\r\n            }\r\n            elseif ($currentTimeSpan -ge $rampDownStart -and $currentTimeSpan -lt $offPeakStart) {\r\n                $activePhase = 'RampDown'\r\n                # During ramp-down, target is minimum healthy host percentage\r\n                $capacityPercentage = $schedule.rampDownMinimumHostsPct\r\n                Write-LogEntry -Message \"Matched phase: RampDown (current $currentDisplay >= $rampDownDisplay AND < $offPeakDisplay)\" -Level Trace\r\n            }\r\n            elseif ($currentTimeSpan -ge $offPeakStart -or $currentTimeSpan -lt $rampUpStart) {\r\n                $activePhase = 'OffPeak'\r\n                # During off-peak, use same floor as ramp-down (lowest usage period)\r\n                $capacityPercentage = $schedule.rampDownMinimumHostsPct\r\n                Write-LogEntry -Message \"Matched phase: OffPeak (current $currentDisplay >= $offPeakDisplay OR < $rampUpDisplay)\" -Level Trace\r\n            }\r\n            \r\n            # SAFETY: Look-ahead check to prevent capacity issues near phase transitions\r\n            # If we're within 30 minutes of transitioning to a higher-capacity phase, use that phase's percentage instead\r\n            # This prevents starting aggressive deletions right before scaling plan needs to add capacity\r\n            # 30-minute window accounts for: deletion verification (~5 min) + deployment time (~20 min) + buffer\r\n            $lookAheadMinutes = 30\r\n            $lookAheadTime = $currentTimeSpan.Add([TimeSpan]::FromMinutes($lookAheadMinutes))\r\n            $nextPhaseCapacity = $null\r\n            $nextPhaseName = $null\r\n            \r\n            # Check if look-ahead time crosses into a different phase (within same day)\r\n            # For transitions that cross midnight (OffPeak->RampUp), we need to handle day boundary\r\n            if ($activePhase -eq 'RampUp' -and $lookAheadTime -ge $peakStart) {\r\n                # We're in RampUp but about to transition to Peak (same capacity, no action needed)\r\n                $nextPhaseCapacity = $schedule.rampUpMinimumHostsPct\r\n                $nextPhaseName = 'Peak'\r\n            }\r\n            elseif ($activePhase -eq 'Peak' -and $lookAheadTime -ge $rampDownStart) {\r\n                # We're in Peak but about to transition to RampDown (lower capacity, okay to use current)\r\n                # No adjustment needed - we're moving to lower capacity requirement\r\n            }\r\n            elseif ($activePhase -eq 'RampDown' -and $lookAheadTime -ge $offPeakStart -and $lookAheadTime.TotalHours -lt 24) {\r\n                # We're in RampDown but about to transition to OffPeak (same capacity, no action needed)\r\n                # No adjustment needed - same capacity requirement\r\n                # Only check if look-ahead doesn't cross midnight (stays within current day)\r\n            }\r\n            elseif ($activePhase -eq 'OffPeak' -and $lookAheadTime.TotalHours -lt 24 -and $lookAheadTime -ge $rampUpStart -and $rampUpStart -gt $offPeakStart) {\r\n                # We're in OffPeak but about to transition to RampUp (SAME DAY only)\r\n                # Only applies if RampUp is later in the day than OffPeak (unusual schedule)\r\n                # Most schedules have RampUp early morning and OffPeak late night (crosses midnight)\r\n                $nextPhaseCapacity = $schedule.rampUpMinimumHostsPct\r\n                $nextPhaseName = 'RampUp'\r\n            }\r\n            \r\n            # Apply more conservative (higher) percentage if next phase requires more capacity\r\n            if ($nextPhaseCapacity -and $nextPhaseCapacity -gt $capacityPercentage) {\r\n                Write-LogEntry -Message \"Safety look-ahead: Transitioning from $activePhase to $nextPhaseName in <$lookAheadMinutes min. Using more conservative $nextPhaseCapacity% instead of $capacityPercentage%\" -Level Trace\r\n                $capacityPercentage = $nextPhaseCapacity\r\n                $activePhase = \"$activePhase->$nextPhaseName (look-ahead)\"\r\n            }\r\n            \r\n            if ($activePhase) {\r\n                $activeSchedule = $schedule\r\n                Write-LogEntry -Message \"Active schedule found: $($schedule.name), Phase: $activePhase, Target capacity: $capacityPercentage%\" -Level Trace\r\n                break\r\n            }\r\n        }\r\n        \r\n        if ($activeSchedule -and $capacityPercentage) {\r\n            return [PSCustomObject]@{\r\n                CapacityPercentage = $capacityPercentage\r\n                ScalingPlanName = $scalingPlanName\r\n                ScheduleName = $activeSchedule.name\r\n                Phase = $activePhase\r\n                Source = 'ScalingPlan'\r\n            }\r\n        }\r\n        else {\r\n            # No schedule found for current day - find most recent scheduled day and use its ramp-down percentage\r\n            Write-LogEntry -Message \"No schedule found for $currentDayOfWeek - searching for most recent scheduled day\" -Level Trace\r\n            \r\n            # Day of week ordering: Sunday=0, Monday=1, ..., Saturday=6\r\n            $dayOrder = @{\r\n                'Sunday' = 0\r\n                'Monday' = 1\r\n                'Tuesday' = 2\r\n                'Wednesday' = 3\r\n                'Thursday' = 4\r\n                'Friday' = 5\r\n                'Saturday' = 6\r\n            }\r\n            \r\n            $currentDayIndex = $dayOrder[$currentDayOfWeek]\r\n            $fallbackCapacityPct = $null\r\n            $fallbackScheduleName = $null\r\n            \r\n            # Search backwards through days to find most recent scheduled day\r\n            for ($i = 1; $i -le 7; $i++) {\r\n                $checkDayIndex = ($currentDayIndex - $i + 7) % 7\r\n                $checkDayName = $dayOrder.GetEnumerator() | Where-Object { $_.Value -eq $checkDayIndex } | Select-Object -ExpandProperty Key\r\n                \r\n                # Check if any schedule covers this day\r\n                foreach ($schedule in $schedules) {\r\n                    if ($schedule.daysOfWeek -contains $checkDayName) {\r\n                        $fallbackCapacityPct = $schedule.rampDownMinimumHostsPct\r\n                        $fallbackScheduleName = $schedule.name\r\n                        Write-LogEntry -Message \"Found most recent scheduled day: $checkDayName (schedule: $fallbackScheduleName, using rampDown: $fallbackCapacityPct%)\" -Level Trace\r\n                        break\r\n                    }\r\n                }\r\n                \r\n                if ($fallbackCapacityPct) {\r\n                    break\r\n                }\r\n            }\r\n            \r\n            if ($fallbackCapacityPct) {\r\n                return [PSCustomObject]@{\r\n                    CapacityPercentage = $fallbackCapacityPct\r\n                    ScalingPlanName = $scalingPlanName\r\n                    ScheduleName = \"$fallbackScheduleName (fallback)\"\r\n                    Phase = 'OffPeak (no schedule)'\r\n                    Source = 'ScalingPlan'\r\n                }\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"No schedules found in scaling plan at all\" -Level Trace\r\n                return [PSCustomObject]@{\r\n                    CapacityPercentage = $null\r\n                    ScalingPlanName = $scalingPlanName\r\n                    ScheduleName = $null\r\n                    Phase = $null\r\n                    Source = $null\r\n                }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-LogEntry -Message \"Error querying scaling plan: $($_.Exception.Message)\" -Level Warning\r\n        Write-LogEntry -Message \"Stack trace: $($_.ScriptStackTrace)\" -Level Trace\r\n        return [PSCustomObject]@{\r\n            CapacityPercentage = $null\r\n            ScalingPlanName = $null\r\n            ScheduleName = $null\r\n            Phase = $null\r\n            Source = 'Error'\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-SessionHostReplacementPlan {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter()]\r\n        [array] $SessionHosts = @(),\r\n        [Parameter()]\r\n        $RunningDeployments,\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n        [Parameter()]\r\n        [int] $TargetSessionHostCount = (Read-FunctionAppSetting TargetSessionHostCount),\r\n        [Parameter()]\r\n        [PSCustomObject] $LatestImageVersion,\r\n        [Parameter()]\r\n        [int] $ReplaceSessionHostOnNewImageVersionDelayDays = (Read-FunctionAppSetting ReplaceSessionHostOnNewImageVersionDelayDays),\r\n        [Parameter()]\r\n        [bool] $AllowImageVersionRollback = $false,\r\n        [Parameter()]\r\n        [bool] $EnableProgressiveScaleUp = (Read-FunctionAppSetting EnableProgressiveScaleUp -AsBoolean),\r\n        [Parameter()]\r\n        [int] $InitialDeploymentPercentage = (Read-FunctionAppSetting InitialDeploymentPercentage),\r\n        [Parameter()]\r\n        [int] $ScaleUpIncrementPercentage = (Read-FunctionAppSetting ScaleUpIncrementPercentage),\r\n        [Parameter()]\r\n        [int] $MaxDeploymentBatchSize = $(\r\n            $setting = Read-FunctionAppSetting MaxDeploymentBatchSize\r\n            if ([string]::IsNullOrEmpty($setting)) { 100 } else { $setting }\r\n        ),\r\n        [Parameter()]\r\n        [int] $SuccessfulRunsBeforeScaleUp = (Read-FunctionAppSetting SuccessfulRunsBeforeScaleUp),\r\n        [Parameter()]\r\n        [string] $ReplacementMode = (Read-FunctionAppSetting ReplacementMode),\r\n        [Parameter()]\r\n        [int] $DrainGracePeriodHours = (Read-FunctionAppSetting DrainGracePeriodHours),\r\n        [Parameter()]\r\n        [int] $MinimumCapacityPercentage = $(\r\n            $setting = Read-FunctionAppSetting MinimumCapacityPercentage\r\n            if ([string]::IsNullOrEmpty($setting)) { 50 } else { $setting }\r\n        ),\r\n        [Parameter()]\r\n        [int] $MaxDeletionsPerCycle = $(\r\n            $setting = Read-FunctionAppSetting MaxDeletionsPerCycle\r\n            if ([string]::IsNullOrEmpty($setting)) { 50 } else { $setting }\r\n        ),\r\n        [Parameter()]\r\n        [PSCustomObject] $ScalingPlanTarget = $null,\r\n        [Parameter()]\r\n        [string] $GraphToken,\r\n        [Parameter()]\r\n        [bool] $RemoveEntraDevice = (Read-FunctionAppSetting RemoveEntraDevice -AsBoolean),\r\n        [Parameter()]\r\n        [bool] $RemoveIntuneDevice = (Read-FunctionAppSetting RemoveIntuneDevice -AsBoolean),\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n        [Parameter()]\r\n        [string] $HostPoolResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri)\r\n    )\r\n    \r\n    Write-LogEntry -Message \"We have $($SessionHosts.Count) session hosts (included in Automation)\"\r\n    \r\n    # Auto-detect target count if not specified (TargetSessionHostCount = 0)\r\n    if ($TargetSessionHostCount -eq 0) {\r\n        # Get deployment state to check for stored target\r\n        try {\r\n            $deploymentState = Get-DeploymentState -HostPoolName $HostPoolName\r\n            \r\n            if ($deploymentState.TargetSessionHostCount -gt 0) {\r\n                # Use previously stored target from ongoing replacement cycle\r\n                $TargetSessionHostCount = $deploymentState.TargetSessionHostCount\r\n                Write-LogEntry -Message \"Auto-detect mode: Using stored target count of $TargetSessionHostCount from current replacement cycle\"\r\n            } else {\r\n                # First run of a new replacement cycle - store current count as target\r\n                $TargetSessionHostCount = $SessionHosts.Count\r\n                $deploymentState.TargetSessionHostCount = $TargetSessionHostCount\r\n                Save-DeploymentState -DeploymentState $deploymentState -HostPoolName $HostPoolName\r\n                Write-LogEntry -Message \"Auto-detect mode: Detected $TargetSessionHostCount session hosts - storing as target for this replacement cycle\"\r\n            }\r\n        }\r\n        catch {\r\n            # If state storage fails, fall back to current count (stateless mode)\r\n            $TargetSessionHostCount = $SessionHosts.Count\r\n            Write-LogEntry -Message \"Auto-detect mode: Unable to access deployment state storage. Using current count of $TargetSessionHostCount. Note: Managed identity needs 'Storage Table Data Contributor' role on storage account for persistent target tracking. Error: $_\" -Level Warning\r\n        }\r\n    }\r\n    \r\n    # Determine which session hosts need replacement based on image version\r\n    [array] $sessionHostsOldVersion = @()\r\n    \r\n    $latestImageAge = (New-TimeSpan -Start $LatestImageVersion.Date -End (Get-Date -AsUTC)).TotalDays\r\n    Write-LogEntry -Message \"Latest Image $($LatestImageVersion.Version) is $latestImageAge days old.\"\r\n    if ($latestImageAge -ge $ReplaceSessionHostOnNewImageVersionDelayDays) {\r\n            Write-LogEntry -Message \"Latest Image age is older than (or equal) New Image Delay value $ReplaceSessionHostOnNewImageVersionDelayDays\"\r\n            \r\n            # Log each session host's image version for debugging\r\n            foreach ($sh in $sessionHosts) {\r\n                Write-LogEntry -Message \"Session host $($sh.SessionHostName) has image version: $($sh.ImageVersion)\" -Level Trace\r\n            }\r\n            \r\n            # Compare versions with rollback protection\r\n            [array] $sessionHostsOldVersion = @()\r\n            foreach ($sh in $sessionHosts) {\r\n                # Skip version comparison for hosts without image version (unavailable/deleted VMs)\r\n                if ([string]::IsNullOrEmpty($sh.ImageVersion)) {\r\n                    Write-LogEntry -Message \"Session host $($sh.SessionHostName) has no image version (likely unavailable) - skipping version comparison\" -Level Trace\r\n                    continue\r\n                }\r\n                \r\n                if ($sh.ImageVersion -ne $LatestImageVersion.Version) {\r\n                    # Check if image definition has changed\r\n                    $imageDefinitionChanged = $false\r\n                    if ($sh.ImageDefinition -and $LatestImageVersion.Definition) {\r\n                        $imageDefinitionChanged = ($sh.ImageDefinition -ne $LatestImageVersion.Definition)\r\n                        if ($imageDefinitionChanged) {\r\n                            Write-LogEntry -Message \"Session host $($sh.SessionHostName) has different image definition - VM: '$($sh.ImageDefinition)', Latest: '$($LatestImageVersion.Definition)'\" -Level Trace\r\n                        }\r\n                    }\r\n                    \r\n                    if ($imageDefinitionChanged) {\r\n                        # Image definition changed - this is a legitimate upgrade, not a rollback\r\n                        $sessionHostsOldVersion += $sh\r\n                    }\r\n                    else {\r\n                        # Same image definition, different version - check for rollback\r\n                        $versionComparison = Compare-ImageVersion -Version1 $sh.ImageVersion -Version2 $LatestImageVersion.Version\r\n                        \r\n                        if ($versionComparison -lt 0) {\r\n                            # VM version is older than latest - safe to replace\r\n                            $sessionHostsOldVersion += $sh\r\n                        }\r\n                        elseif ($versionComparison -gt 0) {\r\n                            # VM version is NEWER than \"latest\" - potential rollback scenario\r\n                            if ($AllowImageVersionRollback) {\r\n                                Write-LogEntry -Message \"Session host $($sh.SessionHostName) has NEWER version '$($sh.ImageVersion)' than latest '$($LatestImageVersion.Version)' - will replace (AllowImageVersionRollback=true)\" -Level Warning\r\n                                $sessionHostsOldVersion += $sh\r\n                            }\r\n                            else {\r\n                                Write-LogEntry -Message \"Session host $($sh.SessionHostName) has NEWER version '$($sh.ImageVersion)' than latest '$($LatestImageVersion.Version)' - skipping replacement (AllowImageVersionRollback=false)\" -Level Warning\r\n                            }\r\n                        }\r\n                        else {\r\n                            # Versions are functionally equal but string representation differs (shouldn't happen)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            Write-LogEntry -Message \"Found $($sessionHostsOldVersion.Count) session hosts to replace due to image version. $($($sessionHostsOldVersion.SessionHostName) -Join ',')\"\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"Latest Image age is less than New Image Delay value $ReplaceSessionHostOnNewImageVersionDelayDays - no session hosts will be replaced based on image version\"\r\n    }\r\n\r\n    # Detect and handle unavailable session hosts (VMs deleted but host pool registration remains)\r\n    $unavailableHosts = $SessionHosts | Where-Object { $_.IsUnavailable -eq $true }\r\n    if ($unavailableHosts.Count -gt 0) {\r\n        $unavailableHostNames = $unavailableHosts.SessionHostName -join ','\r\n        Write-LogEntry -Message \"CRITICAL: Detected $($unavailableHosts.Count) unavailable session hosts (VMs deleted): $unavailableHostNames\" -Level Error\r\n        Write-LogEntry -Message \"Cleaning up device records and host pool registrations before redeployment...\" -Level Warning\r\n        \r\n        # Clean up device records for each unavailable host\r\n        foreach ($unavailableHost in $unavailableHosts) {\r\n            # Remove from Entra ID and Intune if configured\r\n            if ($GraphToken -and ($RemoveEntraDevice -or $RemoveIntuneDevice)) {\r\n                try {\r\n                    Remove-DeviceFromDirectories `\r\n                        -DeviceName $unavailableHost.SessionHostName `\r\n                        -GraphToken $GraphToken `\r\n                        -RemoveEntraDevice $RemoveEntraDevice `\r\n                        -RemoveIntuneDevice $RemoveIntuneDevice\r\n                    Write-LogEntry -Message \"Cleaned up device records for ghost host: $($unavailableHost.SessionHostName)\" -Level Information\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"Failed to clean up device records for $($unavailableHost.SessionHostName): $($_.Exception.Message)\" -Level Warning\r\n                }\r\n            }\r\n            \r\n            # Remove stale host pool registration\r\n            try {\r\n                $hostPoolPath = \"/subscriptions/$HostPoolSubscriptionId/resourceGroups/$HostPoolResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName\"\r\n                $sessionHostPath = \"$hostPoolPath/sessionHosts/$($unavailableHost.FQDN)\"\r\n                $deleteUri = \"$ResourceManagerUri$sessionHostPath`?api-version=2024-04-03&force=true\"\r\n                \r\n                Invoke-AzureRestMethod -ARMToken $ARMToken -Method Delete -Uri $deleteUri | Out-Null\r\n                Write-LogEntry -Message \"Removed stale host pool registration: $($unavailableHost.FQDN)\" -Level Information\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Failed to remove host pool registration for $($unavailableHost.FQDN): $($_.Exception.Message)\" -Level Warning\r\n            }\r\n        }\r\n        \r\n        Write-LogEntry -Message \"Ghost host cleanup complete. These hosts will be excluded from deletion candidates and counted as needing replacement.\" -Level Warning\r\n    }\r\n    \r\n    [array] $sessionHostsToReplace = $sessionHostsOldVersion | Select-Object -Property * -Unique\r\n\r\n    # Good hosts = not needing replacement AND not shutdown (shutdown VMs are deallocated and unavailable) AND not unavailable (VM deleted)\r\n    $goodSessionHosts = $SessionHosts | Where-Object { \r\n        $_.SessionHostName -notin $sessionHostsToReplace.SessionHostName -and \r\n        -not $_.ShutdownTimestamp -and\r\n        -not $_.IsUnavailable\r\n    }\r\n    \r\n    # Count shutdown hosts for logging\r\n    $shutdownHostsCount = ($SessionHosts | Where-Object { $_.ShutdownTimestamp }).Count\r\n    if ($shutdownHostsCount -gt 0) {\r\n        $shutdownHostNames = ($SessionHosts | Where-Object { $_.ShutdownTimestamp }).SessionHostName -join ','\r\n        Write-LogEntry -Message \"Excluding $shutdownHostsCount shutdown session hosts from available capacity: $shutdownHostNames\" -Level Debug\r\n    }\r\n    \r\n    # Count running deployment VMs - handle both ARM deployments (with SessionHostNames) and state-tracked deployments (with VirtualCount)\r\n    $runningDeploymentVMCount = 0\r\n    $runningDeploymentVMNames = @()\r\n    foreach ($deployment in $runningDeployments) {\r\n        if ($deployment.SessionHostNames -and $deployment.SessionHostNames.Count -gt 0) {\r\n            $runningDeploymentVMCount += $deployment.SessionHostNames.Count\r\n            $runningDeploymentVMNames += $deployment.SessionHostNames\r\n        }\r\n        elseif ($deployment.VirtualCount) {\r\n            # Synthetic deployment from state - use virtual count\r\n            $runningDeploymentVMCount += $deployment.VirtualCount\r\n        }\r\n    }\r\n    \r\n    $sessionHostsCurrentTotal = ([array]$goodSessionHosts.SessionHostName + [array]$runningDeploymentVMNames) | Select-Object -Unique\r\n    Write-LogEntry -Message \"We have $($sessionHostsCurrentTotal.Count) good session hosts including $runningDeploymentVMCount session hosts being deployed\"\r\n    Write-LogEntry -Message \"We target having $TargetSessionHostCount session hosts in good shape\"\r\n    \r\n    # Check if there are any running or recently submitted deployments - if so, skip deployment and capacity calculations\r\n    if ($runningDeployments -and $runningDeployments.Count -gt 0) {\r\n        Write-LogEntry -Message \"Found $($runningDeployments.Count) running or recently submitted deployment(s). Will not submit new deployments until these complete.\" -Level Warning\r\n        $canDeploy = 0\r\n        # In DeleteFirst mode, deletions are aligned with deployments (1:1), so also skip deletion calculations\r\n        $canDelete = if ($ReplacementMode -eq 'DeleteFirst') { 0 } else { $SessionHosts.Count - $TargetSessionHostCount }\r\n    }\r\n    else {\r\n        # In DeleteFirst mode, calculate deployments based on what needs replacement (we'll delete first to make room)\r\n        # In SideBySide mode, calculate based on buffer space (pool can temporarily double)\r\n        if ($ReplacementMode -eq 'DeleteFirst') {\r\n            # DeleteFirst: We can deploy as many as we need since we delete first\r\n            # Note: Unavailable hosts are already excluded from $sessionHostsCurrentTotal, so they're \r\n            # automatically counted in the deficit calculation. No need to add them separately.\r\n            $weNeedToDeploy = $TargetSessionHostCount - $sessionHostsCurrentTotal.Count\r\n            \r\n            if ($weNeedToDeploy -gt 0) {\r\n                Write-LogEntry -Message \"We need to deploy $weNeedToDeploy new session hosts\"\r\n                $canDeploy = $weNeedToDeploy\r\n                Write-LogEntry -Message \"DeleteFirst mode allows deploying $canDeploy session hosts (will delete first to make room)\"\r\n            }\r\n            else {\r\n                $canDeploy = 0\r\n                Write-LogEntry -Message \"We have enough session hosts in good shape.\"\r\n            }\r\n        }\r\n        else {\r\n            # SideBySide: Use buffer to allow pool to double\r\n            # Note: Unavailable hosts are already excluded from $sessionHostsCurrentTotal.Count,\r\n            # so they will naturally be counted as needing replacement without special handling\r\n            $effectiveBuffer = $TargetSessionHostCount\r\n            Write-LogEntry -Message \"Automatic buffer: $effectiveBuffer session hosts (allows pool to double during rolling updates)\"\r\n            \r\n            $canDeployUpTo = $TargetSessionHostCount + $effectiveBuffer - $SessionHosts.count - $runningDeploymentVMCount\r\n            \r\n            if ($canDeployUpTo -ge 0) {\r\n                Write-LogEntry -Message \"We can deploy up to $canDeployUpTo session hosts\" \r\n                $weNeedToDeploy = $TargetSessionHostCount - $sessionHostsCurrentTotal.Count\r\n                \r\n                if ($weNeedToDeploy -gt 0) {\r\n                    Write-LogEntry -Message \"We need to deploy $weNeedToDeploy new session hosts\"\r\n                    $canDeploy = if ($weNeedToDeploy -gt $canDeployUpTo) { $canDeployUpTo } else { $weNeedToDeploy }\r\n                    Write-LogEntry -Message \"Buffer allows deploying $canDeploy session hosts\"\r\n                }\r\n                else {\r\n                    $canDeploy = 0\r\n                    Write-LogEntry -Message \"We have enough session hosts in good shape.\"\r\n                }\r\n            }\r\n            else {\r\n                Write-LogEntry -Message \"Buffer is full. We can not deploy more session hosts\"\r\n                $canDeploy = 0\r\n            }\r\n        }\r\n            \r\n        # Apply progressive scale-up to both modes (if enabled)\r\n        if ($EnableProgressiveScaleUp -and $canDeploy -gt 0) {\r\n            Write-LogEntry -Message \"Progressive scale-up is enabled\"\r\n            $deploymentState = Get-DeploymentState\r\n            $currentPercentage = $InitialDeploymentPercentage\r\n            \r\n            if ($deploymentState.ConsecutiveSuccesses -ge $SuccessfulRunsBeforeScaleUp) {\r\n                $scaleUpMultiplier = [Math]::Floor($deploymentState.ConsecutiveSuccesses / $SuccessfulRunsBeforeScaleUp)\r\n                $currentPercentage = $InitialDeploymentPercentage + ($scaleUpMultiplier * $ScaleUpIncrementPercentage)\r\n            }\r\n            \r\n            $currentPercentage = [Math]::Min($currentPercentage, 100)\r\n            $percentageBasedCount = [Math]::Ceiling($canDeploy * ($currentPercentage / 100.0))\r\n            $batchSizeLimit = if ($ReplacementMode -eq 'DeleteFirst') { $MaxDeletionsPerCycle } else { $MaxDeploymentBatchSize }\r\n            $actualDeployCount = [Math]::Min($percentageBasedCount, $batchSizeLimit)\r\n            $actualDeployCount = [Math]::Min($actualDeployCount, $canDeploy)\r\n            \r\n            Write-LogEntry -Message \"Progressive scale-up: Using $currentPercentage% of $canDeploy needed = $actualDeployCount hosts (ConsecutiveSuccesses: $($deploymentState.ConsecutiveSuccesses), Max: $batchSizeLimit)\"\r\n            $canDeploy = $actualDeployCount\r\n        }\r\n    }\r\n        \r\n    # Calculate deletion details (only if not already determined by running deployments check)\r\n    if (-not ($runningDeployments -and $runningDeployments.Count -gt 0)) {\r\n        if ($ReplacementMode -eq 'DeleteFirst') {\r\n            # DeleteFirst mode: Calculate deletions based on hosts that need replacing (not net-new)\r\n            # When growing the pool (e.g., 810), we deploy net-new + replacements, but only delete replacements\r\n            # Example: Current=8, Target=10, Need 1 replacement  Deploy 3 (1 replacement + 2 net-new), Delete 1 (only the old one)\r\n            \r\n            # Calculate how many hosts to delete (only replace existing hosts, not net-new ones)\r\n            $hostsToReplace = $sessionHostsToReplace.Count  # Hosts with old image or other issues\r\n            \r\n            # Only delete hosts that are being replaced, not the net-new ones\r\n            $canDelete = [Math]::Min($canDeploy, $hostsToReplace)\r\n            \r\n            # Determine effective minimum capacity percentage (dynamic from scaling plan or static from config)\r\n            $effectiveMinimumCapacityPct = $MinimumCapacityPercentage\r\n            $capacitySource = 'Static configuration'\r\n        \r\n        if ($ScalingPlanTarget -and $ScalingPlanTarget.CapacityPercentage) {\r\n            $scalingPlanPct = $ScalingPlanTarget.CapacityPercentage\r\n            $phase = $ScalingPlanTarget.Phase\r\n            \r\n            # Phase-aware capacity strategy:\r\n            # - RampUp/Peak: Use configured minimum as safety floor (users are active/arriving)\r\n            # - RampDown/OffPeak: Use scaling plan percentage directly (fewer users expected, safe to be more aggressive)\r\n            if ($phase -in @('RampUp', 'Peak')) {\r\n                # During active hours, maintain the configured minimum as a safety floor\r\n                $effectiveMinimumCapacityPct = [math]::Max($MinimumCapacityPercentage, $scalingPlanPct)\r\n                $capacitySource = \"Scaling plan ($($ScalingPlanTarget.ScalingPlanName), $phase phase) with configured minimum floor\"\r\n                Write-LogEntry -Message \"Peak/RampUp phase: Using configured minimum ($MinimumCapacityPercentage%) as floor. Scaling plan: $scalingPlanPct%, Effective: $effectiveMinimumCapacityPct%\"\r\n            }\r\n            else {\r\n                # During off-hours, trust the scaling plan's lower capacity targets\r\n                $effectiveMinimumCapacityPct = $scalingPlanPct\r\n                $capacitySource = \"Scaling plan ($($ScalingPlanTarget.ScalingPlanName), $phase phase)\"\r\n                Write-LogEntry -Message \"RampDown/OffPeak phase: Using scaling plan target directly. Effective capacity: $effectiveMinimumCapacityPct%\"\r\n            }\r\n            \r\n            Write-LogEntry -Message \"Dynamic capacity from scaling plan (Schedule: $($ScalingPlanTarget.ScheduleName), Phase: $phase): $scalingPlanPct% -> effective: $effectiveMinimumCapacityPct%\"\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Using static minimum capacity from configuration: $effectiveMinimumCapacityPct%\"\r\n        }\r\n        \r\n        # Safety floor: Ensure that after deletion, we maintain minimum capacity relative to target\r\n        # The minimum is calculated as a percentage of the TARGET pool size\r\n        # After deletion, remaining hosts must meet: RemainingTotal >= Ceiling(Target * MinPct)\r\n        \r\n        # Count hosts by drain status\r\n        $availableHostsCount = ($SessionHosts | Where-Object { $_.AllowNewSession }).Count\r\n        $drainingHostsCount = ($SessionHosts | Where-Object { -not $_.AllowNewSession }).Count\r\n        $totalHostsCount = $SessionHosts.Count\r\n        \r\n        # Calculate minimum required hosts based on target (starting pool size)\r\n        $minimumAbsoluteHosts = [Math]::Ceiling($TargetSessionHostCount * ($effectiveMinimumCapacityPct / 100.0))\r\n        \r\n        if ($drainingHostsCount -gt 0) {\r\n            Write-LogEntry -Message \"DeleteFirst mode: $drainingHostsCount host(s) currently draining (not accepting new sessions), $availableHostsCount available, $totalHostsCount total\" -Level Trace\r\n        }\r\n        \r\n        # Calculate max safe deletions:\r\n        # After deletion: (TotalHosts - N) will remain\r\n        # Requirement: (TotalHosts - N) >= MinimumAbsoluteHosts\r\n        # Therefore: N <= TotalHosts - MinimumAbsoluteHosts\r\n        $maxSafeDeletions = $totalHostsCount - $minimumAbsoluteHosts\r\n        \r\n        if ($canDelete -gt $maxSafeDeletions) {\r\n            Write-LogEntry -Message \"DeleteFirst mode: Safety floor triggered - limiting deletions from $canDelete to $maxSafeDeletions to maintain minimum $effectiveMinimumCapacityPct% capacity (need $minimumAbsoluteHosts hosts, currently $totalHostsCount total, after deletion would have $($totalHostsCount - $canDelete)) [Source: $capacitySource]\" -Level Warning\r\n            $canDelete = $maxSafeDeletions\r\n        }\r\n        \r\n        # Emergency brake: Respect the MaxDeletionsPerCycle limit\r\n        if ($canDelete -gt $MaxDeletionsPerCycle) {\r\n            Write-LogEntry -Message \"DeleteFirst mode: MaxDeletionsPerCycle limit triggered - capping deletions from $canDelete to $MaxDeletionsPerCycle\"\r\n            $canDelete = $MaxDeletionsPerCycle\r\n        }\r\n        \r\n        $canDelete = [Math]::Max($canDelete, 0)  # Ensure non-negative\r\n        \r\n        Write-LogEntry -Message \"Delete-First mode: Will delete $canDelete hosts (aligned with $canDeploy deployments, available capacity: $availableHostsCount, minimum: $minimumAbsoluteHosts at $effectiveMinimumCapacityPct%, draining: $drainingHostsCount, max per cycle: $MaxDeletionsPerCycle) [Capacity source: $capacitySource]\"\r\n        }\r\n        else {\r\n            # SideBySide mode: Only delete when overpopulated (more hosts than target)\r\n            $canDelete = $SessionHosts.Count - $TargetSessionHostCount\r\n        }\r\n    }\r\n    \r\n    if ($canDelete -gt 0) {\r\n        Write-LogEntry -Message \"We need to delete $canDelete session hosts\"\r\n        if ($canDelete -gt $sessionHostsToReplace.Count) {\r\n            Write-LogEntry -Message \"Host pool is over populated\"\r\n            $goodSessionHostsToDeleteCount = $canDelete - $sessionHostsToReplace.Count\r\n            Write-LogEntry -Message \"We will delete $goodSessionHostsToDeleteCount good session hosts\"\r\n            \r\n            # Lazy load power states for good hosts being considered for deletion\r\n            $goodHostResourceIds = $goodSessionHosts | ForEach-Object { $_.ResourceId }\r\n            $powerStates = Get-VMPowerStates -ARMToken $ARMToken -VMResourceIds $goodHostResourceIds\r\n            \r\n            # Enrich good hosts with power state\r\n            foreach ($sh in $goodSessionHosts) {\r\n                $sh | Add-Member -NotePropertyName PoweredOff -NotePropertyValue $powerStates[$sh.ResourceId] -Force\r\n            }\r\n            \r\n            # Sort by power state (prioritize powered-off VMs), then session count (idle hosts), then drain status, then name\r\n            $selectedGoodHostsTotDelete = [array] ($goodSessionHosts | Sort-Object -Property @{Expression={-not $_.PoweredOff}; Ascending=$true}, @{Expression={$_.Sessions}; Ascending=$true}, @{Expression={$_.AllowNewSession}; Ascending=$true}, SessionHostName | Select-Object -First $goodSessionHostsToDeleteCount)\r\n            Write-LogEntry -Message \"Selected the following good session hosts to delete: $($($selectedGoodHostsTotDelete.VMName) -join ',')\"\r\n        }\r\n        else {\r\n            $selectedGoodHostsTotDelete = @()\r\n            Write-LogEntry -Message \"Host pool is not over populated\"\r\n        }\r\n        \r\n        # Lazy load power states for hosts to replace being considered for deletion\r\n        # Filter out unavailable hosts (already deleted) before querying power state\r\n        $sessionHostsAvailableForReplace = $sessionHostsToReplace | Where-Object { \r\n            -not $_.IsUnavailable\r\n        }\r\n        \r\n        if ($sessionHostsAvailableForReplace.Count -lt $sessionHostsToReplace.Count) {\r\n            $unavailableCount = $sessionHostsToReplace.Count - $sessionHostsAvailableForReplace.Count\r\n            Write-LogEntry -Message \"Filtered out $unavailableCount unavailable host(s) from deletion candidates (VMs already deleted)\" -Level Warning\r\n        }\r\n        \r\n        $replaceHostResourceIds = $sessionHostsAvailableForReplace | ForEach-Object { $_.ResourceId }\r\n        Write-LogEntry -Message \"Querying power state for $($replaceHostResourceIds.Count) replacement candidate(s): $($sessionHostsAvailableForReplace.VMName -join ',')\"\r\n        $powerStates = Get-VMPowerStates -ARMToken $ARMToken -VMResourceIds $replaceHostResourceIds\r\n        \r\n        # Enrich hosts to replace with power state\r\n        foreach ($sh in $sessionHostsAvailableForReplace) {\r\n            $sh | Add-Member -NotePropertyName PoweredOff -NotePropertyValue $powerStates[$sh.ResourceId] -Force\r\n        }\r\n        \r\n        # Log power state results for visibility\r\n        $poweredOffHosts = $sessionHostsAvailableForReplace | Where-Object { $_.PoweredOff }\r\n        if ($poweredOffHosts) {\r\n            Write-LogEntry -Message \"Found $($poweredOffHosts.Count) powered-off host(s) among replacement candidates: $($poweredOffHosts.VMName -join ',')\"\r\n        }\r\n        \r\n        # Prioritize hosts for deletion: powered-off first, then idle, then draining, then fewest sessions\r\n        # This ensures VMs that are already powered off are replaced before active ones\r\n        $sortedHostsToReplace = $sessionHostsAvailableForReplace | Sort-Object -Property @{Expression={-not $_.PoweredOff}; Ascending=$true}, @{Expression={$_.Sessions}; Ascending=$true}, @{Expression={$_.AllowNewSession}; Ascending=$true}, SessionHostName\r\n        $sessionHostsPendingDelete = (@($sortedHostsToReplace) + @($selectedGoodHostsTotDelete)) | Select-Object -First $canDelete\r\n        \r\n        # In SideBySide mode, apply progressive scale-up to deletions\r\n        # In DeleteFirst mode, skip this - deletions are already controlled by deployment progressive scale-up (they're aligned 1:1)\r\n        if ($ReplacementMode -ne 'DeleteFirst' -and $EnableProgressiveScaleUp -and $sessionHostsPendingDelete.Count -gt 0) {\r\n            Write-LogEntry -Message \"Progressive scale-up is enabled for deletions\"\r\n            $deploymentState = Get-DeploymentState\r\n            $currentPercentage = $InitialDeploymentPercentage\r\n            \r\n            if ($deploymentState.ConsecutiveSuccesses -ge $SuccessfulRunsBeforeScaleUp) {\r\n                $scaleUpMultiplier = [Math]::Floor($deploymentState.ConsecutiveSuccesses / $SuccessfulRunsBeforeScaleUp)\r\n                $currentPercentage = $InitialDeploymentPercentage + ($scaleUpMultiplier * $ScaleUpIncrementPercentage)\r\n            }\r\n            \r\n            $currentPercentage = [Math]::Min($currentPercentage, 100)\r\n            $percentageBasedCount = [Math]::Ceiling($sessionHostsPendingDelete.Count * ($currentPercentage / 100.0))\r\n            $batchSizeLimit = $MaxDeploymentBatchSize\r\n            $actualDeleteCount = [Math]::Min($percentageBasedCount, $batchSizeLimit)\r\n            $actualDeleteCount = [Math]::Min($actualDeleteCount, $sessionHostsPendingDelete.Count)\r\n            \r\n            Write-LogEntry -Message \"Progressive scale-up for deletions: Using $currentPercentage% of $($sessionHostsPendingDelete.Count) pending = $actualDeleteCount hosts (ConsecutiveSuccesses: $($deploymentState.ConsecutiveSuccesses), Max: $batchSizeLimit)\"\r\n            $sessionHostsPendingDelete = $sessionHostsPendingDelete | Select-Object -First $actualDeleteCount\r\n        }\r\n        \r\n        Write-LogEntry -Message \"The following Session Hosts are now pending delete: $($($SessionHostsPendingDelete.SessionHostName) -join ',')\"\r\n    }\r\n    elseif ($sessionHostsToReplace.Count -gt 0) {\r\n        Write-LogEntry -Message \"We need to delete $($sessionHostsToReplace.Count) session hosts but we don't have enough session hosts in the host pool.\"\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"We do not need to delete any session hosts\"\r\n    }\r\n    \r\n    # Auto-detect mode: Clear stored target when replacement cycle is complete\r\n    $configuredTarget = Read-FunctionAppSetting TargetSessionHostCount\r\n    if ($configuredTarget -eq 0 -and $sessionHostsToReplace.Count -eq 0 -and $sessionHostsPendingDelete.Count -eq 0) {\r\n        # All hosts are up to date and nothing pending - clear stored target for next cycle\r\n        try {\r\n            $deploymentState = Get-DeploymentState -HostPoolName $HostPoolName\r\n            if ($deploymentState.TargetSessionHostCount -gt 0) {\r\n                Write-LogEntry -Message \"Auto-detect mode: All session hosts are up to date - clearing stored target count for next replacement cycle\"\r\n                $deploymentState.TargetSessionHostCount = 0\r\n                Save-DeploymentState -DeploymentState $deploymentState -HostPoolName $HostPoolName\r\n            }\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Auto-detect mode: Unable to clear stored target count - will retry on next run. Error: $_\" -Level Warning\r\n        }\r\n    }\r\n\r\n    return [PSCustomObject]@{\r\n        PossibleDeploymentsCount       = $canDeploy\r\n        PossibleSessionHostDeleteCount = $canDelete\r\n        SessionHostsPendingDelete      = $sessionHostsPendingDelete\r\n        ExistingSessionHostNames       = ([array]$SessionHosts.SessionHostName + [array]$runningDeploymentVMNames) | Select-Object -Unique\r\n        TargetSessionHostCount         = $TargetSessionHostCount\r\n        TotalSessionHostsToReplace     = $sessionHostsToReplace.Count\r\n    }\r\n}\r\n\r\nfunction Get-SessionHosts {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        [Parameter()]\r\n        [array] $CachedVMs,\r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n        [Parameter()]\r\n        [string] $HostPoolSubscriptionId = (Read-FunctionAppSetting HostPoolSubscriptionId),\r\n        [Parameter()]\r\n        [string] $ResourceGroupName = (Read-FunctionAppSetting HostPoolResourceGroupName),\r\n        [Parameter()]\r\n        [string] $HostPoolName = (Read-FunctionAppSetting HostPoolName),\r\n        [Parameter()]\r\n        [string] $TagIncludeInAutomation = (Read-FunctionAppSetting Tag_IncludeInAutomation),\r\n        [Parameter()]\r\n        [string] $TagDeployTimestamp = (Read-FunctionAppSetting Tag_DeployTimestamp),\r\n        [Parameter()]\r\n        [string] $TagPendingDrainTimeStamp = (Read-FunctionAppSetting Tag_PendingDrainTimestamp),\r\n        [Parameter()]\r\n        [string] $TagShutdownTimestamp = (Read-FunctionAppSetting Tag_ShutdownTimestamp),\r\n        [Parameter()]\r\n        [string] $TagScalingPlanExclusionTag = (Read-FunctionAppSetting Tag_ScalingPlanExclusionTag),\r\n        [Parameter()]\r\n        [switch] $FixSessionHostTags = (Read-FunctionAppSetting FixSessionHostTags -AsBoolean),\r\n        [Parameter()]\r\n        [bool] $IncludePreExistingSessionHosts = (Read-FunctionAppSetting IncludePreExistingSessionHosts -AsBoolean)\r\n    )\r\n    \r\n    Write-LogEntry -Message \"Getting current session hosts in host pool $HostPoolName\"\r\n    $Uri = \"$ResourceManagerUri/subscriptions/$HostPoolSubscriptionId/resourceGroups/$ResourceGroupName/providers/Microsoft.DesktopVirtualization/hostPools/$HostPoolName/sessionHosts?api-version=2024-04-03\"\r\n    $sessionHostsResponse = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n    \r\n    # Extract properties from nested structure\r\n    $sessionHosts = $sessionHostsResponse | ForEach-Object {\r\n        [PSCustomObject]@{\r\n            Name            = $_.name\r\n            ResourceId      = $_.properties.resourceId\r\n            Sessions        = $_.properties.sessions\r\n            AllowNewSession = $_.properties.allowNewSession\r\n            Status          = $_.properties.status\r\n        }\r\n    }\r\n    \r\n    $result = foreach ($sh in $sessionHosts) {\r\n        # Look up VM from cache by resource ID\r\n        $vmResponse = $null\r\n        if ($CachedVMs -and $CachedVMs.Count -gt 0) {\r\n            $vmResponse = $CachedVMs | Where-Object { $_.id -eq $sh.ResourceId } | Select-Object -First 1\r\n            if ($vmResponse) {\r\n                Write-LogEntry -Message \"Using cached VM data for $($sh.Name)\" -Level Trace\r\n            }\r\n        }\r\n        \r\n        # Fall back to individual query if not in cache (without instanceView - we'll get power state lazily if needed)\r\n        if (-not $vmResponse) {\r\n            Write-LogEntry -Message \"VM not found in cache, querying individually: $($sh.ResourceId)\" -Level Trace\r\n            $Uri = \"$ResourceManagerUri$($sh.ResourceId)?api-version=2024-07-01\"\r\n            try {\r\n                $vmResponse = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $Uri\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"Failed to query VM $($sh.ResourceId): $($_.Exception.Message). VM may have been deleted.\" -Level Warning\r\n                $vmResponse = $null\r\n            }\r\n        }\r\n        \r\n        # Check if VM exists (will be null if deleted but host pool registration remains)\r\n        if (-not $vmResponse) {\r\n            # Ghost host - registered in host pool but VM deleted\r\n            $fqdn = $sh.Name -replace \".+\\/(.+)\", '$1'\r\n            $sessionHostName = $fqdn -replace '\\..*$', ''\r\n            Write-LogEntry -Message \"Detected unavailable session host (VM deleted): $sessionHostName (Status=$($sh.Status))\" -Level Warning\r\n            \r\n            # Return minimal object marking this as unavailable\r\n            [PSCustomObject]@{\r\n                VMName              = $null\r\n                SessionHostName     = $sessionHostName\r\n                FQDN                = $fqdn\r\n                DeployTimestamp     = $null\r\n                IncludeInAutomation = $true\r\n                PendingDrainTimeStamp = $null\r\n                ShutdownTimestamp   = $null\r\n                ImageVersion        = $null\r\n                ImageDefinition     = $null\r\n                Tags                = @{}\r\n                HostId              = $null\r\n                HostGroupId         = $null\r\n                Zones               = $null\r\n                Name                = $sh.Name\r\n                ResourceId          = $sh.ResourceId\r\n                Sessions            = $sh.Sessions\r\n                AllowNewSession     = $sh.AllowNewSession\r\n                Status              = $sh.Status\r\n                IsUnavailable       = $true\r\n            }\r\n            continue\r\n        }\r\n        \r\n        # Extract properties from nested structure\r\n        $vm = [PSCustomObject]@{\r\n            Name           = $vmResponse.name\r\n            TimeCreated    = $vmResponse.properties.timeCreated\r\n            StorageProfile = $vmResponse.properties.storageProfile\r\n            HostId         = $vmResponse.properties.host.id\r\n            HostGroupId    = $vmResponse.properties.hostGroup.id\r\n            Zones          = $vmResponse.zones\r\n        }\r\n        \r\n        # Extract image version and definition - handle both ExactVersion (specific version) and id (image definition reference)\r\n        $vmImageVersion = $null\r\n        $vmImageDefinition = $null\r\n        \r\n        if ($vm.StorageProfile.ImageReference.id) {\r\n            # Gallery image reference (either specific version or definition for \"latest\")\r\n            $imageRef = $vm.StorageProfile.ImageReference.id\r\n            \r\n            # Extract the image definition path (without version)\r\n            if ($imageRef -match '^(?<definition>.+)/versions/[^/]+$') {\r\n                $vmImageDefinition = $Matches['definition']\r\n            }\r\n            elseif ($imageRef -match '^(?<definition>/subscriptions/.+/images/[^/]+)$') {\r\n                $vmImageDefinition = $Matches['definition']\r\n            }\r\n            \r\n            # Get version - prefer ExactVersion if available, otherwise extract from id\r\n            if ($vm.StorageProfile.ImageReference.ExactVersion) {\r\n                $vmImageVersion = $vm.StorageProfile.ImageReference.ExactVersion\r\n            }\r\n            elseif ($imageRef -match '/versions/(?<version>[^/]+)$') {\r\n                $vmImageVersion = $Matches['version']\r\n            }\r\n        }\r\n        elseif ($vm.StorageProfile.ImageReference.publisher) {\r\n            # Marketplace image\r\n            $vmImageVersion = $vm.StorageProfile.ImageReference.version\r\n            $vmImageDefinition = \"marketplace:$($vm.StorageProfile.ImageReference.publisher)/$($vm.StorageProfile.ImageReference.offer)/$($vm.StorageProfile.ImageReference.sku)\"\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Unable to determine VM image version from StorageProfile\" -Level Warning\r\n        }\r\n        \r\n        # Power state will be queried lazily only for deletion candidates to optimize performance\r\n        # This avoids querying instanceView for all VMs when most are not being considered for deletion\r\n        \r\n        # Extract tags directly from VM response (no separate API call needed)\r\n        $vmTags = @{}\r\n        if ($vmResponse.tags) {\r\n            $vmResponse.tags.PSObject.Properties | ForEach-Object {\r\n                $vmTags[$_.Name] = $_.Value\r\n            }\r\n        }\r\n        \r\n        $vmDeployTimeStamp = $vmTags[$TagDeployTimestamp]\r\n        \r\n        try {\r\n            $vmDeployTimeStamp = [DateTime]::Parse($vmDeployTimeStamp)\r\n        }\r\n        catch {\r\n            $value = if ($null -eq $vmDeployTimeStamp) { 'null' } else { $vmDeployTimeStamp }\r\n            Write-LogEntry -Message \"VM tag $TagDeployTimestamp with value $value is not a valid date\" -Level Trace\r\n            if ($FixSessionHostTags) {\r\n                $tagsUri = \"$ResourceManagerUri$($sh.ResourceId)/providers/Microsoft.Resources/tags/default?api-version=2021-04-01\"\r\n                $Body = @{\r\n                    properties = @{\r\n                        tags = @{ $TagDeployTimestamp = $vm.TimeCreated.ToString('o') }\r\n                    }\r\n                    operation  = 'Merge'\r\n                }\r\n                Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 10) -Method PATCH -Uri $tagsUri | Out-Null\r\n            }\r\n            $vmDeployTimeStamp = $vm.TimeCreated\r\n        }\r\n        \r\n        $vmIncludeInAutomation = $vmTags[$TagIncludeInAutomation]\r\n        if ($vmIncludeInAutomation -eq \"True\") {\r\n            $vmIncludeInAutomation = $true\r\n        }\r\n        elseif ($vmIncludeInAutomation -eq \"False\") {\r\n            $vmIncludeInAutomation = $false\r\n        }\r\n        else {\r\n            $value = if ($null -eq $vmIncludeInAutomation) { 'null' } else { $vmIncludeInAutomation }\r\n            Write-LogEntry -Message \"VM tag with $TagIncludeInAutomation value $value is not set to True/False\" -Level Trace\r\n            if ($FixSessionHostTags) {\r\n                $tagsUri = \"$ResourceManagerUri$($sh.ResourceId)/providers/Microsoft.Resources/tags/default?api-version=2021-04-01\"\r\n                $Body = @{\r\n                    properties = @{\r\n                        tags = @{ $TagIncludeInAutomation = $IncludePreExistingSessionHosts }\r\n                    }\r\n                    operation  = 'Merge'\r\n                }\r\n                $null = Invoke-AzureRestMethod -ARMToken $ARMToken -Body ($Body | ConvertTo-Json -Depth 10) -Method PATCH -Uri $tagsUri\r\n            }\r\n            $vmIncludeInAutomation = $IncludePreExistingSessionHosts\r\n        }\r\n        \r\n        # Note: Scaling exclusion tag is automatically set during VM deployment (Deploy-SessionHosts)\r\n        # No need to backfill here - only newly deployed VMs should have the tag\r\n        # Tag will be removed when replacement cycle completes or after successful registration\r\n        \r\n        # Get drain timestamp tag\r\n        $vmPendingDrainTimeStamp = $vmTags[$TagPendingDrainTimeStamp]\r\n        if ($null -ne $vmPendingDrainTimeStamp) {\r\n            try {\r\n                # Parse as UTC time regardless of timezone indicator\r\n                $vmPendingDrainTimeStamp = [DateTime]::Parse($vmPendingDrainTimeStamp, $null, [System.Globalization.DateTimeStyles]::AssumeUniversal -bor [System.Globalization.DateTimeStyles]::AdjustToUniversal)\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"VM tag $TagPendingDrainTimeStamp could not be parsed: '$vmPendingDrainTimeStamp'\" -Level Warning\r\n                $vmPendingDrainTimeStamp = $null\r\n            }\r\n        }\r\n        \r\n        # Get shutdown timestamp tag (for shutdown retention feature)\r\n        $vmShutdownTimestamp = $vmTags[$TagShutdownTimestamp]\r\n        if ($null -ne $vmShutdownTimestamp) {\r\n            try {\r\n                # Parse as UTC time regardless of timezone indicator\r\n                $vmShutdownTimestamp = [DateTime]::Parse($vmShutdownTimestamp, $null, [System.Globalization.DateTimeStyles]::AssumeUniversal -bor [System.Globalization.DateTimeStyles]::AdjustToUniversal)\r\n            }\r\n            catch {\r\n                Write-LogEntry -Message \"VM tag $TagShutdownTimestamp could not be parsed: '$vmShutdownTimestamp'\" -Level Warning\r\n                $vmShutdownTimestamp = $null\r\n            }\r\n        }\r\n\r\n        $fqdn = $sh.Name -replace \".+\\/(.+)\", '$1'\r\n        $sessionHostName = $fqdn -replace '\\..*$', ''\r\n        \r\n        $hostOutput = @{\r\n            VMName                = $vm.Name\r\n            SessionHostName       = $sessionHostName\r\n            FQDN                  = $fqdn\r\n            DeployTimestamp       = $vmDeployTimeStamp\r\n            IncludeInAutomation   = $vmIncludeInAutomation\r\n            PendingDrainTimeStamp = $vmPendingDrainTimeStamp\r\n            ShutdownTimestamp     = $vmShutdownTimestamp\r\n            ImageVersion          = $vmImageVersion\r\n            ImageDefinition       = $vmImageDefinition\r\n            Tags                  = $vmTags\r\n            HostId                = $vm.HostId\r\n            HostGroupId           = $vm.HostGroupId\r\n            Zones                 = $vm.Zones\r\n        }\r\n        $sh.PSObject.Properties.ForEach{ $hostOutput[$_.Name] = $_.Value }\r\n        [PSCustomObject]$hostOutput\r\n    }\r\n    return $result\r\n}\r\n\r\n#EndRegion Session Host Planning\r\n\r\n# Export functions\r\nExport-ModuleMember -Function Get-SessionHostReplacementPlan, Get-SessionHosts, Get-ScalingPlanCurrentTarget\r\n",
    "$fxv#9": "# SessionHostReplacer Device Cleanup Module\r\n# Contains Entra ID and Intune device removal functions\r\n\r\n# Import Core utilities\r\nImport-Module \"$PSScriptRoot\\SessionHostReplacer.Core.psm1\" -Force\r\n\r\n#Region Device Cleanup\r\n\r\nfunction Remove-DeviceFromDirectories {\r\n    <#\r\n    .SYNOPSIS\r\n    Removes a device from Entra ID and/or Intune based on configuration.\r\n    \r\n    .DESCRIPTION\r\n    Helper function to handle device cleanup from identity directories.\r\n    Called by both Remove-SessionHosts and Remove-ExpiredShutdownVMs.\r\n    \r\n    .PARAMETER DeviceName\r\n    The name of the device to remove\r\n    \r\n    .PARAMETER GraphToken\r\n    Graph access token for API calls\r\n    \r\n    .PARAMETER RemoveEntraDevice\r\n    Whether to remove from Entra ID\r\n    \r\n    .PARAMETER RemoveIntuneDevice\r\n    Whether to remove from Intune\r\n    \r\n    .PARAMETER ClientId\r\n    Client ID for Graph API calls\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $DeviceName,\r\n        [Parameter()]\r\n        [string] $GraphToken,\r\n        [Parameter()]\r\n        [bool] $RemoveEntraDevice = (Read-FunctionAppSetting RemoveEntraDevice -AsBoolean),\r\n        [Parameter()]\r\n        [bool] $RemoveIntuneDevice = (Read-FunctionAppSetting RemoveIntuneDevice -AsBoolean),\r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    if (-not $GraphToken) {\r\n        Write-LogEntry -Message \"No Graph token provided - skipping device cleanup for $DeviceName\" -Level Trace\r\n        return\r\n    }\r\n    \r\n    if ($RemoveEntraDevice) {\r\n        Write-LogEntry -Message \"Deleting $DeviceName from Entra ID\" -Level Trace\r\n        try {\r\n            Remove-EntraDevice -GraphToken $GraphToken -Name $DeviceName -ClientId $ClientId\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to remove $DeviceName from Entra ID: $($_.Exception.Message)\" -Level Warning\r\n        }\r\n    }\r\n    \r\n    if ($RemoveIntuneDevice) {\r\n        Write-LogEntry -Message \"Deleting $DeviceName from Intune\" -Level Trace\r\n        try {\r\n            Remove-IntuneDevice -GraphToken $GraphToken -Name $DeviceName -ClientId $ClientId\r\n        }\r\n        catch {\r\n            Write-LogEntry -Message \"Failed to remove $DeviceName from Intune: $($_.Exception.Message)\" -Level Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Remove-EntraDevice {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string] $GraphEndpoint = (Get-GraphEndpoint),\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        $GraphToken,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [string] $Name,\r\n        \r\n        [Parameter(Mandatory = $false)]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    try {\r\n        $Device = Invoke-GraphApiWithRetry `\r\n            -GraphEndpoint $GraphEndpoint `\r\n            -GraphToken $GraphToken `\r\n            -Method Get `\r\n            -Uri \"/v1.0/devices?`$filter=displayName eq '$Name'\" `\r\n            -ClientId $ClientId\r\n        \r\n        If ($Device.value -and $Device.value.Count -gt 0) {\r\n            $Id = $Device.value[0].id\r\n            Write-LogEntry -Message \"Removing session host $Name from Entra ID\"\r\n            Write-LogEntry -Message \"Device ID: $Id\" -Level Trace\r\n            \r\n            Invoke-GraphApiWithRetry `\r\n                -GraphEndpoint $GraphEndpoint `\r\n                -GraphToken $GraphToken `\r\n                -Method Delete `\r\n                -Uri \"/v1.0/devices/$Id\" `\r\n                -ClientId $ClientId\r\n            \r\n            Write-LogEntry -Message \"Successfully removed device $Name from Entra ID\"\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Device $Name not found in Entra ID\"\r\n        }\r\n    }\r\n    catch {\r\n        # Check if error is 404 (device already deleted)\r\n        $is404 = $_.Exception.Response.StatusCode.value__ -eq 404\r\n        if ($is404) {\r\n            Write-LogEntry -Message \"Device $Name not found in Entra ID (404)\"\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Failed to remove Entra device $Name : $($_.Exception.Message)\" -Level Error\r\n            throw\r\n        }\r\n    }\r\n}\r\n\r\nfunction Remove-IntuneDevice {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory = $false)]\r\n        [string] $GraphEndpoint = (Get-GraphEndpoint),\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        $GraphToken,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $Name,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    try {\r\n        $Device = Invoke-GraphApiWithRetry `\r\n            -GraphEndpoint $GraphEndpoint `\r\n            -GraphToken $GraphToken `\r\n            -Method Get `\r\n            -Uri \"/v1.0/deviceManagement/managedDevices?`$filter=deviceName eq '$Name'\" `\r\n            -ClientId $ClientId\r\n        \r\n        If ($Device.value -and $Device.value.Count -gt 0) {\r\n            $Id = $Device.value[0].id\r\n            Write-LogEntry -Message \"Removing session host '$Name' device from Intune\"\r\n            Write-LogEntry -Message \"Device ID: $Id\" -Level Trace\r\n            \r\n            Invoke-GraphApiWithRetry `\r\n                -GraphEndpoint $GraphEndpoint `\r\n                -GraphToken $GraphToken `\r\n                -Method Delete `\r\n                -Uri \"/v1.0/deviceManagement/managedDevices/$Id\" `\r\n                -ClientId $ClientId\r\n            \r\n            Write-LogEntry -Message \"Successfully removed device $Name from Intune\"\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Device $Name not found in Intune\"\r\n        }\r\n    }\r\n    catch {\r\n        # Check if error is 404 (device not enrolled or already deleted)\r\n        $is404 = $_.Exception.Response.StatusCode.value__ -eq 404\r\n        if ($is404) {\r\n            Write-LogEntry -Message \"Device $Name not found in Intune (404)\"\r\n        }\r\n        else {\r\n            Write-LogEntry -Message \"Failed to remove Intune device $Name : $($_.Exception.Message)\" -Level Error\r\n            throw\r\n        }\r\n    }\r\n}\r\n\r\nfunction Confirm-SessionHostDeletions {\r\n    <#\r\n    .SYNOPSIS\r\n    Validates complete deletion of session hosts across VM, Entra ID, and Intune.\r\n    \r\n    .DESCRIPTION\r\n    Polls Azure to confirm VM deletion, then verifies Graph cleanup for Entra ID and Intune devices.\r\n    Provides per-host validation status and comprehensive summary logging.\r\n    \r\n    .PARAMETER ARMToken\r\n    ARM access token for Azure Resource Manager API calls\r\n    \r\n    .PARAMETER GraphToken\r\n    Graph access token for Entra ID and Intune API calls\r\n    \r\n    .PARAMETER DeletedHostNames\r\n    Array of session host names that were successfully deleted\r\n    \r\n    .PARAMETER SessionHosts\r\n    Array of session host objects (to get resource IDs)\r\n    \r\n    .PARAMETER MaxWaitMinutes\r\n    Maximum time to wait for VM deletion confirmation (default: 5)\r\n    \r\n    .PARAMETER PollIntervalSeconds\r\n    Seconds between polling attempts (default: 30)\r\n    \r\n    .PARAMETER RemoveEntraDevice\r\n    Whether Entra ID device deletion was performed (only validate if true)\r\n    \r\n    .PARAMETER RemoveIntuneDevice\r\n    Whether Intune device deletion was performed (only validate if true)\r\n    \r\n    .OUTPUTS\r\n    PSCustomObject with validation results including VM, Entra ID, and Intune confirmation counts\r\n    #>\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string] $ARMToken,\r\n        \r\n        [Parameter()]\r\n        [string] $GraphToken,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [array] $DeletedHostNames,\r\n        \r\n        [Parameter(Mandatory = $true)]\r\n        [array] $SessionHosts,\r\n        \r\n        [Parameter()]\r\n        [int] $MaxWaitMinutes = 10,\r\n        \r\n        [Parameter()]\r\n        [int] $PollIntervalSeconds = 30,\r\n        \r\n        [Parameter()]\r\n        [bool] $RemoveEntraDevice = (Read-FunctionAppSetting RemoveEntraDevice -AsBoolean),\r\n        \r\n        [Parameter()]\r\n        [bool] $RemoveIntuneDevice = (Read-FunctionAppSetting RemoveIntuneDevice -AsBoolean),\r\n        \r\n        [Parameter()]\r\n        [string] $ResourceManagerUri = (Get-ResourceManagerUri),\r\n        \r\n        [Parameter()]\r\n        [string] $ClientId = (Read-FunctionAppSetting UserAssignedIdentityClientId)\r\n    )\r\n    \r\n    if ($DeletedHostNames.Count -eq 0) {\r\n        Write-LogEntry -Message \"No hosts to verify - skipping validation\" -Level Trace\r\n        return [PSCustomObject]@{\r\n            TotalHosts       = 0\r\n            VMsConfirmed     = 0\r\n            EntraIDConfirmed = 0\r\n            IntuneConfirmed  = 0\r\n            IncompleteHosts  = @()\r\n        }\r\n    }\r\n    \r\n    Write-LogEntry -Message \"Verifying complete deletion for {0} host(s) (VM, Entra ID, Intune)...\" -StringValues $DeletedHostNames.Count\r\n    \r\n    $startTime = Get-Date\r\n    $timeoutTime = $startTime.AddMinutes($MaxWaitMinutes)\r\n    \r\n    # Build validation tracking for each deleted host\r\n    $hostsToVerify = @()\r\n    foreach ($deletedName in $DeletedHostNames) {\r\n        $sessionHost = $SessionHosts | Where-Object { $_.SessionHostName -eq $deletedName } | Select-Object -First 1\r\n        if (-not $sessionHost) {\r\n            Write-LogEntry -Message \"Warning: Could not find resource ID for deleted host {0}, skipping verification\" -StringValues $deletedName -Level Warning\r\n            continue\r\n        }\r\n        \r\n        $vmName = $sessionHost.resourceId.Split('/')[-1]\r\n        $vmUri = \"$ResourceManagerUri$($sessionHost.ResourceId)?api-version=2024-03-01\"\r\n        \r\n        $hostsToVerify += [PSCustomObject]@{\r\n            Name             = $deletedName\r\n            VMName           = $vmName\r\n            VMUri            = $vmUri\r\n            VMConfirmed      = $false\r\n            EntraIDConfirmed = $false\r\n            IntuneConfirmed  = $false\r\n        }\r\n    }\r\n    \r\n    # Mark Entra/Intune as confirmed if not being checked\r\n    if (-not $GraphToken -or (-not $RemoveEntraDevice -and -not $RemoveIntuneDevice)) {\r\n        Write-LogEntry -Message \"Graph token not available or device cleanup disabled - skipping Entra ID and Intune validation\" -Level Trace\r\n        foreach ($sh in $hostsToVerify) {\r\n            $sh.EntraIDConfirmed = $true\r\n            $sh.IntuneConfirmed = $true\r\n        }\r\n    }\r\n    elseif (-not $RemoveEntraDevice) {\r\n        foreach ($sh in $hostsToVerify) { $sh.EntraIDConfirmed = $true }\r\n    }\r\n    elseif (-not $RemoveIntuneDevice) {\r\n        foreach ($sh in $hostsToVerify) { $sh.IntuneConfirmed = $true }\r\n    }\r\n    \r\n    # Build verification system list for logging\r\n    $checkSystems = @('VM')\r\n    if ($GraphToken -and $RemoveEntraDevice) { $checkSystems += 'Entra ID' }\r\n    if ($GraphToken -and $RemoveIntuneDevice) { $checkSystems += 'Intune' }\r\n    Write-LogEntry -Message \"Verifying deletion for {0}...\" -StringValues ($checkSystems -join ', ') -Level Trace\r\n    \r\n    # Poll all systems until all hosts fully confirmed or timeout\r\n    $checkCount = 0\r\n    $incompleteHosts = $hostsToVerify | Where-Object { -not ($_.VMConfirmed -and $_.EntraIDConfirmed -and $_.IntuneConfirmed) }\r\n    \r\n    while ((Get-Date) -lt $timeoutTime -and $incompleteHosts.Count -gt 0) {\r\n        $checkCount++\r\n        $elapsedSeconds = [Math]::Round(((Get-Date) - $startTime).TotalSeconds)\r\n        $remainingHosts = $incompleteHosts.Count\r\n        Write-LogEntry -Message \"Deletion verification check {0} at {1}s: {2} host(s) with incomplete deletion...\" -StringValues $checkCount, $elapsedSeconds, $remainingHosts -Level Trace\r\n        \r\n        foreach ($sh in $incompleteHosts) {\r\n            # Check VM deletion\r\n            if (-not $sh.VMConfirmed) {\r\n                try {\r\n                    $vmCheck = Invoke-AzureRestMethod -ARMToken $ARMToken -Method Get -Uri $sh.VMUri -ErrorAction SilentlyContinue\r\n                    \r\n                    if ($null -eq $vmCheck -or $vmCheck.error.code -eq 'ResourceNotFound') {\r\n                        $sh.VMConfirmed = $true\r\n                        Write-LogEntry -Message \"VM deletion confirmed: {0}\" -StringValues $sh.VMName -Level Trace\r\n                    }\r\n                }\r\n                catch {\r\n                    # Exception likely means VM not found\r\n                    $sh.VMConfirmed = $true\r\n                    Write-LogEntry -Message \"VM deletion confirmed: {0}\" -StringValues $sh.VMName -Level Trace\r\n                }\r\n            }\r\n            \r\n            # Check Entra ID deletion (only if removal was enabled and Graph token available)\r\n            if (-not $sh.EntraIDConfirmed -and $GraphToken -and $RemoveEntraDevice) {\r\n                try {\r\n                    $entraDevice = Invoke-GraphApiWithRetry `\r\n                        -GraphEndpoint (Get-GraphEndpoint) `\r\n                        -GraphToken $GraphToken `\r\n                        -Method Get `\r\n                        -Uri \"/v1.0/devices?`$filter=displayName eq '$($sh.Name)'\" `\r\n                        -ClientId $ClientId\r\n                    \r\n                    if (-not $entraDevice.value -or $entraDevice.value.Count -eq 0) {\r\n                        $sh.EntraIDConfirmed = $true\r\n                        Write-LogEntry -Message \"Entra ID deletion confirmed: {0}\" -StringValues $sh.Name -Level Trace\r\n                    }\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"Error verifying Entra ID deletion for {0}: {1}\" -StringValues $sh.Name, $_.Exception.Message -Level Warning\r\n                }\r\n            }\r\n            \r\n            # Check Intune deletion (only if removal was enabled and Graph token available)\r\n            if (-not $sh.IntuneConfirmed -and $GraphToken -and $RemoveIntuneDevice) {\r\n                try {\r\n                    $intuneDevice = Invoke-GraphApiWithRetry `\r\n                        -GraphEndpoint (Get-GraphEndpoint) `\r\n                        -GraphToken $GraphToken `\r\n                        -Method Get `\r\n                        -Uri \"/v1.0/deviceManagement/managedDevices?`$filter=deviceName eq '$($sh.Name)'\" `\r\n                        -ClientId $ClientId\r\n                    \r\n                    if (-not $intuneDevice.value -or $intuneDevice.value.Count -eq 0) {\r\n                        $sh.IntuneConfirmed = $true\r\n                        Write-LogEntry -Message \"Intune deletion confirmed: {0}\" -StringValues $sh.Name -Level Trace\r\n                    }\r\n                }\r\n                catch {\r\n                    Write-LogEntry -Message \"Error verifying Intune deletion for {0}: {1}\" -StringValues $sh.Name, $_.Exception.Message -Level Warning\r\n                }\r\n            }\r\n            \r\n            # Log per-host status after each check\r\n            $vmStatus = if ($sh.VMConfirmed) { \"\" } else { \"\" }\r\n            $entraStatus = if ($sh.EntraIDConfirmed) { \"\" } else { \"\" }\r\n            $intuneStatus = if ($sh.IntuneConfirmed) { \"\" } else { \"\" }\r\n            $fullyConfirmed = $sh.VMConfirmed -and $sh.EntraIDConfirmed -and $sh.IntuneConfirmed\r\n            if ($fullyConfirmed) {\r\n                Write-LogEntry -Message \"Full deletion confirmed for {0}: VM={1} EntraID={2} Intune={3}\" -StringValues $sh.Name, $vmStatus, $entraStatus, $intuneStatus -Level Trace\r\n            }\r\n        }\r\n        \r\n        # Recalculate incomplete hosts for next iteration\r\n        $incompleteHosts = $hostsToVerify | Where-Object { -not ($_.VMConfirmed -and $_.EntraIDConfirmed -and $_.IntuneConfirmed) }\r\n        \r\n        if ($incompleteHosts.Count -gt 0 -and (Get-Date) -lt $timeoutTime) {\r\n            Start-Sleep -Seconds $PollIntervalSeconds\r\n        }\r\n    }\r\n\r\n    # Calculate summary counts\r\n    $vmsConfirmed = ($hostsToVerify | Where-Object { $_.VMConfirmed }).Count\r\n    $entraIDConfirmed = ($hostsToVerify | Where-Object { $_.EntraIDConfirmed }).Count\r\n    $intuneConfirmed = ($hostsToVerify | Where-Object { $_.IntuneConfirmed }).Count\r\n    $totalHosts = $hostsToVerify.Count\r\n\r\n    # Summary logging\r\n    Write-LogEntry -Message \"DELETION_VERIFICATION | VMs: {0}/{1} confirmed | EntraID: {2}/{3} confirmed | Intune: {4}/{5} confirmed\" `\r\n        -StringValues $vmsConfirmed, $totalHosts, $entraIDConfirmed, $totalHosts, $intuneConfirmed, $totalHosts\r\n\r\n    # Warn about any incomplete deletions\r\n    $incompleteHosts = $hostsToVerify | Where-Object { -not ($_.VMConfirmed -and $_.EntraIDConfirmed -and $_.IntuneConfirmed) }\r\n    if ($incompleteHosts.Count -gt 0) {\r\n        foreach ($sh in $incompleteHosts) {\r\n            $failures = @()\r\n            if (-not $sh.VMConfirmed) { $failures += \"VM\" }\r\n            if (-not $sh.EntraIDConfirmed) { $failures += \"EntraID\" }\r\n            if (-not $sh.IntuneConfirmed) { $failures += \"Intune\" }\r\n            Write-LogEntry -Message \"Warning: Incomplete deletion for {0} - unconfirmed: {1}\" -StringValues $sh.Name, ($failures -join ', ') -Level Warning\r\n        }\r\n    }\r\n    else {\r\n        Write-LogEntry -Message \"All deletions fully confirmed across VM, Entra ID, and Intune\"\r\n    }\r\n\r\n    # Return validation results\r\n    return [PSCustomObject]@{\r\n        TotalHosts       = $totalHosts\r\n        VMsConfirmed     = $vmsConfirmed\r\n        EntraIDConfirmed = $entraIDConfirmed\r\n        IntuneConfirmed  = $intuneConfirmed\r\n        IncompleteHosts  = $incompleteHosts\r\n    }\r\n}\r\n\r\n#EndRegion Device Cleanup\r\n\r\n# Export functions\r\nExport-ModuleMember -Function Remove-DeviceFromDirectories, Remove-EntraDevice, Remove-IntuneDevice, Confirm-SessionHostDeletions\r\n",
    "deploymentSuffix": "[uniqueString(resourceGroup().id, deployment().name)]",
    "hostPoolName": "[last(split(parameters('hostPoolResourceId'), '/'))]",
    "hostPoolResourceGroupName": "[split(parameters('hostPoolResourceId'), '/')[4]]",
    "hostPoolSubscriptionId": "[split(parameters('hostPoolResourceId'), '/')[2]]",
    "virtualMachinesResourceGroupName": "[last(split(parameters('virtualMachinesResourceGroupId'), '/'))]",
    "virtualMachinesSubscriptionId": "[split(parameters('virtualMachinesResourceGroupId'), '/')[2]]",
    "cloud": "[toLower(environment().name)]",
    "locationsObject": "[variables('$fxv#0')]",
    "locationsEnvProperty": "[if(startsWith(variables('cloud'), 'us'), 'other', variables('cloud'))]",
    "locations": "[variables('locationsObject')[variables('locationsEnvProperty')]]",
    "graphEndpoint": "[if(equals(variables('cloud'), 'azureusgovernment'), 'https://graph.microsoft.us', if(startsWith(variables('cloud'), 'us'), format('https://graph.{0}', environment().suffixes.storage), 'https://graph.microsoft.com'))]",
    "functionAppRegionAbbreviation": "[variables('locations')[parameters('location')].abbreviation]",
    "resourceAbbreviations": "[variables('$fxv#1')]",
    "nameConvReversed": "[if(startsWith(variables('hostPoolName'), format('{0}-', variables('resourceAbbreviations').hostPools)), false(), if(endsWith(variables('hostPoolName'), format('-{0}', variables('resourceAbbreviations').hostPools)), true(), false()))]",
    "arrHostPoolName": "[split(variables('hostPoolName'), '-')]",
    "hpBaseName": "[if(variables('nameConvReversed'), join(take(variables('arrHostPoolName'), sub(length(variables('arrHostPoolName')), 2)), '-'), join(take(skip(variables('arrHostPoolName'), 1), sub(length(variables('arrHostPoolName')), 2)), '-'))]",
    "hpResPrfx": "[if(variables('nameConvReversed'), variables('hpBaseName'), format('RESOURCETYPE-{0}', variables('hpBaseName')))]",
    "nameConvSuffix": "[if(variables('nameConvReversed'), 'LOCATION-RESOURCETYPE', 'LOCATION')]",
    "nameConv_HP_Resources": "[format('{0}-TOKEN-{1}', variables('hpResPrfx'), variables('nameConvSuffix'))]",
    "uniqueStringHosts": "[take(uniqueString(variables('virtualMachinesSubscriptionId'), variables('virtualMachinesResourceGroupName')), 6)]",
    "nameConv_Shared_Resources": "[if(variables('nameConvReversed'), format('avd-TOKEN-{0}', variables('nameConvSuffix')), format('RESOURCETYPE-avd-TOKEN-{0}', variables('nameConvSuffix')))]",
    "appServicePlanName": "[replace(replace(replace(variables('nameConv_Shared_Resources'), 'RESOURCETYPE', variables('resourceAbbreviations').appServicePlans), 'LOCATION', variables('functionAppRegionAbbreviation')), 'TOKEN-', '')]",
    "privateEndpointNameConv": "[replace(if(variables('nameConvReversed'), 'RESOURCE-SUBRESOURCE-VNETID-RESOURCETYPE', 'RESOURCETYPE-RESOURCE-SUBRESOURCE-VNETID'), 'RESOURCETYPE', variables('resourceAbbreviations').privateEndpoints)]",
    "privateEndpointNICNameConvTemp": "[if(variables('nameConvReversed'), format('{0}-RESOURCETYPE', variables('privateEndpointNameConv')), format('RESOURCETYPE-{0}', variables('privateEndpointNameConv')))]",
    "privateEndpointNICNameConv": "[replace(variables('privateEndpointNICNameConvTemp'), 'RESOURCETYPE', variables('resourceAbbreviations').networkInterfaces)]",
    "appInsightsName": "[if(not(empty(parameters('applicationInsightsNameOverride'))), parameters('applicationInsightsNameOverride'), replace(replace(replace(variables('nameConv_Shared_Resources'), 'RESOURCETYPE', variables('resourceAbbreviations').applicationInsights), 'TOKEN-', 'sessionhostreplacer-'), 'LOCATION', variables('functionAppRegionAbbreviation')))]",
    "workbookName": "[guid(subscription().subscriptionId, 'session-host-replacer-workbook')]",
    "functionAppName": "[if(not(empty(parameters('functionAppNameOverride'))), parameters('functionAppNameOverride'), replace(replace(replace(replace(variables('nameConv_HP_Resources'), 'RESOURCETYPE', variables('resourceAbbreviations').functionApps), 'LOCATION', variables('functionAppRegionAbbreviation')), 'TOKEN-', format('shr-{0}-', variables('uniqueStringHosts'))), 'LOCATION', variables('functionAppRegionAbbreviation')))]",
    "storageAccountName": "[if(not(empty(parameters('storageAccountNameOverride'))), toLower(parameters('storageAccountNameOverride')), toLower(replace(replace(replace(replace(variables('nameConv_HP_Resources'), 'RESOURCETYPE', ''), 'LOCATION', variables('functionAppRegionAbbreviation')), 'TOKEN-', format('shr-{0}', variables('uniqueStringHosts'))), '-', '')))]",
    "encryptionKeyName": "[format('{0}-encryption-key-{1}', variables('hpBaseName'), variables('storageAccountName'))]",
    "templateSpecNameFinal": "[if(not(empty(parameters('templateSpecName'))), parameters('templateSpecName'), replace(replace(replace(variables('nameConv_Shared_Resources'), 'RESOURCETYPE', variables('resourceAbbreviations').templateSpecs), 'TOKEN', 'sessionhost'), 'LOCATION', variables('functionAppRegionAbbreviation')))]",
    "virtualMachineNameConv": "[if(not(empty(parameters('virtualMachineNameConvOverride'))), parameters('virtualMachineNameConvOverride'), if(variables('nameConvReversed'), format('SHNAME-{0}', variables('resourceAbbreviations').virtualMachines), format('{0}-SHNAME', variables('resourceAbbreviations').virtualMachines)))]",
    "diskNameConv": "[if(not(empty(parameters('diskNameConvOverride'))), parameters('diskNameConvOverride'), if(variables('nameConvReversed'), format('SHNAME-{0}', variables('resourceAbbreviations').osdisks), format('{0}-SHNAME', variables('resourceAbbreviations').osdisks)))]",
    "networkInterfaceNameConv": "[if(not(empty(parameters('networkInterfaceNameConvOverride'))), parameters('networkInterfaceNameConvOverride'), if(variables('nameConvReversed'), format('SHNAME-{0}', variables('resourceAbbreviations').networkInterfaces), format('{0}-SHNAME', variables('resourceAbbreviations').networkInterfaces)))]",
    "computeGalleryResourceId": "[if(not(empty(parameters('customImageResourceId'))), join(take(split(parameters('customImageResourceId'), '/'), 9), '/'), '')]",
    "paramArtifactsContainerUri": "[if(not(empty(parameters('artifactsContainerUri'))), createObject('artifactsContainerUri', parameters('artifactsContainerUri')), createObject())]",
    "paramArtifactsUserAssignedIdentityResourceId": "[if(not(empty(parameters('artifactsUserAssignedIdentityResourceId'))), createObject('artifactsUserAssignedIdentityResourceId', parameters('artifactsUserAssignedIdentityResourceId')), createObject())]",
    "paramAvailabilityZones": "[if(not(empty(parameters('availabilityZones'))), createObject('availabilityZones', parameters('availabilityZones')), createObject())]",
    "paramAvdInsightsDataCollectionRulesResourceId": "[if(not(empty(parameters('avdInsightsDataCollectionRulesResourceId'))), createObject('avdInsightsDataCollectionRulesResourceId', parameters('avdInsightsDataCollectionRulesResourceId')), createObject())]",
    "paramConfidentialVMOSDiskEncryption": "[if(parameters('confidentialVMOSDiskEncryption'), createObject('confidentialVMOSDiskEncryption', parameters('confidentialVMOSDiskEncryption')), createObject())]",
    "paramDataCollectionEndpointResourceId": "[if(not(empty(parameters('dataCollectionEndpointResourceId'))), createObject('dataCollectionEndpointResourceId', parameters('dataCollectionEndpointResourceId')), createObject())]",
    "paramDiskEncryptionSetResourceId": "[if(not(empty(parameters('diskEncryptionSetResourceId'))), createObject('diskEncryptionSetResourceId', parameters('diskEncryptionSetResourceId')), createObject())]",
    "paramDomainName": "[if(not(empty(parameters('domainName'))), createObject('domainName', parameters('domainName')), createObject())]",
    "paramEnableMonitoring": "[if(parameters('enableMonitoring'), createObject('enableMonitoring', parameters('enableMonitoring')), createObject())]",
    "paramIntegrityMonitoring": "[if(parameters('integrityMonitoring'), createObject('integrityMonitoring', parameters('integrityMonitoring')), createObject())]",
    "paramIntuneEnrollment": "[if(parameters('intuneEnrollment'), createObject('intuneEnrollment', parameters('intuneEnrollment')), createObject())]",
    "paramOuPath": "[if(not(empty(parameters('ouPath'))), createObject('ouPath', parameters('ouPath')), createObject())]",
    "paramSessionHostCustomizations": "[if(not(empty(parameters('sessionHostCustomizations'))), createObject('sessionHostCustomizations', parameters('sessionHostCustomizations')), createObject())]",
    "paramVmInsightsDataCollectionRulesResourceId": "[if(not(empty(parameters('vmInsightsDataCollectionRulesResourceId'))), createObject('vmInsightsDataCollectionRulesResourceId', parameters('vmInsightsDataCollectionRulesResourceId')), createObject())]",
    "paramFslogixConfigureSessionHosts": "[if(parameters('fslogixConfigureSessionHosts'), createObject('fslogixConfigureSessionHosts', parameters('fslogixConfigureSessionHosts')), createObject())]",
    "paramFslogixContainerType": "[if(parameters('fslogixConfigureSessionHosts'), createObject('fslogixContainerType', parameters('fslogixContainerType')), createObject())]",
    "paramFslogixLocalNetAppVolumeResourceIds": "[if(and(parameters('fslogixConfigureSessionHosts'), not(empty(parameters('fslogixLocalNetAppVolumeResourceIds')))), createObject('fslogixLocalNetAppVolumeResourceIds', parameters('fslogixLocalNetAppVolumeResourceIds')), createObject())]",
    "paramFslogixLocalStorageAccountResourceIds": "[if(and(parameters('fslogixConfigureSessionHosts'), not(empty(parameters('fslogixLocalStorageAccountResourceIds')))), createObject('fslogixLocalStorageAccountResourceIds', parameters('fslogixLocalStorageAccountResourceIds')), createObject())]",
    "paramFslogixOSSGroups": "[if(and(parameters('fslogixConfigureSessionHosts'), not(empty(parameters('fslogixOSSGroups')))), createObject('fslogixOSSGroups', parameters('fslogixOSSGroups')), createObject())]",
    "paramFslogixRemoteNetAppVolumeResourceIds": "[if(and(parameters('fslogixConfigureSessionHosts'), not(empty(parameters('fslogixRemoteNetAppVolumeResourceIds')))), createObject('fslogixRemoteNetAppVolumeResourceIds', parameters('fslogixRemoteNetAppVolumeResourceIds')), createObject())]",
    "paramFslogixRemoteStorageAccountResourceIds": "[if(and(parameters('fslogixConfigureSessionHosts'), not(empty(parameters('fslogixRemoteStorageAccountResourceIds')))), createObject('fslogixRemoteStorageAccountResourceIds', parameters('fslogixRemoteStorageAccountResourceIds')), createObject())]",
    "paramFslogixSizeInMBs": "[if(parameters('fslogixConfigureSessionHosts'), createObject('fslogixSizeInMBs', parameters('fslogixSizeInMBs')), createObject())]",
    "paramFslogixStorageService": "[if(parameters('fslogixConfigureSessionHosts'), createObject('fslogixStorageService', parameters('fslogixStorageService')), createObject())]",
    "monitoringResourceGroupId": "[if(not(empty(parameters('avdInsightsDataCollectionRulesResourceId'))), format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('avdInsightsDataCollectionRulesResourceId'), '/')[2], split(parameters('avdInsightsDataCollectionRulesResourceId'), '/')[4]), if(not(empty(parameters('vmInsightsDataCollectionRulesResourceId'))), format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('vmInsightsDataCollectionRulesResourceId'), '/')[2], split(parameters('vmInsightsDataCollectionRulesResourceId'), '/')[4]), if(not(empty(parameters('dataCollectionEndpointResourceId'))), format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('dataCollectionEndpointResourceId'), '/')[2], split(parameters('dataCollectionEndpointResourceId'), '/')[4]), '')))]",
    "hostPoolResourceGroupId": "[format('/subscriptions/{0}/resourceGroups/{1}', variables('hostPoolSubscriptionId'), variables('hostPoolResourceGroupName'))]",
    "roleAssignmentsResourceGroups": "[union(createArray(createObject('resourceGroupId', variables('hostPoolResourceGroupId'), 'roleDefinitionId', 'e307426c-f9b6-4e81-87de-d99efb3c32bc', 'roleDescription', 'DVHPCont')), if(not(empty(variables('monitoringResourceGroupId'))), createArray(createObject('resourceGroupId', parameters('virtualMachinesResourceGroupId'), 'roleDefinitionId', '749f88d5-cbae-40b8-bcfc-e573ddc772fa', 'roleDescription', 'MonCont')), createArray()), if(and(not(empty(variables('monitoringResourceGroupId'))), not(equals(variables('monitoringResourceGroupId'), parameters('virtualMachinesResourceGroupId')))), createArray(createObject('resourceGroupId', variables('monitoringResourceGroupId'), 'roleDefinitionId', '749f88d5-cbae-40b8-bcfc-e573ddc772fa', 'roleDescription', 'MonCont')), createArray()))]"
  },
  "resources": [
    {
      "condition": "[empty(parameters('sessionHostTemplateSpecResourceId'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('SessionHostTemplateSpec-{0}', variables('deploymentSuffix'))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "templateSpecName": {
            "value": "[variables('templateSpecNameFinal')]"
          },
          "templateSpecVersion": {
            "value": "[parameters('templateSpecVersion')]"
          },
          "tags": {
            "value": "[coalesce(tryGet(parameters('tags'), 'Microsoft.Resources/templateSpecs'), createObject())]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "10224960162525916020"
            }
          },
          "parameters": {
            "location": {
              "type": "string"
            },
            "templateSpecName": {
              "type": "string"
            },
            "templateSpecVersion": {
              "type": "string"
            },
            "tags": {
              "type": "object"
            }
          },
          "variables": {
            "$fxv#0": {
              "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
              "contentVersion": "1.0.0.0",
              "metadata": {
                "_generator": {
                  "name": "bicep",
                  "version": "0.39.26.7824",
                  "templateHash": "14146623445166458904"
                }
              },
              "parameters": {
                "artifactsContainerUri": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "URI of the storage container holding custom artifacts for session host configuration."
                  }
                },
                "artifactsUserAssignedIdentityResourceId": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Resource ID of the user-assigned managed identity with access to the artifacts container."
                  }
                },
                "availability": {
                  "type": "string",
                  "defaultValue": "None",
                  "allowedValues": [
                    "AvailabilitySets",
                    "AvailabilityZones",
                    "None"
                  ],
                  "metadata": {
                    "description": "Availability option for session hosts. Valid values: AvailabilitySets, AvailabilityZones, None."
                  }
                },
                "availabilitySetNameConv": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Naming convention for availability sets when availability is set to AvailabilitySets. Use ## as placeholder for the index."
                  }
                },
                "availabilityZones": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of availability zones to distribute session hosts across when availability is set to AvailabilityZones."
                  }
                },
                "avdAgentsDSCPackage": {
                  "type": "string",
                  "metadata": {
                    "description": "Name of the DSC package used to register session hosts with the AVD host pool."
                  }
                },
                "avdInsightsDataCollectionRulesResourceId": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Resource ID of the data collection rule for AVD Insights monitoring."
                  }
                },
                "confidentialVMOSDiskEncryption": {
                  "type": "bool",
                  "defaultValue": false,
                  "metadata": {
                    "description": "Enable confidential VM OS disk encryption with VM guest state. Only applicable for confidential VMs."
                  }
                },
                "credentialsKeyVaultResourceId": {
                  "type": "string",
                  "metadata": {
                    "description": "Resource ID of the Key Vault containing credentials for domain join and VM admin accounts."
                  }
                },
                "dataCollectionEndpointResourceId": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Resource ID of the data collection endpoint for Azure Monitor agent."
                  }
                },
                "dedicatedHostGroupResourceIds": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of resource IDs for dedicated host groups. One per session host, or single value applied to all, or empty string for VMs without assignment."
                  }
                },
                "dedicatedHostResourceIds": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of resource IDs for specific dedicated hosts. One per session host, or single value applied to all, or empty string for VMs without assignment."
                  }
                },
                "preferredZones": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of preferred zones for each session host. One per session host (as array like [\"1\"]), or empty for VMs without specific zone preference."
                  }
                },
                "diskEncryptionSetResourceId": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Resource ID of the disk encryption set for encrypting managed disks with customer-managed keys."
                  }
                },
                "diskSizeGB": {
                  "type": "int",
                  "defaultValue": 0,
                  "allowedValues": [
                    0,
                    32,
                    64,
                    128,
                    256,
                    512,
                    1024,
                    2048
                  ],
                  "metadata": {
                    "description": "Size of the OS disk in GB."
                  }
                },
                "diskSku": {
                  "type": "string",
                  "defaultValue": "Premium_LRS",
                  "allowedValues": [
                    "Standard_LRS",
                    "StandardSSD_LRS",
                    "Premium_LRS"
                  ],
                  "metadata": {
                    "description": "SKU for the managed OS disk. Examples: Premium_LRS, StandardSSD_LRS, Standard_LRS."
                  }
                },
                "domainName": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Fully qualified domain name (FQDN) for Active Directory domain join."
                  }
                },
                "enableAcceleratedNetworking": {
                  "type": "bool",
                  "defaultValue": true,
                  "metadata": {
                    "description": "Enable accelerated networking on network interfaces for improved network performance."
                  }
                },
                "enableIPv6": {
                  "type": "bool",
                  "defaultValue": false,
                  "metadata": {
                    "description": "Enable IPv6 on network interfaces."
                  }
                },
                "encryptionAtHost": {
                  "type": "bool",
                  "defaultValue": true,
                  "metadata": {
                    "description": "Enable encryption at host for additional data encryption on the VM host."
                  }
                },
                "fslogixConfigureSessionHosts": {
                  "type": "bool",
                  "defaultValue": false,
                  "metadata": {
                    "description": "Configure FSLogix on session hosts during deployment."
                  }
                },
                "fslogixContainerType": {
                  "type": "string",
                  "defaultValue": "ProfileContainer",
                  "allowedValues": [
                    "CloudCacheProfileContainer",
                    "CloudCacheProfileOfficeContainer",
                    "ProfileContainer",
                    "ProfileOfficeContainer"
                  ],
                  "metadata": {
                    "description": "Type of FSLogix container. Valid values: CloudCacheProfileContainer, CloudCacheProfileOfficeContainer, ProfileContainer, ProfileOfficeContainer."
                  }
                },
                "fslogixLocalNetAppVolumeResourceIds": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of resource IDs for local Azure NetApp Files volumes used for FSLogix containers."
                  }
                },
                "fslogixLocalStorageAccountResourceIds": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of resource IDs for local storage accounts used for FSLogix containers."
                  }
                },
                "fslogixOSSGroups": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of Active Directory security groups for FSLogix Office 365 container redirection."
                  }
                },
                "fslogixRemoteNetAppVolumeResourceIds": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of resource IDs for remote Azure NetApp Files volumes used for FSLogix containers in DR scenarios."
                  }
                },
                "fslogixRemoteStorageAccountResourceIds": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of resource IDs for remote storage accounts used for FSLogix containers in DR scenarios."
                  }
                },
                "fslogixSizeInMBs": {
                  "type": "int",
                  "defaultValue": 30720,
                  "metadata": {
                    "description": "Size limit in MB for FSLogix containers. 0 = no limit."
                  }
                },
                "fslogixStorageService": {
                  "type": "string",
                  "defaultValue": "AzureFiles",
                  "allowedValues": [
                    "AzureFiles",
                    "AzureNetAppFiles"
                  ],
                  "metadata": {
                    "description": "Storage service type for FSLogix."
                  }
                },
                "hostPoolResourceId": {
                  "type": "string",
                  "metadata": {
                    "description": "Resource ID of the AVD host pool that session hosts will be registered to."
                  }
                },
                "identitySolution": {
                  "type": "string",
                  "allowedValues": [
                    "ActiveDirectoryDomainServices",
                    "EntraDomainServices",
                    "EntraId",
                    "EntraKerberos-CloudOnly",
                    "EntraKerberos-Hybrid"
                  ],
                  "metadata": {
                    "description": "Identity solution for session hosts. Valid values: ActiveDirectoryDomainServices, EntraDomainServices, EntraId, EntraKerberos-CloudOnly, EntraKerberos-Hybrid."
                  }
                },
                "imageReference": {
                  "type": "object",
                  "metadata": {
                    "description": "Image reference object containing either marketplace image details or compute gallery image version resource ID."
                  }
                },
                "integrityMonitoring": {
                  "type": "bool",
                  "defaultValue": false,
                  "metadata": {
                    "description": "Enable Microsoft Defender for Cloud integrity monitoring on session hosts."
                  }
                },
                "intuneEnrollment": {
                  "type": "bool",
                  "defaultValue": false,
                  "metadata": {
                    "description": "Enroll session hosts in Microsoft Intune. Only applicable with EntraIDIntuneEnrollment identity solution."
                  }
                },
                "location": {
                  "type": "string",
                  "defaultValue": "[[resourceGroup().location]",
                  "metadata": {
                    "description": "Azure region where session hosts will be deployed."
                  }
                },
                "enableMonitoring": {
                  "type": "bool",
                  "defaultValue": false,
                  "metadata": {
                    "description": "Enable Azure Monitor VM insights on session hosts."
                  }
                },
                "networkInterfaceNameConv": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Naming convention pattern for network interfaces."
                  }
                },
                "osDiskNameConv": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Naming convention pattern for OS managed disks."
                  }
                },
                "ouPath": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Organizational Unit (OU) path in Active Directory for computer objects. Leave empty for default Computers container."
                  }
                },
                "secureBootEnabled": {
                  "type": "bool",
                  "defaultValue": true,
                  "metadata": {
                    "description": "Enable secure boot for generation 2 VMs."
                  }
                },
                "securityType": {
                  "type": "string",
                  "defaultValue": "TrustedLaunch",
                  "allowedValues": [
                    "Standard",
                    "TrustedLaunch",
                    "ConfidentialVM"
                  ],
                  "metadata": {
                    "description": "Security type for VMs. Valid values: Standard, TrustedLaunch, ConfidentialVM."
                  }
                },
                "sessionHostCustomizations": {
                  "type": "array",
                  "defaultValue": [],
                  "metadata": {
                    "description": "Array of custom script extension configurations for additional session host customization."
                  }
                },
                "sessionHostNameIndexLength": {
                  "type": "int",
                  "defaultValue": 2,
                  "minValue": 1,
                  "maxValue": 4,
                  "metadata": {
                    "description": "Number of digits used in the session host name index. Determines how many characters from the end represent the VM number."
                  }
                },
                "sessionHostNames": {
                  "type": "array",
                  "metadata": {
                    "description": "Array of session host names to deploy. Names should follow the pattern <prefix><index> where index length matches sessionHostNameIndexLength."
                  }
                },
                "subnetResourceId": {
                  "type": "string",
                  "metadata": {
                    "description": "Resource ID of the subnet where session host network interfaces will be placed."
                  }
                },
                "tags": {
                  "type": "object",
                  "defaultValue": {},
                  "metadata": {
                    "description": "Tags to apply to deployed resources. Organized by resource type."
                  }
                },
                "timeZone": {
                  "type": "string",
                  "defaultValue": "Eastern Standard Time",
                  "metadata": {
                    "description": "Time zone for session hosts. Use Windows time zone format (e.g., Eastern Standard Time, Pacific Standard Time)."
                  }
                },
                "virtualMachineNameConv": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Naming convention pattern for virtual machines."
                  }
                },
                "virtualMachineSize": {
                  "type": "string",
                  "metadata": {
                    "description": "Azure VM size for session hosts. Examples: Standard_D4s_v5, Standard_D8s_v5."
                  }
                },
                "vTpmEnabled": {
                  "type": "bool",
                  "defaultValue": true,
                  "metadata": {
                    "description": "Enable virtual Trusted Platform Module (vTPM) for generation 2 VMs."
                  }
                },
                "vmInsightsDataCollectionRulesResourceId": {
                  "type": "string",
                  "defaultValue": "",
                  "metadata": {
                    "description": "Resource ID of the data collection rule for VM Insights performance and dependency monitoring."
                  }
                }
              },
              "variables": {
                "[string('copy')]": [
                  {
                    "name": "vmNumbersForAvSet",
                    "count": "[[length(parameters('sessionHostNames'))]",
                    "input": "[[int(substring(parameters('sessionHostNames')[copyIndex('vmNumbersForAvSet')], sub(length(parameters('sessionHostNames')[copyIndex('vmNumbersForAvSet')]), parameters('sessionHostNameIndexLength')), parameters('sessionHostNameIndexLength')))]"
                  }
                ],
                "avSetNameConv": "[[if(empty(parameters('availabilitySetNameConv')), format('as-{0}-##', substring(parameters('sessionHostNames')[0], 0, sub(length(parameters('sessionHostNames')[0]), parameters('sessionHostNameIndexLength')))), parameters('availabilitySetNameConv'))]",
                "deploymentSuffix": "[[uniqueString(deployment().name)]",
                "sessionHostRegistrationDSCStorageAccount": "[[if(startsWith(environment().name, 'USN'), 'wvdexportalcontainer', 'wvdportalstorageblob')]",
                "sessionHostRegistrationDSCUrl": "[[if(startsWith(parameters('avdAgentsDSCPackage'), 'https://'), parameters('avdAgentsDSCPackage'), format('https://{0}.blob.{1}/galleryartifacts/{2}', variables('sessionHostRegistrationDSCStorageAccount'), environment().suffixes.storage, parameters('avdAgentsDSCPackage')))]",
                "confidentialVMOSDiskEncryptionType": "[[if(parameters('confidentialVMOSDiskEncryption'), 'DiskWithVMGuestState', 'VMGuestStateOnly')]",
                "hasAmdGpu": "[[and(contains(parameters('virtualMachineSize'), 'Standard_NV'), or(endsWith(parameters('virtualMachineSize'), 'as_v4'), endsWith(parameters('virtualMachineSize'), '_V710_v5')))]",
                "hasNvidiaGpu": "[[and(contains(parameters('virtualMachineSize'), 'Standard_NV'), or(endsWith(parameters('virtualMachineSize'), '_v3'), endsWith(parameters('virtualMachineSize'), '_A10_v5')))]",
                "baseResourcesPerVM": 11,
                "monitoringResourcesPerVM": "[[if(parameters('enableMonitoring'), 4, 0)]",
                "gpuResourcesPerVM": "[[if(or(variables('hasAmdGpu'), variables('hasNvidiaGpu')), 1, 0)]",
                "integrityResourcesPerVM": "[[if(parameters('integrityMonitoring'), 1, 0)]",
                "customizationsResourcesPerVM": "[[if(not(empty(parameters('sessionHostCustomizations'))), add(1, length(parameters('sessionHostCustomizations'))), 0)]",
                "totalResourcesPerVM": "[[add(add(add(add(variables('baseResourcesPerVM'), variables('monitoringResourcesPerVM')), variables('gpuResourcesPerVM')), variables('integrityResourcesPerVM')), variables('customizationsResourcesPerVM'))]",
                "calculatedMaxVMs": "[[div(800, variables('totalResourcesPerVM'))]",
                "maxVMsPerDeployment": "[[if(less(variables('calculatedMaxVMs'), 20), 20, if(greater(variables('calculatedMaxVMs'), 45), 45, variables('calculatedMaxVMs')))]",
                "totalVMCount": "[[length(parameters('sessionHostNames'))]",
                "divisionValue": "[[div(variables('totalVMCount'), variables('maxVMsPerDeployment'))]",
                "divisionRemainderValue": "[[mod(variables('totalVMCount'), variables('maxVMsPerDeployment'))]",
                "sessionHostBatchCount": "[[if(greater(variables('divisionRemainderValue'), 0), add(variables('divisionValue'), 1), variables('divisionValue'))]",
                "minVmNumber": "[[min(variables('vmNumbersForAvSet'))]",
                "maxVmNumber": "[[max(variables('vmNumbersForAvSet'))]",
                "maxAvSetMembers": 200,
                "beginAvSetRange": "[[div(variables('minVmNumber'), variables('maxAvSetMembers'))]",
                "endAvSetRange": "[[div(variables('maxVmNumber'), variables('maxAvSetMembers'))]",
                "calculatedAvailabilitySetsCount": "[[add(sub(variables('endAvSetRange'), variables('beginAvSetRange')), 1)]",
                "calculatedAvailabilitySetsIndex": "[[variables('beginAvSetRange')]",
                "fslogixFileShareNames": "[[if(contains(parameters('fslogixContainerType'), 'Office'), createArray('profile-containers', 'office-containers'), createArray('profile-containers'))]"
              },
              "resources": [
                {
                  "condition": "[[and(parameters('fslogixConfigureSessionHosts'), or(not(empty(parameters('fslogixLocalNetAppVolumeResourceIds'))), not(empty(parameters('fslogixRemoteNetAppVolumeResourceIds')))))]",
                  "type": "Microsoft.Resources/deployments",
                  "apiVersion": "2025-04-01",
                  "name": "[[format('shr-netAppVolumeFqdns-{0}', variables('deploymentSuffix'))]",
                  "properties": {
                    "expressionEvaluationOptions": {
                      "scope": "inner"
                    },
                    "mode": "Incremental",
                    "parameters": {
                      "localNetAppVolumeResourceIds": {
                        "value": "[[parameters('fslogixLocalNetAppVolumeResourceIds')]"
                      },
                      "remoteNetAppVolumeResourceIds": {
                        "value": "[[parameters('fslogixRemoteNetAppVolumeResourceIds')]"
                      },
                      "shareNames": {
                        "value": "[[variables('fslogixFileShareNames')]"
                      }
                    },
                    "template": {
                      "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                      "contentVersion": "1.0.0.0",
                      "metadata": {
                        "_generator": {
                          "name": "bicep",
                          "version": "0.39.26.7824",
                          "templateHash": "11609031045672993663"
                        }
                      },
                      "parameters": {
                        "localNetAppVolumeResourceIds": {
                          "type": "array"
                        },
                        "remoteNetAppVolumeResourceIds": {
                          "type": "array"
                        },
                        "shareNames": {
                          "type": "array"
                        }
                      },
                      "variables": {
                        "localNetAppProfileContainerVolumeResourceIds": "[[if(not(empty(parameters('localNetAppVolumeResourceIds'))), filter(parameters('localNetAppVolumeResourceIds'), lambda('id', contains(lambdaVariables('id'), parameters('shareNames')[0]))), createArray())]",
                        "localNetAppOfficeContainerVolumeResourceIds": "[[if(and(not(empty(parameters('localNetAppVolumeResourceIds'))), greater(length(parameters('shareNames')), 1)), filter(parameters('localNetAppVolumeResourceIds'), lambda('id', contains(lambdaVariables('id'), parameters('shareNames')[1]))), createArray())]",
                        "sortedLocalNetAppResourceIds": "[[union(variables('localNetAppProfileContainerVolumeResourceIds'), variables('localNetAppOfficeContainerVolumeResourceIds'))]",
                        "remoteNetAppProfileContainerVolumeResourceIds": "[[if(not(empty(parameters('remoteNetAppVolumeResourceIds'))), filter(parameters('remoteNetAppVolumeResourceIds'), lambda('id', contains(lambdaVariables('id'), parameters('shareNames')[0]))), createArray())]",
                        "remoteNetAppOfficeContainerVolumeResourceIds": "[[if(and(not(empty(parameters('remoteNetAppVolumeResourceIds'))), greater(length(parameters('shareNames')), 1)), filter(parameters('remoteNetAppVolumeResourceIds'), lambda('id', not(contains(lambdaVariables('id'), parameters('shareNames')[0])))), createArray())]",
                        "sortedRemoteNetAppResourceIds": "[[union(variables('remoteNetAppProfileContainerVolumeResourceIds'), variables('remoteNetAppOfficeContainerVolumeResourceIds'))]"
                      },
                      "resources": [],
                      "outputs": {
                        "localNetAppVolumeSmbServerFqdns": {
                          "type": "array",
                          "[string('copy')]": {
                            "count": "[[length(range(0, length(variables('sortedLocalNetAppResourceIds'))))]",
                            "input": "[[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(variables('sortedLocalNetAppResourceIds')[range(0, length(variables('sortedLocalNetAppResourceIds')))[range(0, length(variables('sortedLocalNetAppResourceIds')))[copyIndex()]]], '/')[2], split(variables('sortedLocalNetAppResourceIds')[range(0, length(variables('sortedLocalNetAppResourceIds')))[range(0, length(variables('sortedLocalNetAppResourceIds')))[copyIndex()]]], '/')[4]), 'Microsoft.NetApp/netAppAccounts/capacityPools/volumes', split(last(split(variables('sortedLocalNetAppResourceIds')[range(0, length(variables('sortedLocalNetAppResourceIds')))[range(0, length(variables('sortedLocalNetAppResourceIds')))[copyIndex()]]], '/')), '/')[0], split(last(split(variables('sortedLocalNetAppResourceIds')[range(0, length(variables('sortedLocalNetAppResourceIds')))[range(0, length(variables('sortedLocalNetAppResourceIds')))[copyIndex()]]], '/')), '/')[1], split(last(split(variables('sortedLocalNetAppResourceIds')[range(0, length(variables('sortedLocalNetAppResourceIds')))[range(0, length(variables('sortedLocalNetAppResourceIds')))[copyIndex()]]], '/')), '/')[2]), '2023-11-01').mountTargets[0].smbServerFqdn]"
                          }
                        },
                        "remoteNetAppVolumeSmbServerFqdns": {
                          "type": "array",
                          "[string('copy')]": {
                            "count": "[[length(range(0, length(variables('sortedRemoteNetAppResourceIds'))))]",
                            "input": "[[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(variables('sortedRemoteNetAppResourceIds')[range(0, length(variables('sortedRemoteNetAppResourceIds')))[range(0, length(variables('sortedRemoteNetAppResourceIds')))[copyIndex()]]], '/')[2], split(variables('sortedRemoteNetAppResourceIds')[range(0, length(variables('sortedRemoteNetAppResourceIds')))[range(0, length(variables('sortedRemoteNetAppResourceIds')))[copyIndex()]]], '/')[4]), 'Microsoft.NetApp/netAppAccounts/capacityPools/volumes', split(last(split(variables('sortedRemoteNetAppResourceIds')[range(0, length(variables('sortedRemoteNetAppResourceIds')))[range(0, length(variables('sortedRemoteNetAppResourceIds')))[copyIndex()]]], '/')), '/')[0], split(last(split(variables('sortedRemoteNetAppResourceIds')[range(0, length(variables('sortedRemoteNetAppResourceIds')))[range(0, length(variables('sortedRemoteNetAppResourceIds')))[copyIndex()]]], '/')), '/')[1], split(last(split(variables('sortedRemoteNetAppResourceIds')[range(0, length(variables('sortedRemoteNetAppResourceIds')))[range(0, length(variables('sortedRemoteNetAppResourceIds')))[copyIndex()]]], '/')), '/')[2]), '2023-11-01').mountTargets[0].smbServerFqdn]"
                          }
                        }
                      }
                    }
                  }
                },
                {
                  "[string('copy')]": {
                    "name": "availabilitySets",
                    "count": "[[length(range(0, variables('calculatedAvailabilitySetsCount')))]"
                  },
                  "condition": "[[equals(parameters('availability'), 'AvailabilitySets')]",
                  "type": "Microsoft.Resources/deployments",
                  "apiVersion": "2025-04-01",
                  "name": "[[format('shr-availabilitySet-{0}-{1}', padLeft(add(add(range(0, variables('calculatedAvailabilitySetsCount'))[copyIndex()], variables('calculatedAvailabilitySetsIndex')), 1), 2, '0'), variables('deploymentSuffix'))]",
                  "properties": {
                    "expressionEvaluationOptions": {
                      "scope": "inner"
                    },
                    "mode": "Incremental",
                    "parameters": {
                      "name": {
                        "value": "[[replace(variables('avSetNameConv'), '##', padLeft(add(add(range(0, variables('calculatedAvailabilitySetsCount'))[copyIndex()], variables('calculatedAvailabilitySetsIndex')), 1), 2, '0'))]"
                      },
                      "platformFaultDomainCount": {
                        "value": 2
                      },
                      "platformUpdateDomainCount": {
                        "value": 5
                      },
                      "proximityPlacementGroupResourceId": {
                        "value": ""
                      },
                      "location": {
                        "value": "[[parameters('location')]"
                      },
                      "skuName": {
                        "value": "Aligned"
                      },
                      "tags": {
                        "value": "[[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Compute/availabilitySets'), createObject()))]"
                      }
                    },
                    "template": {
                      "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                      "contentVersion": "1.0.0.0",
                      "metadata": {
                        "_generator": {
                          "name": "bicep",
                          "version": "0.39.26.7824",
                          "templateHash": "3553316518590342751"
                        },
                        "name": "Availability Sets",
                        "description": "This module deploys an Availability Set.",
                        "owner": "Azure/module-maintainers"
                      },
                      "parameters": {
                        "name": {
                          "type": "string",
                          "metadata": {
                            "description": "Required. The name of the availability set that is being created."
                          }
                        },
                        "platformFaultDomainCount": {
                          "type": "int",
                          "defaultValue": 2,
                          "metadata": {
                            "description": "Optional. The number of fault domains to use."
                          }
                        },
                        "platformUpdateDomainCount": {
                          "type": "int",
                          "defaultValue": 5,
                          "metadata": {
                            "description": "Optional. The number of update domains to use."
                          }
                        },
                        "skuName": {
                          "type": "string",
                          "defaultValue": "Aligned",
                          "metadata": {
                            "description": "Optional. SKU of the availability set.</p>- Use 'Aligned' for virtual machines with managed disks.</p>- Use 'Classic' for virtual machines with unmanaged disks."
                          }
                        },
                        "proximityPlacementGroupResourceId": {
                          "type": "string",
                          "defaultValue": "",
                          "metadata": {
                            "description": "Optional. Resource ID of a proximity placement group."
                          }
                        },
                        "location": {
                          "type": "string",
                          "defaultValue": "[[resourceGroup().location]",
                          "metadata": {
                            "description": "Optional. Resource location."
                          }
                        },
                        "tags": {
                          "type": "object",
                          "defaultValue": {},
                          "metadata": {
                            "description": "Optional. Tags of the availability set resource."
                          }
                        }
                      },
                      "resources": [
                        {
                          "type": "Microsoft.Compute/availabilitySets",
                          "apiVersion": "2022-11-01",
                          "name": "[[parameters('name')]",
                          "location": "[[parameters('location')]",
                          "tags": "[[parameters('tags')]",
                          "properties": {
                            "platformFaultDomainCount": "[[parameters('platformFaultDomainCount')]",
                            "platformUpdateDomainCount": "[[parameters('platformUpdateDomainCount')]",
                            "proximityPlacementGroup": "[[if(not(empty(parameters('proximityPlacementGroupResourceId'))), createObject('id', parameters('proximityPlacementGroupResourceId')), null())]"
                          },
                          "sku": {
                            "name": "[[parameters('skuName')]"
                          }
                        }
                      ],
                      "outputs": {
                        "name": {
                          "type": "string",
                          "metadata": {
                            "description": "The name of the availability set."
                          },
                          "value": "[[parameters('name')]"
                        },
                        "resourceId": {
                          "type": "string",
                          "metadata": {
                            "description": "The resource ID of the availability set."
                          },
                          "value": "[[resourceId('Microsoft.Compute/availabilitySets', parameters('name'))]"
                        },
                        "resourceGroupName": {
                          "type": "string",
                          "metadata": {
                            "description": "The resource group the availability set was deployed into."
                          },
                          "value": "[[resourceGroup().name]"
                        },
                        "location": {
                          "type": "string",
                          "metadata": {
                            "description": "The location the resource was deployed into."
                          },
                          "value": "[[reference(resourceId('Microsoft.Compute/availabilitySets', parameters('name')), '2022-11-01', 'full').location]"
                        }
                      }
                    }
                  }
                },
                {
                  "[string('copy')]": {
                    "name": "virtualMachines",
                    "count": "[[length(range(1, variables('sessionHostBatchCount')))]",
                    "mode": "serial",
                    "batchSize": 5
                  },
                  "type": "Microsoft.Resources/deployments",
                  "apiVersion": "2025-04-01",
                  "name": "[[format('shr-vm-batch-{0}-of-{1}_({2}-vms)-{3}', range(1, variables('sessionHostBatchCount'))[copyIndex()], variables('sessionHostBatchCount'), if(and(equals(range(1, variables('sessionHostBatchCount'))[copyIndex()], variables('sessionHostBatchCount')), greater(variables('divisionRemainderValue'), 0)), variables('divisionRemainderValue'), variables('maxVMsPerDeployment')), variables('deploymentSuffix'))]",
                  "properties": {
                    "expressionEvaluationOptions": {
                      "scope": "inner"
                    },
                    "mode": "Incremental",
                    "parameters": {
                      "artifactsContainerUri": {
                        "value": "[[parameters('artifactsContainerUri')]"
                      },
                      "artifactsUserAssignedIdentityResourceId": {
                        "value": "[[parameters('artifactsUserAssignedIdentityResourceId')]"
                      },
                      "artifactsUserAssignedIdentityClientId": "[[if(empty(parameters('artifactsUserAssignedIdentityResourceId')), createObject('value', ''), createObject('value', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('artifactsUserAssignedIdentityResourceId'), '/')[2], split(parameters('artifactsUserAssignedIdentityResourceId'), '/')[4]), 'Microsoft.ManagedIdentity/userAssignedIdentities', last(split(parameters('artifactsUserAssignedIdentityResourceId'), '/'))), '2018-11-30').clientId))]",
                      "availability": {
                        "value": "[[parameters('availability')]"
                      },
                      "availabilityZones": {
                        "value": "[[parameters('availabilityZones')]"
                      },
                      "availabilitySetNameConv": {
                        "value": "[[variables('avSetNameConv')]"
                      },
                      "avdInsightsDataCollectionRulesResourceId": {
                        "value": "[[parameters('avdInsightsDataCollectionRulesResourceId')]"
                      },
                      "confidentialVMOSDiskEncryptionType": {
                        "value": "[[variables('confidentialVMOSDiskEncryptionType')]"
                      },
                      "dataCollectionEndpointResourceId": {
                        "value": "[[parameters('dataCollectionEndpointResourceId')]"
                      },
                      "dedicatedHostGroupResourceIds": {
                        "value": "[[parameters('dedicatedHostGroupResourceIds')]"
                      },
                      "dedicatedHostResourceIds": {
                        "value": "[[parameters('dedicatedHostResourceIds')]"
                      },
                      "preferredZones": {
                        "value": "[[parameters('preferredZones')]"
                      },
                      "deploymentSuffix": {
                        "value": "[[variables('deploymentSuffix')]"
                      },
                      "diskEncryptionSetResourceId": {
                        "value": "[[parameters('diskEncryptionSetResourceId')]"
                      },
                      "diskSizeGB": {
                        "value": "[[parameters('diskSizeGB')]"
                      },
                      "diskSku": {
                        "value": "[[parameters('diskSku')]"
                      },
                      "domainJoinUserPassword": "[[if(not(empty(parameters('domainName'))), createObject('reference', createObject('keyVault', createObject('id', extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('credentialsKeyVaultResourceId'), '/')[2], split(parameters('credentialsKeyVaultResourceId'), '/')[4]), 'Microsoft.KeyVault/vaults', last(split(parameters('credentialsKeyVaultResourceId'), '/')))), 'secretName', 'DomainJoinUserPassword')), createObject('value', ''))]",
                      "domainJoinUserPrincipalName": "[[if(not(empty(parameters('domainName'))), createObject('reference', createObject('keyVault', createObject('id', extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('credentialsKeyVaultResourceId'), '/')[2], split(parameters('credentialsKeyVaultResourceId'), '/')[4]), 'Microsoft.KeyVault/vaults', last(split(parameters('credentialsKeyVaultResourceId'), '/')))), 'secretName', 'DomainJoinUserPrincipalName')), createObject('value', ''))]",
                      "domainName": {
                        "value": "[[parameters('domainName')]"
                      },
                      "enableAcceleratedNetworking": {
                        "value": "[[parameters('enableAcceleratedNetworking')]"
                      },
                      "enableIPv6": {
                        "value": "[[parameters('enableIPv6')]"
                      },
                      "enableMonitoring": {
                        "value": "[[parameters('enableMonitoring')]"
                      },
                      "encryptionAtHost": {
                        "value": "[[parameters('encryptionAtHost')]"
                      },
                      "hasAmdGpu": {
                        "value": "[[variables('hasAmdGpu')]"
                      },
                      "hasNvidiaGpu": {
                        "value": "[[variables('hasNvidiaGpu')]"
                      },
                      "fslogixConfigureSessionHosts": {
                        "value": "[[parameters('fslogixConfigureSessionHosts')]"
                      },
                      "fslogixContainerType": {
                        "value": "[[parameters('fslogixContainerType')]"
                      },
                      "fslogixFileShareNames": {
                        "value": "[[variables('fslogixFileShareNames')]"
                      },
                      "fslogixOSSGroups": {
                        "value": "[[parameters('fslogixOSSGroups')]"
                      },
                      "fslogixLocalNetAppServerFqdns": "[[if(and(parameters('fslogixConfigureSessionHosts'), not(empty(parameters('fslogixLocalNetAppVolumeResourceIds')))), createObject('value', reference(resourceId('Microsoft.Resources/deployments', format('shr-netAppVolumeFqdns-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.localNetAppVolumeSmbServerFqdns.value), createObject('value', createArray()))]",
                      "fslogixLocalStorageAccountResourceIds": {
                        "value": "[[parameters('fslogixLocalStorageAccountResourceIds')]"
                      },
                      "fslogixRemoteNetAppServerFqdns": "[[if(and(parameters('fslogixConfigureSessionHosts'), not(empty(parameters('fslogixRemoteNetAppVolumeResourceIds')))), createObject('value', reference(resourceId('Microsoft.Resources/deployments', format('shr-netAppVolumeFqdns-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.remoteNetAppVolumeSmbServerFqdns.value), createObject('value', createArray()))]",
                      "fslogixRemoteStorageAccountResourceIds": {
                        "value": "[[parameters('fslogixRemoteStorageAccountResourceIds')]"
                      },
                      "fslogixSizeInMBs": {
                        "value": "[[parameters('fslogixSizeInMBs')]"
                      },
                      "fslogixStorageService": {
                        "value": "[[parameters('fslogixStorageService')]"
                      },
                      "hostPoolResourceId": {
                        "value": "[[parameters('hostPoolResourceId')]"
                      },
                      "identitySolution": {
                        "value": "[[parameters('identitySolution')]"
                      },
                      "imageReference": {
                        "value": "[[parameters('imageReference')]"
                      },
                      "integrityMonitoring": {
                        "value": "[[parameters('integrityMonitoring')]"
                      },
                      "intuneEnrollment": {
                        "value": "[[parameters('intuneEnrollment')]"
                      },
                      "location": {
                        "value": "[[parameters('location')]"
                      },
                      "networkInterfaceNameConv": {
                        "value": "[[parameters('networkInterfaceNameConv')]"
                      },
                      "osDiskNameConv": {
                        "value": "[[parameters('osDiskNameConv')]"
                      },
                      "ouPath": {
                        "value": "[[parameters('ouPath')]"
                      },
                      "sessionHostCustomizations": {
                        "value": "[[parameters('sessionHostCustomizations')]"
                      },
                      "secureBootEnabled": {
                        "value": "[[parameters('secureBootEnabled')]"
                      },
                      "securityType": {
                        "value": "[[parameters('securityType')]"
                      },
                      "sessionHostNameIndexLength": {
                        "value": "[[parameters('sessionHostNameIndexLength')]"
                      },
                      "sessionHostNames": "[[if(and(equals(range(1, variables('sessionHostBatchCount'))[copyIndex()], variables('sessionHostBatchCount')), greater(variables('divisionRemainderValue'), 0)), createObject('value', take(skip(parameters('sessionHostNames'), mul(sub(range(1, variables('sessionHostBatchCount'))[copyIndex()], 1), variables('maxVMsPerDeployment'))), variables('divisionRemainderValue'))), createObject('value', take(skip(parameters('sessionHostNames'), mul(sub(range(1, variables('sessionHostBatchCount'))[copyIndex()], 1), variables('maxVMsPerDeployment'))), variables('maxVMsPerDeployment'))))]",
                      "sessionHostRegistrationDSCUrl": {
                        "value": "[[variables('sessionHostRegistrationDSCUrl')]"
                      },
                      "subnetResourceId": {
                        "value": "[[parameters('subnetResourceId')]"
                      },
                      "tags": {
                        "value": "[[parameters('tags')]"
                      },
                      "timestamp": {
                        "value": "[[variables('deploymentSuffix')]"
                      },
                      "timeZone": {
                        "value": "[[parameters('timeZone')]"
                      },
                      "virtualMachineAdminPassword": {
                        "reference": {
                          "keyVault": {
                            "id": "[[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('credentialsKeyVaultResourceId'), '/')[2], split(parameters('credentialsKeyVaultResourceId'), '/')[4]), 'Microsoft.KeyVault/vaults', last(split(parameters('credentialsKeyVaultResourceId'), '/')))]"
                          },
                          "secretName": "VirtualMachineAdminPassword"
                        }
                      },
                      "virtualMachineAdminUserName": {
                        "reference": {
                          "keyVault": {
                            "id": "[[extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('credentialsKeyVaultResourceId'), '/')[2], split(parameters('credentialsKeyVaultResourceId'), '/')[4]), 'Microsoft.KeyVault/vaults', last(split(parameters('credentialsKeyVaultResourceId'), '/')))]"
                          },
                          "secretName": "VirtualMachineAdminUserName"
                        }
                      },
                      "virtualMachineNameConv": {
                        "value": "[[parameters('virtualMachineNameConv')]"
                      },
                      "virtualMachineSize": {
                        "value": "[[parameters('virtualMachineSize')]"
                      },
                      "vmInsightsDataCollectionRulesResourceId": {
                        "value": "[[parameters('vmInsightsDataCollectionRulesResourceId')]"
                      },
                      "vTpmEnabled": {
                        "value": "[[parameters('vTpmEnabled')]"
                      }
                    },
                    "template": {
                      "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                      "contentVersion": "1.0.0.0",
                      "metadata": {
                        "_generator": {
                          "name": "bicep",
                          "version": "0.39.26.7824",
                          "templateHash": "7756541200620846732"
                        }
                      },
                      "parameters": {
                        "artifactsContainerUri": {
                          "type": "string"
                        },
                        "artifactsUserAssignedIdentityClientId": {
                          "type": "string"
                        },
                        "artifactsUserAssignedIdentityResourceId": {
                          "type": "string"
                        },
                        "availability": {
                          "type": "string"
                        },
                        "availabilitySetNameConv": {
                          "type": "string"
                        },
                        "availabilityZones": {
                          "type": "array"
                        },
                        "avdInsightsDataCollectionRulesResourceId": {
                          "type": "string"
                        },
                        "confidentialVMOSDiskEncryptionType": {
                          "type": "string"
                        },
                        "dataCollectionEndpointResourceId": {
                          "type": "string"
                        },
                        "dedicatedHostGroupResourceIds": {
                          "type": "array"
                        },
                        "dedicatedHostResourceIds": {
                          "type": "array"
                        },
                        "preferredZones": {
                          "type": "array"
                        },
                        "diskEncryptionSetResourceId": {
                          "type": "string"
                        },
                        "diskSizeGB": {
                          "type": "int"
                        },
                        "diskSku": {
                          "type": "string"
                        },
                        "domainJoinUserPassword": {
                          "type": "securestring"
                        },
                        "domainJoinUserPrincipalName": {
                          "type": "securestring"
                        },
                        "domainName": {
                          "type": "string"
                        },
                        "enableAcceleratedNetworking": {
                          "type": "bool"
                        },
                        "enableIPv6": {
                          "type": "bool"
                        },
                        "enableMonitoring": {
                          "type": "bool"
                        },
                        "encryptionAtHost": {
                          "type": "bool"
                        },
                        "fslogixConfigureSessionHosts": {
                          "type": "bool"
                        },
                        "fslogixContainerType": {
                          "type": "string"
                        },
                        "fslogixFileShareNames": {
                          "type": "array"
                        },
                        "fslogixLocalNetAppServerFqdns": {
                          "type": "array"
                        },
                        "fslogixLocalStorageAccountResourceIds": {
                          "type": "array"
                        },
                        "fslogixOSSGroups": {
                          "type": "array"
                        },
                        "fslogixRemoteNetAppServerFqdns": {
                          "type": "array"
                        },
                        "fslogixRemoteStorageAccountResourceIds": {
                          "type": "array"
                        },
                        "fslogixSizeInMBs": {
                          "type": "int"
                        },
                        "fslogixStorageService": {
                          "type": "string"
                        },
                        "hostPoolResourceId": {
                          "type": "string"
                        },
                        "identitySolution": {
                          "type": "string"
                        },
                        "imageReference": {
                          "type": "object"
                        },
                        "integrityMonitoring": {
                          "type": "bool"
                        },
                        "intuneEnrollment": {
                          "type": "bool"
                        },
                        "location": {
                          "type": "string"
                        },
                        "networkInterfaceNameConv": {
                          "type": "string"
                        },
                        "osDiskNameConv": {
                          "type": "string"
                        },
                        "ouPath": {
                          "type": "string"
                        },
                        "sessionHostCustomizations": {
                          "type": "array"
                        },
                        "sessionHostNameIndexLength": {
                          "type": "int"
                        },
                        "sessionHostNames": {
                          "type": "array"
                        },
                        "sessionHostRegistrationDSCUrl": {
                          "type": "string"
                        },
                        "securityType": {
                          "type": "string"
                        },
                        "secureBootEnabled": {
                          "type": "bool"
                        },
                        "subnetResourceId": {
                          "type": "string"
                        },
                        "timestamp": {
                          "type": "string",
                          "defaultValue": "[[utcNow()]"
                        },
                        "tags": {
                          "type": "object"
                        },
                        "deploymentSuffix": {
                          "type": "string"
                        },
                        "timeZone": {
                          "type": "string"
                        },
                        "virtualMachineAdminPassword": {
                          "type": "securestring"
                        },
                        "virtualMachineAdminUserName": {
                          "type": "securestring"
                        },
                        "virtualMachineNameConv": {
                          "type": "string"
                        },
                        "virtualMachineSize": {
                          "type": "string"
                        },
                        "vmInsightsDataCollectionRulesResourceId": {
                          "type": "string"
                        },
                        "vTpmEnabled": {
                          "type": "bool"
                        },
                        "hasAmdGpu": {
                          "type": "bool"
                        },
                        "hasNvidiaGpu": {
                          "type": "bool"
                        }
                      },
                      "variables": {
                        "[string('copy')]": [
                          {
                            "name": "vmNumbers",
                            "count": "[[length(parameters('sessionHostNames'))]",
                            "input": "[[int(substring(parameters('sessionHostNames')[copyIndex('vmNumbers')], sub(length(parameters('sessionHostNames')[copyIndex('vmNumbers')]), parameters('sessionHostNameIndexLength')), parameters('sessionHostNameIndexLength')))]"
                          },
                          {
                            "name": "fslogixLocalStorageAccountNames",
                            "count": "[[length(parameters('fslogixLocalStorageAccountResourceIds'))]",
                            "input": "[[last(split(parameters('fslogixLocalStorageAccountResourceIds')[copyIndex('fslogixLocalStorageAccountNames')], '/'))]"
                          },
                          {
                            "name": "fslogixRemoteStorageAccountNames",
                            "count": "[[length(parameters('fslogixRemoteStorageAccountResourceIds'))]",
                            "input": "[[last(split(parameters('fslogixRemoteStorageAccountResourceIds')[copyIndex('fslogixRemoteStorageAccountNames')], '/'))]"
                          },
                          {
                            "name": "networkInterfaceNames",
                            "count": "[[length(range(0, variables('sessionHostCount')))]",
                            "input": "[[if(empty(parameters('networkInterfaceNameConv')), parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex('networkInterfaceNames')]], replace(parameters('networkInterfaceNameConv'), 'SHNAME', parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex('networkInterfaceNames')]]))]"
                          },
                          {
                            "name": "virtualMachineNames",
                            "count": "[[length(range(0, variables('sessionHostCount')))]",
                            "input": "[[if(empty(parameters('virtualMachineNameConv')), parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex('virtualMachineNames')]], replace(parameters('virtualMachineNameConv'), 'SHNAME', parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex('virtualMachineNames')]]))]"
                          },
                          {
                            "name": "osDiskNames",
                            "count": "[[length(range(0, variables('sessionHostCount')))]",
                            "input": "[[if(empty(parameters('osDiskNameConv')), null(), replace(parameters('osDiskNameConv'), 'SHNAME', parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex('osDiskNames')]]))]"
                          }
                        ],
                        "$fxv#0": "[CmdletBinding(SupportsShouldProcess = $true)]\r\nparam (\r\n    [string]$AmdVmSize,\r\n    [string]$NvidiaVmSize,\r\n    [string]$DisableUpdates,\r\n    [string]$ConfigureFSLogix,\r\n    [string]$CloudCache = 'false',\r\n    [string]$IdentitySolution,\r\n    [string]$LocalNetAppServers,\r\n    [string]$LocalStorageAccountNames,\r\n    [string]$LocalStorageAccountKeys,\r\n    [string]$OSSGroups,\r\n    [string]$RemoteNetAppServers,\r\n    [string]$RemoteStorageAccountNames,\r\n    [string]$RemoteStorageAccountKeys,\r\n    [string]$Shares,\r\n    [string]$SizeInMBs,\r\n    [string]$StorageAccountDNSSuffix,\r\n    [string]$StorageService,\r\n    [string]$TimeZone\r\n)\r\n\r\n#region Functions\r\n\r\nfunction New-Log {\r\n    Param (\r\n        [Parameter(Mandatory = $true, Position = 0)]\r\n        [string] $Path\r\n    )\r\n\r\n    $date = Get-Date -UFormat \"%Y-%m-%d %H-%M-%S\"\r\n    Set-Variable logFile -Scope Script\r\n    $script:logFile = \"$Script:Name-$date.log\"\r\n\r\n    if ((Test-Path $path ) -eq $false) {\r\n        $null = New-Item -Path $path -type directory\r\n    }\r\n\r\n    $script:Log = Join-Path $path $logfile\r\n\r\n    Add-Content $script:Log \"Date`t`t`tCategory`t`tDetails\"\r\n}\r\n\r\nfunction Write-Log {\r\n    Param (\r\n        [Parameter(Mandatory = $false, Position = 0)]\r\n        [ValidateSet(\"Info\", \"Warning\", \"Error\")]\r\n        $Category = 'Info',\r\n        [Parameter(Mandatory = $true, Position = 1)]\r\n        $Message\r\n    )\r\n\r\n    $Date = get-date\r\n    $Content = \"[$Date]`t$Category`t`t$Message`n\" \r\n    Add-Content $Script:Log $content -ErrorAction Stop\r\n    If ($Verbose) {\r\n        Write-Verbose $Content\r\n    }\r\n    Else {\r\n        Switch ($Category) {\r\n            'Info' { Write-Host $content }\r\n            'Error' { Write-Error $Content }\r\n            'Warning' { Write-Warning $Content }\r\n        }\r\n    }\r\n}\r\n\r\nFunction ConvertFrom-JsonString {\r\n    [CmdletBinding()]\r\n    param (\r\n        [string]$JsonString,\r\n        [string]$Name,\r\n        [switch]$SensitiveValues      \r\n    )\r\n    If ($JsonString -ne '[]' -and $JsonString -ne $null) {\r\n        [array]$Array = $JsonString.replace('\\', '') | ConvertFrom-Json\r\n        If ($Array.Length -gt 0) {\r\n            If ($SensitiveValues) { Write-Log -message \"Array '$Name' has $($Array.Length) members\" } Else { Write-Log -message \"$($Name): '$($Array -join \"', '\")'\" }\r\n            Return $Array\r\n        }\r\n        Else {\r\n            Return $null\r\n        }            \r\n    }\r\n    Else {\r\n        Return $null\r\n    }    \r\n}\r\n\r\nFunction Convert-GroupToSID {\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string]$DomainName,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [string]$GroupName\r\n    )\r\n    Begin {\r\n        [string]$groupSID = ''\r\n    }\r\n    Process {\r\n        Try {\r\n            $groupSID = (New-Object System.Security.Principal.NTAccount(\"$GroupName\")).Translate([System.Security.Principal.SecurityIdentifier]).Value\r\n        }\r\n        Catch {\r\n            Try {\r\n                $groupSID = (New-Object System.Security.Principal.NTAccount($DomainName, \"$GroupName\")).Translate([System.Security.Principal.SecurityIdentifier]).Value\r\n            }\r\n            Catch {\r\n                Write-Error -Message \"Failed to convert group name '$GroupName' to SID.\"\r\n            }\r\n        }\r\n        Write-Output -InputObject $groupSID\r\n    }\r\n}\r\n\r\nFunction Get-InstalledApplication {\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Parameter(Mandatory = $false)]\r\n        [ValidateNotNullorEmpty()]\r\n        [string[]]$Name,\r\n        [Parameter(Mandatory = $false)]\r\n        [ValidateNotNullorEmpty()]\r\n        [string]$ProductCode\r\n    )\r\n\r\n    Begin {\r\n        [string[]]$regKeyApplications = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall', 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall'\r\n    }\r\n    Process { \r\n        ## Enumerate the installed applications from the registry for applications that have the \"DisplayName\" property\r\n        [psobject[]]$regKeyApplication = @()\r\n        ForEach ($regKey in $regKeyApplications) {\r\n            If (Test-Path -LiteralPath $regKey -ErrorAction 'SilentlyContinue' -ErrorVariable '+ErrorUninstallKeyPath') {\r\n                [psobject[]]$UninstallKeyApps = Get-ChildItem -LiteralPath $regKey -ErrorAction 'SilentlyContinue' -ErrorVariable '+ErrorUninstallKeyPath'\r\n                ForEach ($UninstallKeyApp in $UninstallKeyApps) {\r\n                    Try {\r\n                        [psobject]$regKeyApplicationProps = Get-ItemProperty -LiteralPath $UninstallKeyApp.PSPath -ErrorAction 'Stop'\r\n                        If ($regKeyApplicationProps.DisplayName) { [psobject[]]$regKeyApplication += $regKeyApplicationProps }\r\n                    }\r\n                    Catch {\r\n                        Continue\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        ## Create a custom object with the desired properties for the installed applications and sanitize property details\r\n        [psobject[]]$installedApplication = @()\r\n        ForEach ($regKeyApp in $regKeyApplication) {\r\n            Try {\r\n                [string]$appDisplayName = ''\r\n                [string]$appDisplayVersion = ''\r\n                [string]$appPublisher = ''\r\n\r\n                ## Bypass any updates or hotfixes\r\n                If (($regKeyApp.DisplayName -match '(?i)kb\\d+') -or ($regKeyApp.DisplayName -match 'Cumulative Update') -or ($regKeyApp.DisplayName -match 'Security Update') -or ($regKeyApp.DisplayName -match 'Hotfix')) {\r\n                    Continue\r\n                }\r\n\r\n                ## Remove any control characters which may interfere with logging and creating file path names from these variables\r\n                $appDisplayName = $regKeyApp.DisplayName -replace '[^\\u001F-\\u007F]', ''\r\n                $appDisplayVersion = $regKeyApp.DisplayVersion -replace '[^\\u001F-\\u007F]', ''\r\n                $appPublisher = $regKeyApp.Publisher -replace '[^\\u001F-\\u007F]', ''\r\n\r\n                ## Determine if application is a 64-bit application\r\n                [boolean]$Is64BitApp = If (($is64Bit) -and ($regKeyApp.PSPath -notmatch '^Microsoft\\.PowerShell\\.Core\\\\Registry::HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Wow6432Node')) { $true } Else { $false }\r\n\r\n                If ($ProductCode) {\r\n                    ## Verify if there is a match with the product code passed to the script\r\n                    If ($regKeyApp.PSChildName -match [regex]::Escape($productCode)) {\r\n                        $installedApplication += New-Object -TypeName 'PSObject' -Property @{\r\n                            UninstallSubkey    = $regKeyApp.PSChildName\r\n                            ProductCode        = If ($regKeyApp.PSChildName -match $MSIProductCodeRegExPattern) { $regKeyApp.PSChildName } Else { [string]::Empty }\r\n                            DisplayName        = $appDisplayName\r\n                            DisplayVersion     = $appDisplayVersion\r\n                            UninstallString    = $regKeyApp.UninstallString\r\n                            InstallSource      = $regKeyApp.InstallSource\r\n                            InstallLocation    = $regKeyApp.InstallLocation\r\n                            InstallDate        = $regKeyApp.InstallDate\r\n                            Publisher          = $appPublisher\r\n                            Is64BitApplication = $Is64BitApp\r\n                        }\r\n                    }\r\n                }\r\n\r\n                If ($name) {\r\n                    ## Verify if there is a match with the application name(s) passed to the script\r\n                    ForEach ($application in $Name) {\r\n                        $applicationMatched = $false\r\n                        #  Check for a contains application name match\r\n                        If ($regKeyApp.DisplayName -match [regex]::Escape($application)) {\r\n                            $applicationMatched = $true\r\n                        }\r\n\r\n                        If ($applicationMatched) {\r\n                            $installedApplication += New-Object -TypeName 'PSObject' -Property @{\r\n                                UninstallSubkey    = $regKeyApp.PSChildName\r\n                                ProductCode        = If ($regKeyApp.PSChildName -match $MSIProductCodeRegExPattern) { $regKeyApp.PSChildName } Else { [string]::Empty }\r\n                                DisplayName        = $appDisplayName\r\n                                DisplayVersion     = $appDisplayVersion\r\n                                UninstallString    = $regKeyApp.UninstallString\r\n                                InstallSource      = $regKeyApp.InstallSource\r\n                                InstallLocation    = $regKeyApp.InstallLocation\r\n                                InstallDate        = $regKeyApp.InstallDate\r\n                                Publisher          = $appPublisher\r\n                                Is64BitApplication = $Is64BitApp\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            Catch {\r\n                Continue\r\n            }\r\n        }\r\n        Write-Output -InputObject $installedApplication\r\n    }\r\n}\r\n\r\nFunction Set-RegistryValue {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter()]\r\n        [string]\r\n        $Name,\r\n        [Parameter()]\r\n        [string]\r\n        $Path,\r\n        [Parameter()]\r\n        [string]$PropertyType,\r\n        [Parameter()]\r\n        $Value\r\n    )\r\n    Begin {\r\n        Write-Log -message \"[Set-RegistryValue]: Setting Registry Value: $Name\"\r\n    }\r\n    Process {\r\n        # Create the registry Key(s) if necessary.\r\n        If (!(Test-Path -Path $Path)) {\r\n            Write-Log -message \"[Set-RegistryValue]: Creating Registry Key: $Path\"\r\n            New-Item -Path $Path -Force | Out-Null\r\n        }\r\n        # Check for existing registry setting\r\n        $RemoteValue = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue\r\n        If ($RemoteValue) {\r\n            # Get current Value\r\n            $CurrentValue = Get-ItemPropertyValue -Path $Path -Name $Name\r\n            Write-Log -message \"[Set-RegistryValue]: Current Value of $($Path)\\$($Name) : $CurrentValue\"\r\n            If ($Value -ne $CurrentValue) {\r\n                Write-Log -message \"[Set-RegistryValue]: Setting Value of $($Path)\\$($Name) : $Value\"\r\n                Set-ItemProperty -Path $Path -Name $Name -Value $Value -Force | Out-Null\r\n            }\r\n            Else {\r\n                Write-Log -message \"[Set-RegistryValue]: Value of $($Path)\\$($Name) is already set to $Value\"\r\n            }           \r\n        }\r\n        Else {\r\n            Write-Log -message \"[Set-RegistryValue]: Setting Value of $($Path)\\$($Name) : $Value\"\r\n            New-ItemProperty -Path $Path -Name $Name -PropertyType $PropertyType -Value $Value -Force | Out-Null\r\n        }\r\n        Start-Sleep -Milliseconds 500\r\n    }\r\n    End {\r\n    }\r\n}\r\n\r\n#endregion Functions\r\n$Script:Name = 'Set-SessionHostConfiguration'\r\n# from https://learn.microsoft.com/en-us/microsoftteams/new-teams-vdi-requirements-deploy#recommended-for-exclusion\r\n# only specifying the folders that do not affect performance per article\r\n$redirectionsXMLStart = @'\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<FrxProfileFolderRedirection ExcludeCommonFolders=\"0\">\r\n<Excludes>\r\n'@\r\n$redirectionsXMLExcludesTeams = @'\r\n<Exclude Copy=\"0\">AppData\\Local\\Packages\\MSTeams_8wekyb3d8bbwe\\LocalCache\\Microsoft\\MSTeams\\Logs</Exclude>\r\n<Exclude Copy=\"0\">AppData\\Local\\Packages\\MSTeams_8wekyb3d8bbwe\\LocalCache\\Microsoft\\MSTeams\\PerfLog</Exclude>\r\n<Exclude Copy=\"0\">AppData\\Local\\Packages\\MSTeams_8wekyb3d8bbwe\\LocalCache\\Microsoft\\MSTeams\\EBWebView\\WV2Profile_tfw\\GPUCache</Exclude>\r\n<Exclude Copy=\"0\">AppData\\Local\\Packages\\Microsoft.Windows.StartMenuExperienceHost_cw5n1h2txyewy\\TempState</Exclude>\r\n'@\r\n$redirectionsXMLExcludesAzCLI = @'\r\n<Exclude Copy=\"0\">.Azure</Exclude>\r\n'@\r\n$redirectionsXMLEnd = @'\r\n</Excludes>\r\n<Includes>\r\n</Includes>\r\n</FrxProfileFolderRedirection>\r\n'@\r\n\r\nNew-Log -Path (Join-Path -Path $env:SystemRoot -ChildPath 'Logs')\r\nwrite-log -message \"*** Parameter Values ***\"\r\nWrite-Log -message \"AmdVmSize: $AmdVmSize\"\r\nWrite-Log -message \"NvidiaVmSize: $NvidiaVmSize\"\r\nWrite-Log -message \"DisableUpdates: $DisableUpdates\"\r\n[bool]$ConfigureFSLogix = [System.Convert]::ToBoolean($ConfigureFSLogix)\r\nWrite-Log -message \"ConfigureFSLogix: $ConfigureFSLogix\"\r\nif ($ConfigureFSLogix) {\r\n    Write-Log -message \"IdentitySolution: $IdentitySolution\" \r\n    #Convert CloudCache to Boolean\r\n    $CloudCache = [System.Convert]::ToBoolean($CloudCache)\r\n    Write-Log -message \"CloudCache: $CloudCache\"\r\n    #Convert Shares to Array\r\n    [array]$Shares = ConvertFrom-JsonString -JsonString $Shares -Name 'Shares'\r\n    $ProfileShareName = $Shares[0]\r\n    if ($Shares.Count -gt 1) {\r\n        $OfficeShareName = $Shares[1]\r\n    }\r\n    Else {\r\n        $OfficeShareName = $null\r\n    }\r\n\r\n    Write-Log -message \"ProfileShareName: $ProfileShareName\"\r\n    Write-Log -message \"OfficeShareName: $OfficeShareName\"\r\n    Write-Log -message \"StorageService: $StorageService\"\r\n    if ($SizeInMBs -ne '' -and $null -ne $SizeInMBs) {\r\n        [int]$SizeInMBs = $SizeInMBs\r\n        Write-Log -message \"SizeInMBs: $SizeInMBs\"\r\n    }\r\n    Else {\r\n        [int]$SizeInMBs = 30000\r\n        Write-Log -message \"SizeInMBs not specified. Defaulting to: $SizeInMBs\"\r\n    } \r\n}\r\n\r\nWrite-Log -message \"TimeZone: $TimeZone\"\r\n\r\nWrite-Log -message \"Configuring Time Zone to: $TimeZone\"\r\nSet-TimeZone -Id \"$TimeZone\"\r\n\r\nWrite-Log -message \"*** Building Array of Registry Settings ***\"\r\n$RegSettings = New-Object System.Collections.ArrayList\r\nIf ($DisableUpdates -eq 'true') {\r\n    # Disable Automatic Updates: https://learn.microsoft.com/azure/virtual-desktop/set-up-customize-master-image#disable-automatic-updates\r\n    $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU'; Name = 'NoAutoUpdate'; PropertyType = 'DWORD'; Value = 1 })\r\n    # Disable Edge Updates : https://learn.microsoft.com/en-us/deployedge/microsoft-edge-update-policies#updatedefault\r\n    $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\EdgeUpdate'; Name = 'UpdateDefault'; PropertyType = 'DWORD'; Value = 0 })\r\n    # Set the OneDrive Update Ring to Deferred: https://learn.microsoft.com/en-us/sharepoint/use-group-policy#set-the-sync-app-update-ring\r\n    $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\OneDrive'; Name = 'GPOSetUpdateRing'; PropertyType = 'DWORD'; Value = 0 })\r\n    If (Get-InstalledApplication -Name 'Microsoft 365 Apps') {\r\n        # Disable Office Automatic Updates: https://learn.microsoft.com/azure/virtual-desktop/set-up-customize-master-image#disable-office-automatic-updates\r\n        $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\office\\16.0\\common\\officeupdate'; Name = 'hideupdatenotifications'; PropertyType = 'DWORD'; Value = 1 })\r\n        $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\office\\16.0\\common\\officeupdate'; Name = 'hideenabledisableupdates'; PropertyType = 'DWORD'; Value = 1 })\r\n    }\r\n    If ($TeamsInstalled) {\r\n        # Disable Teams Auto-Update: https://learn.microsoft.com/en-us/microsoftteams/new-teams-vdi-requirements-deploy#disable-new-teams-autoupdate-in-non-persistent-vdi\r\n        $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Microsoft\\Teams'; Name = 'disableAutoUpdate'; PropertyType = 'DWORD'; Value = 1 })\r\n    }\r\n}\r\n# Enable Time Zone Redirection: https://learn.microsoft.com/azure/virtual-desktop/set-up-customize-master-image#set-up-time-zone-redirection\r\n$RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services'; Name = 'fEnableTimeZoneRedirection'; PropertyType = 'DWORD'; Value = 1 })\r\n\r\n##############################################################\r\n#  Add GPU Settings\r\n##############################################################\r\n# This setting applies to the VM Size's recommended for AVD with a GPU\r\nif ($AmdVmSize -eq 'true' -or $NvidiaVmSize -eq 'true') {\r\n    Write-Log -message \"Adding GPU Settings\"\r\n    # Configure GPU-accelerated app rendering: https://learn.microsoft.com/azure/virtual-desktop/configure-vm-gpu#configure-gpu-accelerated-app-rendering\r\n    $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services'; Name = 'bEnumerateHWBeforeSW'; PropertyType = 'DWORD'; Value = 1 })\r\n    # Configure fullscreen video encoding: https://learn.microsoft.com/azure/virtual-desktop/configure-vm-gpu#configure-fullscreen-video-encoding\r\n    $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services'; Name = 'AVC444ModePreferred'; PropertyType = 'DWORD'; Value = 1 })\r\n}\r\n\r\n# This setting applies only to VM Size's recommended for AVD with a Nvidia GPU\r\nif ($NvidiaVmSize -eq 'true') {\r\n    Write-Log -message \"Adding Nvidia GPU Settings\"\r\n    # Configure GPU-accelerated frame encoding: https://learn.microsoft.com/azure/virtual-desktop/configure-vm-gpu#configure-gpu-accelerated-frame-encoding\r\n    $RegSettings.Add(@{Path = 'HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services'; Name = 'AVChardwareEncodePreferred'; PropertyType = 'DWORD'; Value = 1 })\r\n}\r\n\r\nIf ($ConfigureFSLogix) {\r\n    $AzCLIInstalled = Get-InstalledApplication -Name 'Azure CLI'\r\n    $TeamsInstalled = Get-AppxProvisionedPackage -Online | Where-Object { $_.DisplayName -eq 'MSTeams' }\r\n    # Create Array Lists so it is easy to add them\r\n    [System.Collections.ArrayList]$LocalProfileContainerPaths = @()\r\n    [System.Collections.ArrayList]$LocalCloudCacheProfileContainerPaths = @()\r\n    [System.Collections.ArrayList]$LocalOfficeContainerPaths = @()\r\n    [System.Collections.ArrayList]$LocalCloudCacheOfficeContainerPaths = @()\r\n    [System.Collections.ArrayList]$RemoteProfileContainerPaths = @()\r\n    [System.Collections.ArrayList]$RemoteCloudCacheProfileContainerPaths = @()\r\n    [System.Collections.ArrayList]$RemoteOfficeContainerPaths = @()\r\n    [System.Collections.ArrayList]$RemoteCloudCacheOfficeContainerPaths = @()\r\n\r\n    switch ($StorageService) {\r\n        'AzureFiles' {\r\n            Write-Log -message \"Gathering Azure Files Storage Account Parameters\"\r\n            # Convert escaped JSON strings to arrays\r\n            [array]$OSSGroups = ConvertFrom-JsonString -JsonString $OSSGroups -Name 'OSSGroups'\r\n            [array]$LocalStorageAccountNames = ConvertFrom-JsonString -JsonString $LocalStorageAccountNames -Name 'LocalStorageAccountNames'\r\n            [array]$LocalStorageAccountKeys = ConvertFrom-JsonString -JsonString $LocalStorageAccountKeys -Name 'LocalStorageAccountKeys' -SensitiveValues\r\n            [array]$RemoteStorageAccountNames = ConvertFrom-JsonString -JsonString $RemoteStorageAccountNames -Name 'RemoteStorageAccountNames'\r\n            [array]$RemoteStorageAccountKeys = ConvertFrom-JsonString -JsonString $RemoteStorageAccountKeys -Name 'RemoteStorageAccountKeys' -SensitiveValues\r\n            \r\n            Write-Log -message \"*** Begin Processing Storage Accounts ***\"\r\n            # Local Storage Accounts\r\n            Write-Log -message \"Processing Local Storage Accounts\"\r\n            For ($i = 0; $i -lt $LocalStorageAccountNames.Count; $i++) {\r\n                $SAFQDN = \"$($LocalStorageAccountNames[$i]).file.$StorageAccountDNSSuffix\"\r\n                Write-Log -message \"LocalStorageAccountFQDN: '$SAFQDN'\"\r\n                If ($LocalStorageAccountKeys.Count -gt 0) {\r\n                    If ($LocalStorageAccountKeys[$i]) {\r\n                        Write-Log -message \"Adding Local Storage Account Key for '$SAFQDN' to Credential Manager\"\r\n                        Start-Process -FilePath 'cmdkey.exe' -ArgumentList \"/add:$SAFQDN /user:localhost\\$($LocalStorageAccountNames[$i]) /pass:$($LocalStorageAccountKeys[$i])\" -NoNewWindow -Wait\r\n                    }\r\n                }\r\n                If ($OfficeShareName) {\r\n                    $LocalOfficeContainerPaths.Add(\"\\\\$SAFQDN\\$OfficeShareName\")\r\n                    Write-Log -message \"LocalOfficeContainerPath: '\\\\$($SAFQDN)\\$($OfficeShareName)'\"                \r\n                    $LocalCloudCacheOfficeContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)\")\r\n                    Write-Log -message \"LocalCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)'\"\r\n                }\r\n                $LocalProfileContainerPaths.Add(\"\\\\$($SAFQDN)\\$($ProfileShareName)\")\r\n                Write-Log -message \"LocalProfileContainerPath: \\\\$($SAFQDN)\\$($ProfileShareName)\"\r\n                $LocalCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)\")\r\n                Write-Log -message \"LocalCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)'\"\r\n            }\r\n            # Remote / Existing Storage Accounts\r\n            If ($RemoteStorageAccountNames.Count -gt 0) {\r\n                Write-Log Info \"Processing Remote Storage Accounts\"\r\n                For ($i = 0; $i -lt $RemoteStorageAccountNames.Count; $i++) {\r\n                    $SAFQDN = \"$($RemoteStorageAccountNames[$i]).file.$StorageAccountDNSSuffix\"\r\n                    Write-Log -message \"RemoteStorageAccountFQDN: '$SAFQDN'\"\r\n                    If ($RemoteStorageAccountKeys.Count -gt 0) {\r\n                        If ($RemoteStorageAccountKeys[$i]) {\r\n                            Write-Log -message \"Adding Remote Storage Account Key for '$SAFQDN' to Credential Manager\"\r\n                            Start-Process -FilePath 'cmdkey.exe' -ArgumentList \"/add:$($SAFQDN) /user:localhost\\$($RemoteStorageAccountNames[$i]) /pass:$($RemoteStorageAccountKeys[$i])\" -NoNewWindow -Wait\r\n                        }\r\n                    }\r\n                    If ($OfficeShareName) {\r\n                        $RemoteOfficeContainerPaths.Add(\"\\\\$($SAFQDN)\\$($OfficeShareName)\")\r\n                        Write-Log -message \"RemoteOfficeContainerPath: '\\\\$($SAFQDN)\\$($OfficeShareName)'\"\r\n                        $RemoteCloudCacheOfficeContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)\")\r\n                        Write-Log -message \"RemoteCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)\"\r\n                    }\r\n                    $RemoteProfileContainerPaths.Add(\"\\\\$(SAFQDN)\\$(ProfileShareName)\")\r\n                    Write-Log -message \"RemoteProfileContainerPath: '\\\\$($SAFQDN)\\$(ProfileShareName)'\"\r\n                    $RemoteCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)\")\r\n                    Write-Log -message \"RemoteCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)'\"\r\n                }\r\n            }\r\n            Write-Log -message \"Done Adding UNC Paths to arrays.\"\r\n        }\r\n        'AzureNetAppFiles' {\r\n            Write-Log -message \"Gathering Azure NetApp Files Storage Account Parameters\"\r\n            # Convert escaped JSON strings to arrays\r\n            [array]$LocalNetAppServers = ConvertFrom-JsonString -JsonString $LocalNetAppServers -Name 'LocalNetAppServers'\r\n            [array]$RemoteNetAppServers = ConvertFrom-JsonString -JsonString $RemoteNetAppServers -Name 'RemoteNetAppServers' \r\n            Write-Log -message \"Processing Local Azure NetApp Servers\"        \r\n            $LocalProfileContainerPaths.Add(\"\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)\")\r\n            Write-Log -message \"LocalProfileContainerPath: '\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)'\"\r\n            $LocalCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)\")\r\n            Write-Log -message \"LocalCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)'\"\r\n            If ($LocalNetAppServers.Length -gt 1 -and $OfficeShareName) {            \r\n                $LocalOfficeContainerPaths.Add(\"\\\\$($LocalNetAppServers[1])\\$($OfficeShareName)\")\r\n                Write-Log -message \"LocalOfficeContainerPath: \\\\$($LocalNetAppServers[1])\\$($OfficeShareName)\"\r\n                $LocalCloudCacheOfficeContainerPaths.Add(\"type=smb,connectionString=\\\\$($LocalNetAppServers[1])\\$($OfficeShareName)\")\r\n                Write-Log -message \"LocalCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($LocalNetAppServers[1])\\$($OfficeShareName)'\"\r\n            }\r\n            \r\n            If ($RemoteNetAppServers.Count -gt 0) {\r\n                Write-Log -message \"Processing Remote Azure NetApp Servers\"\r\n                $RemoteProfileContainerPaths.Add(\"\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)\")\r\n                Write-Log -message \"RemoteProfileContainerPath: '\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)'\"\r\n                $RemoteCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)\")\r\n                Write-Log -message \"RemoteCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)\"\r\n                If ($RemoteNetAppShares.Length -gt 1 -and $OfficeShareName) {\r\n                    $RemoteOfficeContainerPaths.Add(\"\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)\")\r\n                    Write-Log -message \"RemoteOfficeContainerPath: '\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)'\"\r\n                    $RemoteCloudCacheOfficeContainers.Add(\"type=smb,connectionString=\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)\")\r\n                    Write-Log -message \"RemoteCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)'\"\r\n                }        \r\n            }\r\n        }\r\n    }\r\n\r\n    Write-Log -message \"Adding Common FSLogix Settings\"\r\n    # Cleans up an invalid sessions to enable a successful sign-in: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#cleanupinvalidsessions\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'CleanupInvalidSessions'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Apps'; PropertyType = 'DWord'; Value = 1 })\r\n    # Enables Fslogix profile containers: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#enabled\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'Enabled'; Path = 'HKLM:\\SOFTWARE\\Fslogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n    # Deletes a local profile if it exists and matches the profile being loaded from VHD: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#deletelocalprofilewhenvhdshouldapply\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'DeleteLocalProfileWhenVHDShouldApply'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n    # The folder created in the Fslogix fileshare will begin with the username instead of the SID: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#flipflopprofiledirectoryname\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'FlipFlopProfileDirectoryName'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n    # Prevent Login with a failure: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#preventloginwithfailure\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithFailure'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n    # Prevent Login with a temporary profile: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#preventloginwithtempprofile\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithTempProfile'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n    # Specifies the number of seconds to wait between retries when attempting to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#reattachintervalseconds\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachIntervalSeconds'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 15 })\r\n    # Specifies the number of times the system should attempt to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#reattachretrycount\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachRetryCount'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 3 })\r\n    # Specifies the maximum size of the user's container in megabytes. Newly created VHD(x) containers are of this size: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#sizeinmbs\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'SizeInMBs'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = $SizeInMBs })\r\n    # Specifies the file extension for the profile containers: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#volumetype\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'VolumeType'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'String'; Value = 'VHDX' })\r\n\r\n    If ($LocalStorageAccountKeys.Count -gt 0) {\r\n        Write-Log -message \"Adding AccessNetworkAsComputerObject for cloud only identities.\"\r\n        # Attach the users VHD(x) as the computer: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#accessnetworkascomputerobject\r\n        $RegSettings.Add([PSCustomObject]@{Name = 'AccessNetworkAsComputerObject'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n    }\r\n\r\n    if ($CloudCache -eq $True) {\r\n        Write-Log -message \"Adding Cloud Cache Settings\"\r\n        # Clear the cloud cache on logoff: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#clearcacheonlogoff\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'ClearCacheOnLogoff'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n    }\r\n\r\n    If ($LocalOfficeContainerPaths.Count -gt 0) {\r\n        Write-Log -message \"Adding Office Container Settings\"    \r\n        # Enables Fslogix office containers: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#enabled-1   \r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'Enabled'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })   \r\n        # The folder created in the Fslogix fileshare will begin with the username instead of the SID: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#flipflopprofiledirectoryname-1\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'FlipFlopProfileDirectoryName'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n        # Specifies the number of retries attempted when a VHD(x) file is locked: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#lockedretrycount\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'LockedRetryCount'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 3 })\r\n        # Specifies the number of seconds to wait between retries: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#lockedretryinterval\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'LockedRetryInterval'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 15 })\r\n        # Prevent Login with a failure: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#preventloginwithfailure-1\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithFailure'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n        # Prevent Login with Temporary Profile: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#preventloginwithtempprofile-1\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithTempProfile'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })    \r\n        # Specifies the number of seconds to wait between retries when attempting to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#reattachintervalseconds\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachIntervalSeconds'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 15 })\r\n        # Specifies the number of times the system should attempt to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#reattachretrycount\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachRetryCount'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 3 })\r\n        # Specifies the maximum size of the user's container in megabytes: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#sizeinmbs\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'SizeInMBs'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = $SizeInMBs })\r\n        # Specifies the type of container: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#volumetype\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'VolumeType'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'String'; Value = 'VHDX' })\r\n        If ($LocalStorageAccountKeys.Count -gt 0) {\r\n            Write-Log -message \"Adding AccessNetworkAsComputerObject for cloud only identities.\"\r\n            # Attach the users VHD(x) as the computer: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#accessnetworkascomputerobject-1\r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'AccessNetworkAsComputerObject'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n        }\r\n        If ($CloudCache -eq $True) {\r\n            Write-Log -message \"Adding Cloud Cache Settings\"\r\n            # Clear the cloud cache on logoff: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#clearcacheonlogoff\r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'ClearCacheOnLogoff'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n        }   \r\n    }\r\n\r\n    If ($OSSGroups.Count -gt 0) {\r\n        Write-Log -message \"Adding Object Specific Settings\"\r\n        # Object Specific Settings\r\n        $DomainName = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain\r\n        Write-Log -message \"DomainName: $DomainName\"\r\n        For ($i = 0; $i -lt $OSSGroups.Count; $i++) {\r\n            # Get Domain information\r\n            Write-Log -message \"Getting SID for $($OSSGroups[$i])\"        \r\n            $OSSGroupSID = Convert-GroupToSID -DomainName $DomainName -GroupName $OSSGroups[$i]\r\n            [string]$LocalProfileContainerPath = $LocalProfileContainerPaths[$i]\r\n            Write-Log -message \"LocalProfileContainerPath: '$LocalProfileContainerPath'\"\r\n            [string]$LocalCloudCacheProfileContainerPath = $LocalCloudCacheProfileContainerPaths[$i]\r\n            Write-Log -message \"LocalCloudCacheProfileContainerPath: '$LocalCloudCacheProfileContainerPath'\"\r\n\r\n            If ($RemoteStorageAccountNames) {\r\n                [string]$RemoteProfileContainerPath = $RemoteProfileContainerPaths[$i]\r\n                Write-Log -message \"RemoteProfileContainerPath: '$RemoteProfileContainerPath'\"\r\n                [string]$RemoteCloudCacheProfileContainerPath = $RemoteCloudCacheProfilePaths[$i]\r\n                Write-Log -message \"RemoteCloudCacheProfileContainerPath: '$RemoteCloudCacheProfileContainerPath'\"\r\n                [array]$ProfileContainerPaths = @($LocalProfileContainerPath + $RemoteProfileContainerPath)\r\n                [array]$CloudCacheProfileContainerPaths = @($LocalCloudCacheProfileContainerPath + $RemoteCloudCacheProfileContainerPath)\r\n            }\r\n            Else {\r\n                [array]$ProfileContainerPaths = @($LocalProfileContainerPath)\r\n                [array]$CloudCacheProfileContainerPaths = @($LocalCloudCacheProfileContainerPath)\r\n            }\r\n\r\n            If ($CloudCache -eq $True) {\r\n                Write-Log -message \"Adding Cloud Cache Profile Container Settings: $OSSGroupSID : '$($CloudCacheProfileContainerPaths -join \"', '\")'\"\r\n                # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations\r\n                $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = \"HKLM:\\SOFTWARE\\FSLogix\\Profiles\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $CloudCacheProfileContainerPaths })\r\n            }\r\n            Else {\r\n                Write-Log -message \"Adding Profile Container Settings: $OSSGroupSID : '$($ProfileContainerPaths -join \"', '\")'\"\r\n                # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#vhdlocations\r\n                $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = \"HKLM:\\SOFTWARE\\FSLogix\\Profiles\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $ProfileContainerPaths })\r\n            }   \r\n\r\n            If ($LocalOfficeContainerPaths.Count -gt 0) {\r\n                [string]$LocalOfficeContainerPath = $LocalOfficeContainerPaths[$i]\r\n                Write-Log -message \"LocalOfficeContainerPath: '$LocalOfficeContainerPath'\"\r\n                [string]$LocalCloudCacheOfficeContainerPath = $LocalCloudCacheOfficeContainerPaths[$i]\r\n                Write-Log -message \"LocalCloudCacheOfficeContainerPath: '$LocalCloudCacheOfficeContainerPath'\"\r\n                If ($RemoteStorageAccountNames) {\r\n                    [string]$RemoteOfficeContainerPath = $RemoteOfficeContainerPaths[$i]\r\n                    Write-Log -message \"RemoteOfficeContainerPath: '$RemoteOfficeContainerPath'\"\r\n                    [string]$RemoteCloudCacheOfficeContainerPath = $RemoteCloudCacheOfficePaths[$i]\r\n                    Write-Log -message \"RemoteCloudCacheOfficeContainerPath: '$RemoteCloudCacheOfficeContainerPath'\"\r\n                    [array]$OfficeContainerPaths = @($LocalOfficeContainerPath + $RemoteOfficeContainerPath)\r\n                    [array]$CloudCacheOfficeContainerPaths = @($LocalCloudCacheOfficeContainerPath + $RemoteCloudCacheOfficeContainerPath)\r\n                }\r\n                Else {\r\n                    [array]$OfficeContainerPaths = @($LocalOfficeContainerPath)\r\n                    [array]$CloudCacheOfficeContainerPaths = @($LocalCloudCacheOfficeContainerPath)\r\n                }\r\n                If ($CloudCache -eq $True) {\r\n                    Write-Log -message \"Adding Cloud Cache Office Container Settings: $OSSGroupSID : '$($CloudCacheOfficeContainerPaths -join \"', '\")'\"\r\n                    # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations\r\n                    $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = \"HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $CloudCacheOfficeContainerPaths })\r\n                }\r\n                Else {\r\n                    Write-Log -message \"Adding Office Container Settings: $OSSGroupSID : '$($OfficeContainerPaths -join \"', '\")'\"\r\n                    # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#vhdlocations-1\r\n                    $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = \"HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $OfficeContainerPaths })\r\n                }\r\n            }  \r\n        }          \r\n    }\r\n    Else {\r\n        If ($RemoteStorageAccountNames.Count -gt 0) {\r\n            $ProfileContainerPaths = $LocalProfileContainerPaths + $RemoteProfileContainerPaths\r\n            $CloudCacheProfileContainerPaths = $LocalCloudCacheProfileContainerPaths + $RemoteCloudCacheProfileContainerPaths\r\n        }\r\n        Else {\r\n            $ProfileContainerPaths = $LocalProfileContainerPaths\r\n            $CloudCacheProfileContainerPaths = $LocalCloudCacheProfileContainerPaths\r\n        }\r\n        If ($CloudCache -eq $True) {\r\n            Write-Log -message \"Adding Cloud Cache Profile Container Settings: '$($CloudCacheProfileContainerPaths -join \"', '\")'\"   \r\n            # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations \r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'MultiString'; Value = $CloudCacheProfileContainerPaths })             \r\n        }\r\n        Else {\r\n            Write-Log -message \"Adding Profile Container Settings: '$($ProfileContainerPaths -join \"', '\")'\"\r\n            # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#vhdlocations\r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'MultiString'; Value = $ProfileContainerPaths })\r\n        }\r\n        If ($LocalOfficeContainerPaths.Count -gt 0) {\r\n            If ($RemoteStorageAccountNames.Count -gt 0) {\r\n                $OfficeContainerPaths = $LocalOfficeContainerPaths + $RemoteOfficeContainerPaths\r\n                $CloudCacheOfficeContainerPaths = $LocalCloudCacheOfficeContainerPaths + $RemoteCloudCacheOfficeContainerPaths\r\n            }\r\n            Else {\r\n                $OfficeContainerPaths = $LocalOfficeContainerPaths\r\n                $CloudCacheOfficeContainerPaths = $LocalCloudCacheOfficeContainerPaths\r\n            }\r\n            If ($CloudCache -eq $True) {\r\n                Write-Log -message \"Adding Cloud Cache Office Container Settings: '$($CloudCacheOfficeContainerPaths -join \"', '\")'\"\r\n                # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations\r\n                $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'MultiString'; Value = $CloudCacheOfficeContainerPaths })\r\n            }\r\n            Else {\r\n                Write-Log -message \"Adding Office Container Settings: '$($OfficeContainerPaths -join \"', '\")'\"\r\n                # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#vhdlocations-1\r\n                $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'MultiString'; Value = $OfficeContainerPaths })\r\n            }\r\n        }    \r\n    }\r\n    If ($TeamsInstalled -or $AzCLIInstalled) {\r\n        $customRedirFolder = \"$env:ProgramData\\FSLogix_CustomRedirections\"\r\n        Write-Log -message \"Creating custom redirections.xml file in $customRedirFolder\"\r\n        If (-not (Test-Path $customRedirFolder )) {\r\n            New-Item -Path $customRedirFolder -ItemType Directory -Force\r\n        }\r\n        $customRedirFilePath = \"$customRedirFolder\\redirections.xml\"\r\n        $redirectionsXMLContent = $redirectionsXMLStart\r\n        if ($AzCLIInstalled) {\r\n            $redirectionsXMLContent = $redirectionsXMLContent + \"`n\" + $redirectionsXMLExcludesAzCLI\r\n        }\r\n        if ($TeamsInstalled) {\r\n            $redirectionsXMLContent = $redirectionsXMLContent + \"`n\" + $redirectionsXMLExcludesTeams\r\n        }\r\n        $redirectionsXMLContent = $redirectionsXMLContent + \"`n\" + $redirectionsXMLEnd\r\n        $redirectionsXMLContent | Out-File -FilePath $customRedirFilePath -Encoding unicode\r\n        # Path where FSLogix looks for the redirections.xml file to copy from and into the user's profile: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#redirxmlsourcefolder\r\n        \r\n        $RegSettings.Add(\r\n            [PSCustomObject]@{\r\n                Name         = 'RedirXMLSourceFolder'\r\n                Path         = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'\r\n                PropertyType = 'String'\r\n                Value        = $customRedirFolder\r\n            }\r\n        )\r\n    }\r\n    If ($IdentitySolution -match 'EntraKerberos') {\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'CloudKerberosTicketRetrievalEnabled'; Path = 'HKLM:\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Parameters'; PropertyType = 'DWord'; Value = 1})\r\n    }\r\n\r\n    # Windows Defender Exclusions for FSLogix https://learn.microsoft.com/en-us/fslogix/overview-prerequisites#configure-antivirus-file-and-folder-exclusions\r\n    Write-Log -message \"Adding Windows Defender Exclusions for FSLogix\"\r\n\r\n    $LocalPathExclusions = @(\r\n        \"$env:ProgramData\\FSLogix\",\r\n        \"$env:ProgramData\\FSLogix\\Cache\",\r\n        \"$env:ProgramData\\FSLogix\\Proxy\",\r\n        \"$env:ProgramFiles\\FSLogix\\Apps\",\r\n        \"$env:SystemDrive\\Users\\*\\AppData\\Local\\FSLogix\",\r\n        \"$env:SystemRoot\\Temp\\*\\*.vhdx\",\r\n        \"$env:SystemDrive\\users\\*\\AppData\\Local\\Temp\\*.vhdx\"\r\n    )\r\n    \r\n    # Build UNC Path Exclusions from storage account paths\r\n    $UncPathExclusions = @()\r\n    $UncPathExclusions += $LocalProfileContainerPaths | ForEach-Object { \"$_\\*\\*.vhdx\" }\r\n    $UncPathExclusions += $LocalOfficeContainerPaths | ForEach-Object { \"$_\\*\\*.vhdx\" }\r\n    $UncPathExclusions += $RemoteProfileContainerPaths | ForEach-Object { \"$_\\*\\*.vhdx\" }\r\n    $UncPathExclusions += $RemoteOfficeContainerPaths | ForEach-Object { \"$_\\*\\*.vhdx\" }\r\n    $UncPathExclusions = $UncPathExclusions | Where-Object { $_ }\r\n\r\n    $PathExclusions = $LocalPathExclusions + $UncPathExclusions\r\n\r\n    $ProcessExclusions = @(\r\n        \"$env:ProgramFiles\\FSLogix\\Apps\\frxsvc.exe\",\r\n        \"$env:ProgramFiles\\FSLogix\\Apps\\frxccds.exe\",\r\n        \"$env:ProgramFiles\\FSLogix\\Apps\\frxdrv.sys\",\r\n        \"$env:ProgramFiles\\FSLogix\\Apps\\frxdrvvt.sys\",\r\n        \"$env:ProgramFiles\\FSLogix\\Apps\\frxccd.sys\"\r\n    )\r\n\r\n    Try {\r\n        Write-Log -message \"Adding path exclusions using Add-MpPreference\"\r\n        ForEach ($Path in $PathExclusions) {\r\n            Write-Log -message \"Adding path exclusion: $Path\"\r\n            Add-MpPreference -ExclusionPath $Path -ErrorAction SilentlyContinue\r\n        }\r\n        \r\n        Write-Log -message \"Adding process exclusions using Add-MpPreference\"\r\n        ForEach ($Process in $ProcessExclusions) {\r\n            Write-Log -message \"Adding process exclusion: $Process\"\r\n            Add-MpPreference -ExclusionProcess $Process -ErrorAction SilentlyContinue\r\n        }\r\n        \r\n        Write-Log -message \"Windows Defender exclusions added successfully\"\r\n    }\r\n    Catch {\r\n        Write-Log -message \"Warning: Failed to add Windows Defender exclusions via Add-MpPreference: $_\" -Level Warning\r\n    }\r\n\r\n    $LocalAdministrator = (Get-LocalUser | Where-Object { $_.SID -like '*-500' }).Name\r\n    $LocalGroups = 'FSLogix Profile Exclude List', 'FSLogix ODFC Exclude List'\r\n    ForEach ($Group in $LocalGroups) {\r\n        If (-not (Get-LocalGroupMember -Group $Group | Where-Object { $_.Name -like \"*$LocalAdministrator\" })) {\r\n            Add-LocalGroupMember -Group $Group -Member $LocalAdministrator\r\n        }\r\n    }\r\n}\r\n\r\nWrite-Log -message \"*** Setting Registry Values ***\"\r\nForEach ($Setting in $RegSettings) {\r\n    Set-RegistryValue -Name $Setting.Name -Path $Setting.Path -PropertyType $Setting.PropertyType -Value $Setting.Value -Verbose\r\n}\r\n\r\n# Resize OS Disk\r\nWrite-Log -message \"Resizing OS Disk\"\r\n$driveLetter = $env:SystemDrive.Substring(0, 1)\r\n$size = Get-PartitionSupportedSize -DriveLetter $driveLetter\r\nResize-Partition -DriveLetter $driveLetter -Size $size.SizeMax\r\nWrite-Log -message \"OS Disk Resized\"\r\nClear-EventLog \"Windows PowerShell\" -ErrorAction SilentlyContinue\r\nWrite-Log -message \"Done\"",
                        "storageSuffix": "[[environment().suffixes.storage]",
                        "sessionHostCount": "[[length(parameters('sessionHostNames'))]",
                        "identityType": "[[if(if(or(not(contains(parameters('identitySolution'), 'DomainServices')), parameters('enableMonitoring')), true(), false()), if(not(empty(parameters('artifactsUserAssignedIdentityResourceId'))), 'SystemAssigned, UserAssigned', 'SystemAssigned'), if(not(empty(parameters('artifactsUserAssignedIdentityResourceId'))), 'UserAssigned', 'None'))]",
                        "userAssignedIdentities": "[[if(not(empty(parameters('artifactsUserAssignedIdentityResourceId'))), createObject(format('{0}', parameters('artifactsUserAssignedIdentityResourceId')), createObject()), createObject())]",
                        "identity": "[[if(not(equals(variables('identityType'), 'None')), createObject('type', variables('identityType'), 'userAssignedIdentities', if(not(empty(variables('userAssignedIdentities'))), variables('userAssignedIdentities'), null())), null())]"
                      },
                      "resources": [
                        {
                          "[string('copy')]": {
                            "name": "networkInterface",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "type": "Microsoft.Network/networkInterfaces",
                          "apiVersion": "2020-05-01",
                          "name": "[[variables('networkInterfaceNames')[range(0, variables('sessionHostCount'))[copyIndex()]]]",
                          "location": "[[parameters('location')]",
                          "tags": "[[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Network/networkInterfaces'), createObject()))]",
                          "properties": {
                            "ipConfigurations": "[[union(createArray(createObject('name', 'ipv4config', 'properties', createObject('privateIPAllocationMethod', 'Dynamic', 'subnet', createObject('id', parameters('subnetResourceId')), 'primary', true(), 'privateIPAddressVersion', 'IPv4'))), if(parameters('enableIPv6'), createArray(createObject('name', 'ipv6config', 'properties', createObject('privateIPAllocationMethod', 'Dynamic', 'subnet', createObject('id', parameters('subnetResourceId')), 'primary', false(), 'privateIPAddressVersion', 'IPv6'))), createArray()))]",
                            "enableAcceleratedNetworking": "[[parameters('enableAcceleratedNetworking')]",
                            "enableIPForwarding": false
                          }
                        },
                        {
                          "[string('copy')]": {
                            "name": "virtualMachine",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "type": "Microsoft.Compute/virtualMachines",
                          "apiVersion": "2024-03-01",
                          "name": "[[variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[copyIndex()]]]",
                          "location": "[[parameters('location')]",
                          "tags": "[[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Compute/virtualMachines'), createObject()))]",
                          "zones": "[[if(and(and(not(empty(parameters('preferredZones'))), less(range(0, variables('sessionHostCount'))[copyIndex()], length(parameters('preferredZones')))), not(empty(parameters('preferredZones')[range(0, variables('sessionHostCount'))[copyIndex()]]))), createArray(parameters('preferredZones')[range(0, variables('sessionHostCount'))[copyIndex()]]), if(and(equals(parameters('availability'), 'AvailabilityZones'), not(empty(parameters('availabilityZones')))), createArray(parameters('availabilityZones')[mod(sub(variables('vmNumbers')[range(0, variables('sessionHostCount'))[copyIndex()]], 1), length(parameters('availabilityZones')))]), null()))]",
                          "identity": "[[variables('identity')]",
                          "properties": {
                            "availabilitySet": "[[if(equals(parameters('availability'), 'AvailabilitySets'), createObject('id', resourceId('Microsoft.Compute/availabilitySets', replace(parameters('availabilitySetNameConv'), '##', padLeft(add(div(sub(variables('vmNumbers')[range(0, variables('sessionHostCount'))[copyIndex()]], 1), 200), 1), 2, '0')))), null())]",
                            "diagnosticsProfile": {
                              "bootDiagnostics": {
                                "enabled": true
                              }
                            },
                            "hardwareProfile": {
                              "vmSize": "[[parameters('virtualMachineSize')]"
                            },
                            "host": "[[if(and(and(not(empty(parameters('dedicatedHostResourceIds'))), less(range(0, variables('sessionHostCount'))[copyIndex()], length(parameters('dedicatedHostResourceIds')))), not(empty(parameters('dedicatedHostResourceIds')[range(0, variables('sessionHostCount'))[copyIndex()]]))), createObject('id', parameters('dedicatedHostResourceIds')[range(0, variables('sessionHostCount'))[copyIndex()]]), null())]",
                            "hostGroup": "[[if(and(and(and(not(empty(parameters('dedicatedHostGroupResourceIds'))), less(range(0, variables('sessionHostCount'))[copyIndex()], length(parameters('dedicatedHostGroupResourceIds')))), not(empty(parameters('dedicatedHostGroupResourceIds')[range(0, variables('sessionHostCount'))[copyIndex()]]))), or(or(empty(parameters('dedicatedHostResourceIds')), greaterOrEquals(range(0, variables('sessionHostCount'))[copyIndex()], length(parameters('dedicatedHostResourceIds')))), empty(parameters('dedicatedHostResourceIds')[range(0, variables('sessionHostCount'))[copyIndex()]]))), createObject('id', parameters('dedicatedHostGroupResourceIds')[range(0, variables('sessionHostCount'))[copyIndex()]]), null())]",
                            "storageProfile": {
                              "imageReference": "[[parameters('imageReference')]",
                              "osDisk": {
                                "diskSizeGB": "[[if(not(equals(parameters('diskSizeGB'), 0)), parameters('diskSizeGB'), null())]",
                                "name": "[[variables('osDiskNames')[range(0, variables('sessionHostCount'))[copyIndex()]]]",
                                "osType": "Windows",
                                "createOption": "FromImage",
                                "caching": "ReadWrite",
                                "deleteOption": "Delete",
                                "managedDisk": {
                                  "diskEncryptionSet": "[[if(and(not(equals(parameters('securityType'), 'ConfidentialVM')), not(empty(parameters('diskEncryptionSetResourceId')))), createObject('id', parameters('diskEncryptionSetResourceId')), null())]",
                                  "securityProfile": "[[if(equals(parameters('securityType'), 'ConfidentialVM'), createObject('diskEncryptionSet', if(not(empty(parameters('diskEncryptionSetResourceId'))), createObject('id', parameters('diskEncryptionSetResourceId')), null()), 'securityEncryptionType', parameters('confidentialVMOSDiskEncryptionType')), null())]",
                                  "storageAccountType": "[[parameters('diskSku')]"
                                }
                              },
                              "dataDisks": []
                            },
                            "osProfile": {
                              "computerName": "[[parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex()]]]",
                              "adminUsername": "[[parameters('virtualMachineAdminUserName')]",
                              "adminPassword": "[[parameters('virtualMachineAdminPassword')]",
                              "windowsConfiguration": {
                                "provisionVMAgent": true,
                                "enableAutomaticUpdates": false
                              },
                              "secrets": [],
                              "allowExtensionOperations": true
                            },
                            "networkProfile": {
                              "networkInterfaces": [
                                {
                                  "id": "[[resourceId('Microsoft.Network/networkInterfaces', variables('networkInterfaceNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]",
                                  "properties": {
                                    "deleteOption": "Delete"
                                  }
                                }
                              ]
                            },
                            "securityProfile": {
                              "encryptionAtHost": "[[if(parameters('encryptionAtHost'), true(), null())]",
                              "securityType": "[[if(not(equals(parameters('securityType'), 'Standard')), parameters('securityType'), null())]",
                              "uefiSettings": "[[if(not(equals(parameters('securityType'), 'Standard')), createObject('secureBootEnabled', parameters('secureBootEnabled'), 'vTpmEnabled', parameters('vTpmEnabled')), null())]"
                            },
                            "licenseType": "[[if(or(not(empty(tryGet(parameters('imageReference'), 'id'))), equals(tryGet(parameters('imageReference'), 'publisher'), 'MicrosoftWindowsDesktop')), 'Windows_Client', 'Windows_Server')]"
                          },
                          "dependsOn": [
                            "networkInterface"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "extension_JsonADDomainExtension",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[contains(parameters('identitySolution'), 'DomainServices')]",
                          "type": "Microsoft.Compute/virtualMachines/extensions",
                          "apiVersion": "2021-03-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'JsonADDomainExtension')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "forceUpdateTag": "[[parameters('deploymentSuffix')]",
                            "publisher": "Microsoft.Compute",
                            "type": "JsonADDomainExtension",
                            "typeHandlerVersion": "1.3",
                            "autoUpgradeMinorVersion": true,
                            "settings": {
                              "Name": "[[parameters('domainName')]",
                              "User": "[[parameters('domainJoinUserPrincipalName')]",
                              "Restart": "true",
                              "Options": "3",
                              "OUPath": "[[parameters('ouPath')]"
                            },
                            "protectedSettings": {
                              "Password": "[[parameters('domainJoinUserPassword')]"
                            }
                          },
                          "dependsOn": [
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "extension_AADLoginForWindows",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[or(startsWith(parameters('identitySolution'), 'EntraKerberos'), equals(parameters('identitySolution'), 'EntraId'))]",
                          "type": "Microsoft.Compute/virtualMachines/extensions",
                          "apiVersion": "2021-03-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'AADLoginForWindows')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "publisher": "Microsoft.Azure.ActiveDirectory",
                            "type": "AADLoginForWindows",
                            "typeHandlerVersion": "1.0",
                            "autoUpgradeMinorVersion": true,
                            "settings": "[[if(parameters('intuneEnrollment'), createObject('mdmId', '0000000a-0000-0000-c000-000000000000'), null())]"
                          },
                          "dependsOn": [
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "extension_AzureMonitorWindowsAgent",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[parameters('enableMonitoring')]",
                          "type": "Microsoft.Compute/virtualMachines/extensions",
                          "apiVersion": "2023-03-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'AzureMonitorWindowsAgent')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "publisher": "Microsoft.Azure.Monitor",
                            "type": "AzureMonitorWindowsAgent",
                            "typeHandlerVersion": "1.1",
                            "autoUpgradeMinorVersion": true,
                            "enableAutomaticUpgrade": true
                          },
                          "dependsOn": [
                            "extension_AADLoginForWindows",
                            "extension_JsonADDomainExtension",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "dataCollectionEndpointAssociation",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[and(parameters('enableMonitoring'), not(empty(parameters('dataCollectionEndpointResourceId'))))]",
                          "type": "Microsoft.Insights/dataCollectionRuleAssociations",
                          "apiVersion": "2022-06-01",
                          "scope": "[[format('Microsoft.Compute/virtualMachines/{0}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]",
                          "name": "configurationAccessEndpoint",
                          "properties": {
                            "dataCollectionEndpointId": "[[parameters('dataCollectionEndpointResourceId')]",
                            "description": "Data Collection Endpoint Association"
                          },
                          "dependsOn": [
                            "extension_AzureMonitorWindowsAgent",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "avdInsightsDataCollectionRuleAssociation",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[and(parameters('enableMonitoring'), not(empty(parameters('avdInsightsDataCollectionRulesResourceId'))))]",
                          "type": "Microsoft.Insights/dataCollectionRuleAssociations",
                          "apiVersion": "2022-06-01",
                          "scope": "[[format('Microsoft.Compute/virtualMachines/{0}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]",
                          "name": "[[format('{0}-avdInsights-data-coll-rule-assoc', parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex()]])]",
                          "properties": {
                            "dataCollectionRuleId": "[[parameters('avdInsightsDataCollectionRulesResourceId')]",
                            "description": "AVD Insights data collection rule association"
                          },
                          "dependsOn": [
                            "extension_AzureMonitorWindowsAgent",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "vmInsightsDataCollectionRuleAssociation",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[and(parameters('enableMonitoring'), not(empty(parameters('vmInsightsDataCollectionRulesResourceId'))))]",
                          "type": "Microsoft.Insights/dataCollectionRuleAssociations",
                          "apiVersion": "2022-06-01",
                          "scope": "[[format('Microsoft.Compute/virtualMachines/{0}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]",
                          "name": "[[format('{0}-vmInsights-data-coll-rule-assoc', parameters('sessionHostNames')[range(0, variables('sessionHostCount'))[copyIndex()]])]",
                          "properties": {
                            "dataCollectionRuleId": "[[parameters('vmInsightsDataCollectionRulesResourceId')]",
                            "description": "VM Insights data collection rule association"
                          },
                          "dependsOn": [
                            "extension_AzureMonitorWindowsAgent",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "extension_GuestAttestation",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[parameters('integrityMonitoring')]",
                          "type": "Microsoft.Compute/virtualMachines/extensions",
                          "apiVersion": "2023-09-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'GuestAttestation')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "publisher": "Microsoft.Azure.Security.WindowsAttestation",
                            "type": "GuestAttestation",
                            "typeHandlerVersion": "1.0",
                            "autoUpgradeMinorVersion": true,
                            "settings": {
                              "AttestationConfig": {
                                "MaaSettings": {
                                  "maaEndpoint": "",
                                  "maaTenantName": "GuestAttestation"
                                },
                                "AscSettings": {
                                  "ascReportingEndpoint": "",
                                  "ascReportingFrequency": ""
                                },
                                "useCustomToken": "false",
                                "disableAlerts": "false"
                              }
                            }
                          },
                          "dependsOn": [
                            "extension_AADLoginForWindows",
                            "extension_AzureMonitorWindowsAgent",
                            "extension_JsonADDomainExtension",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "extension_AmdGpuDriverWindows",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[parameters('hasAmdGpu')]",
                          "type": "Microsoft.Compute/virtualMachines/extensions",
                          "apiVersion": "2021-03-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'AmdGpuDriverWindows')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "publisher": "Microsoft.HpcCompute",
                            "type": "AmdGpuDriverWindows",
                            "typeHandlerVersion": "1.0",
                            "autoUpgradeMinorVersion": true,
                            "settings": {}
                          },
                          "dependsOn": [
                            "extension_AADLoginForWindows",
                            "extension_AzureMonitorWindowsAgent",
                            "extension_JsonADDomainExtension",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "extension_NvidiaGpuDriverWindows",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[parameters('hasNvidiaGpu')]",
                          "type": "Microsoft.Compute/virtualMachines/extensions",
                          "apiVersion": "2021-03-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'NvidiaGpuDriverWindows')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "publisher": "Microsoft.HpcCompute",
                            "type": "NvidiaGpuDriverWindows",
                            "typeHandlerVersion": "1.2",
                            "autoUpgradeMinorVersion": true,
                            "settings": {}
                          },
                          "dependsOn": [
                            "extension_AADLoginForWindows",
                            "extension_AzureMonitorWindowsAgent",
                            "extension_JsonADDomainExtension",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "runCommand_ConfigureSessionHost",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "type": "Microsoft.Compute/virtualMachines/runCommands",
                          "apiVersion": "2023-09-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'configureSessionHost')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "parameters": [
                              {
                                "name": "AmdVmSize",
                                "value": "[[if(parameters('hasAmdGpu'), 'true', 'false')]"
                              },
                              {
                                "name": "NvidiaVmSize",
                                "value": "[[if(parameters('hasNvidiaGpu'), 'true', 'false')]"
                              },
                              {
                                "name": "DisableUpdates",
                                "value": "false"
                              },
                              {
                                "name": "ConfigureFSLogix",
                                "value": "[[if(parameters('fslogixConfigureSessionHosts'), 'true', 'false')]"
                              },
                              {
                                "name": "CloudCache",
                                "value": "[[if(contains(parameters('fslogixContainerType'), 'CloudCache'), 'true', 'false')]"
                              },
                              {
                                "name": "IdentitySolution",
                                "value": "[[parameters('identitySolution')]"
                              },
                              {
                                "name": "LocalNetAppServers",
                                "value": "[[string(parameters('fslogixLocalNetAppServerFqdns'))]"
                              },
                              {
                                "name": "LocalStorageAccountNames",
                                "value": "[[string(variables('fslogixLocalStorageAccountNames'))]"
                              },
                              {
                                "name": "OSSGroups",
                                "value": "[[string(parameters('fslogixOSSGroups'))]"
                              },
                              {
                                "name": "RemoteNetAppServers",
                                "value": "[[string(parameters('fslogixRemoteNetAppServerFqdns'))]"
                              },
                              {
                                "name": "RemoteStorageAccountNames",
                                "value": "[[string(variables('fslogixRemoteStorageAccountNames'))]"
                              },
                              {
                                "name": "Shares",
                                "value": "[[string(parameters('fslogixFileShareNames'))]"
                              },
                              {
                                "name": "SizeInMBs",
                                "value": "[[string(parameters('fslogixSizeInMBs'))]"
                              },
                              {
                                "name": "StorageAccountDNSSuffix",
                                "value": "[[variables('storageSuffix')]"
                              },
                              {
                                "name": "StorageService",
                                "value": "[[parameters('fslogixStorageService')]"
                              },
                              {
                                "name": "TimeZone",
                                "value": "[[parameters('timeZone')]"
                              }
                            ],
                            "protectedParameters": "[[if(parameters('fslogixConfigureSessionHosts'), createArray(createObject('name', 'LocalStorageAccountKeys', 'value', string(union(if(and(equals(parameters('identitySolution'), 'EntraId'), not(empty(parameters('fslogixLocalStorageAccountResourceIds')))), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixLocalStorageAccountResourceIds')[0], '/')[2], split(parameters('fslogixLocalStorageAccountResourceIds')[0], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixLocalStorageAccountResourceIds')[0], '/'))), '2023-01-01').keys[0].value), createArray()), if(and(equals(parameters('identitySolution'), 'EntraId'), greater(length(parameters('fslogixLocalStorageAccountResourceIds')), 1)), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixLocalStorageAccountResourceIds')[1], '/')[2], split(parameters('fslogixLocalStorageAccountResourceIds')[1], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixLocalStorageAccountResourceIds')[1], '/'))), '2023-01-01').keys[0].value), createArray())))), createObject('name', 'RemoteStorageAccountKeys', 'value', string(union(if(and(equals(parameters('identitySolution'), 'EntraId'), not(empty(parameters('fslogixRemoteStorageAccountResourceIds')))), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixRemoteStorageAccountResourceIds')[0], '/')[2], split(parameters('fslogixRemoteStorageAccountResourceIds')[0], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixRemoteStorageAccountResourceIds')[0], '/'))), '2023-01-01').keys[0].value), createArray()), if(and(equals(parameters('identitySolution'), 'EntraId'), greater(length(parameters('fslogixRemoteStorageAccountResourceIds')), 1)), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixRemoteStorageAccountResourceIds')[1], '/')[2], split(parameters('fslogixRemoteStorageAccountResourceIds')[1], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixRemoteStorageAccountResourceIds')[1], '/'))), '2023-01-01').keys[0].value), createArray()))))), null())]",
                            "source": {
                              "script": "[[variables('$fxv#0')]"
                            },
                            "treatFailureAsDeploymentFailure": true,
                            "timeoutInSeconds": 600
                          },
                          "dependsOn": [
                            "extension_AADLoginForWindows",
                            "extension_AmdGpuDriverWindows",
                            "extension_AzureMonitorWindowsAgent",
                            "extension_GuestAttestation",
                            "extension_JsonADDomainExtension",
                            "extension_NvidiaGpuDriverWindows",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "extension_DSC_installAvdAgents",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "type": "Microsoft.Compute/virtualMachines/extensions",
                          "apiVersion": "2021-03-01",
                          "name": "[[format('{0}/{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], 'AVDAgentInstallandConfig')]",
                          "location": "[[parameters('location')]",
                          "properties": {
                            "forceUpdateTag": "[[parameters('timestamp')]",
                            "publisher": "Microsoft.Powershell",
                            "type": "DSC",
                            "typeHandlerVersion": "2.73",
                            "autoUpgradeMinorVersion": true,
                            "settings": {
                              "modulesUrl": "[[parameters('sessionHostRegistrationDSCUrl')]",
                              "configurationFunction": "Configuration.ps1\\AddSessionHost",
                              "properties": {
                                "hostPoolName": "[[last(split(parameters('hostPoolResourceId'), '/'))]",
                                "registrationInfoTokenCredential": {
                                  "UserName": "PLACEHOLDER_DO_NOT_USE",
                                  "Password": "PrivateSettingsRef:RegistrationInfoToken"
                                },
                                "aadJoin": "[[not(contains(parameters('identitySolution'), 'DomainServices'))]",
                                "UseAgentDownloadEndpoint": true,
                                "mdmId": "[[if(parameters('intuneEnrollment'), '0000000a-0000-0000-c000-000000000000', '')]"
                              }
                            },
                            "protectedSettings": {
                              "Items": {
                                "RegistrationInfoToken": "[[last(listRegistrationTokens(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('hostPoolResourceId'), '/')[2], split(parameters('hostPoolResourceId'), '/')[4]), 'Microsoft.DesktopVirtualization/hostPools', last(split(parameters('hostPoolResourceId'), '/'))), '2023-09-05').value).token]"
                              }
                            }
                          },
                          "dependsOn": [
                            "postDeploymentScripts",
                            "runCommand_ConfigureSessionHost",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "postDeploymentScripts",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "condition": "[[not(empty(parameters('sessionHostCustomizations')))]",
                          "type": "Microsoft.Resources/deployments",
                          "apiVersion": "2025-04-01",
                          "name": "[[format('shr-{0}-customizations-{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], parameters('deploymentSuffix'))]",
                          "properties": {
                            "expressionEvaluationOptions": {
                              "scope": "inner"
                            },
                            "mode": "Incremental",
                            "parameters": {
                              "artifactsContainerUri": {
                                "value": "[[parameters('artifactsContainerUri')]"
                              },
                              "customizations": {
                                "value": "[[parameters('sessionHostCustomizations')]"
                              },
                              "userAssignedIdentityClientId": {
                                "value": "[[parameters('artifactsUserAssignedIdentityClientId')]"
                              },
                              "virtualMachineName": {
                                "value": "[[variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]]]"
                              }
                            },
                            "template": {
                              "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                              "contentVersion": "1.0.0.0",
                              "metadata": {
                                "_generator": {
                                  "name": "bicep",
                                  "version": "0.39.26.7824",
                                  "templateHash": "6032795963718933388"
                                }
                              },
                              "parameters": {
                                "artifactsContainerUri": {
                                  "type": "string"
                                },
                                "customizations": {
                                  "type": "array"
                                },
                                "location": {
                                  "type": "string",
                                  "defaultValue": "[[resourceGroup().location]"
                                },
                                "userAssignedIdentityClientId": {
                                  "type": "string"
                                },
                                "virtualMachineName": {
                                  "type": "string"
                                }
                              },
                              "variables": {
                                "[string('copy')]": [
                                  {
                                    "name": "customizers",
                                    "count": "[[length(parameters('customizations'))]",
                                    "input": {
                                      "name": "[[replace(parameters('customizations')[copyIndex('customizers')].name, ' ', '-')]",
                                      "uri": "[[if(or(startsWith(parameters('customizations')[copyIndex('customizers')].blobNameOrUri, 'https://'), startsWith(parameters('customizations')[copyIndex('customizers')].blobNameorUri, 'http://')), parameters('customizations')[copyIndex('customizers')].blobNameOrUri, format('{0}/{1}', parameters('artifactsContainerUri'), parameters('customizations')[copyIndex('customizers')].blobNameOrUri))]",
                                      "arguments": "[[coalesce(tryGet(parameters('customizations')[copyIndex('customizers')], 'arguments'), '')]"
                                    }
                                  }
                                ],
                                "$fxv#0": "param(\r\n  [string]$APIVersion,\r\n  [string]$Arguments='',\r\n  [string]$BlobStorageSuffix,\r\n  [string]$BuildDir='',\r\n  [string]$Name,\r\n  [string]$Uri,\r\n  [string]$UserAssignedIdentityClientId\r\n)\r\n\r\nfunction Write-OutputWithTimeStamp {\r\n  param(\r\n      [string]$Message\r\n  )    \r\n  $Timestamp = Get-Date -Format 'MM/dd/yyyy HH:mm:ss'\r\n  $Entry = '[' + $Timestamp + '] ' + $Message\r\n  Write-Output $Entry\r\n}\r\n\r\nFunction Split-ArgumentString {\r\n    param (\r\n        [string]$ArgumentString\r\n    )\r\n\r\n    if ([string]::IsNullOrWhiteSpace($ArgumentString)) {\r\n        return @()\r\n    }\r\n\r\n    # For PowerShell execution with &, we want individual arguments, not combined ones\r\n    $arguments = @()\r\n    $currentArg = \"\"\r\n    $inQuotes = $false\r\n    \r\n    for ($i = 0; $i -lt $ArgumentString.Length; $i++) {\r\n        $char = $ArgumentString[$i]\r\n        \r\n        if ($char -eq '\"' -and ($i -eq 0 -or $ArgumentString[$i-1] -ne '\\')) {\r\n            $inQuotes = !$inQuotes\r\n            $currentArg += $char\r\n        }\r\n        elseif ($char -eq ' ' -and !$inQuotes) {\r\n            if ($currentArg.Length -gt 0) {\r\n                # Handle boolean conversion\r\n                $value = $currentArg.Trim('\"')\r\n                if ($value -eq 'true') {\r\n                    $arguments += '$true'\r\n                }\r\n                elseif ($value -eq 'false') {\r\n                    $arguments += '$false'\r\n                }\r\n                else {\r\n                    $arguments += $value\r\n                }\r\n                $currentArg = \"\"\r\n            }\r\n        }\r\n        else {\r\n            $currentArg += $char\r\n        }\r\n    }\r\n    \r\n    # Add the last argument\r\n    if ($currentArg.Length -gt 0) {\r\n        $value = $currentArg.Trim('\"')\r\n        if ($value -eq 'true') {\r\n            $arguments += '$true'\r\n        }\r\n        elseif ($value -eq 'false') {\r\n            $arguments += '$false'\r\n        }\r\n        else {\r\n            $arguments += $value\r\n        }\r\n    }\r\n    \r\n    return $arguments\r\n}\r\n\r\nFunction ConvertTo-ParametersSplat {\r\n    param (\r\n        [string]$ArgumentString\r\n    )\r\n\r\n    if ([string]::IsNullOrWhiteSpace($ArgumentString)) {\r\n        return @{}\r\n    }\r\n\r\n    $tokens = Split-ArgumentString -ArgumentString $ArgumentString\r\n    $parameters = @{}\r\n    \r\n    $i = 0\r\n    while ($i -lt $tokens.Count) {\r\n        $token = $tokens[$i]\r\n        \r\n        # If this is a parameter (starts with -)\r\n        if ($token -match '^-(\\w+)$') {\r\n            $paramName = $matches[1]  # Remove the dash\r\n            \r\n            # Check if there's a value following this parameter\r\n            if (($i + 1) -lt $tokens.Count -and $tokens[$i + 1] -notmatch '^-\\w+$') {\r\n                # Parameter with value\r\n                $i++  # Move to the value\r\n                $value = $tokens[$i]\r\n                \r\n                # Handle PowerShell booleans\r\n                if ($value -eq '$true') {\r\n                    $parameters[$paramName] = $true\r\n                }\r\n                elseif ($value -eq '$false') {\r\n                    $parameters[$paramName] = $false\r\n                }\r\n                else {\r\n                    # Remove quotes if present\r\n                    $cleanValue = $value.Trim('\"')\r\n                    $parameters[$paramName] = $cleanValue\r\n                }\r\n            }\r\n            else {\r\n                # This is a switch parameter (no value)\r\n                $parameters[$paramName] = $true\r\n            }\r\n        }\r\n        else {\r\n            # Handle positional arguments (rare in this context)\r\n            # You could add logic here if needed\r\n        }\r\n        \r\n        $i++\r\n    }\r\n    \r\n    return $parameters\r\n}\r\n\r\nStart-Transcript -Path \"$env:SystemRoot\\Logs\\$Name.log\" -Force\r\nWrite-OutputWithTimeStamp \"Starting '$Name' script with the following parameters.\"\r\nWrite-Output ( $PSBoundParameters | Format-Table -AutoSize )\r\nIf ($Arguments -eq '') { $Arguments = $null }\r\nIf ($BuildDir -ne '') {\r\n  $TempDir = Join-Path $BuildDir -ChildPath $Name\r\n} Else {\r\n  $TempDir = Join-Path $Env:TEMP -ChildPath $Name\r\n}\r\nNew-Item -Path $TempDir -ItemType Directory -Force | Out-Null\r\n$WebClient = New-Object System.Net.WebClient\r\nIf ($Uri -match $BlobStorageSuffix -and $UserAssignedIdentityClientId -ne '') {\r\n  Write-OutputWithTimeStamp \"Getting access token for '$Uri' using User Assigned Identity.\"\r\n  $StorageEndpoint = ($Uri -split \"://\")[0] + \"://\" + ($Uri -split \"/\")[2] + \"/\"\r\n  $TokenUri = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=$APIVersion&resource=$StorageEndpoint&client_id=$UserAssignedIdentityClientId\"\r\n  $AccessToken = ((Invoke-WebRequest -Headers @{Metadata = $true } -Uri $TokenUri -UseBasicParsing).Content | ConvertFrom-Json).access_token\r\n  $WebClient.Headers.Add('x-ms-version', '2017-11-09')\r\n  $webClient.Headers.Add(\"Authorization\", \"Bearer $AccessToken\")\r\n}\r\n$SourceFileName = ($Uri -Split \"/\")[-1]\r\nWrite-OutputWithTimeStamp \"Downloading '$Uri' to '$TempDir'.\"\r\n$DestFile = Join-Path -Path $TempDir -ChildPath $SourceFileName\r\n$webClient.DownloadFile(\"$Uri\", \"$DestFile\")\r\nStart-Sleep -Seconds 10\r\nIf (!(Test-Path -Path $DestFile)) { Write-Error \"Failed to download $SourceFileName\"; Exit 1 }\r\nWrite-OutputWithTimeStamp 'Finished downloading'\r\nSet-Location -Path $TempDir\r\n$Ext = [System.IO.Path]::GetExtension($DestFile).ToLower().Replace('.','')\r\nswitch ($Ext) {\r\n  'exe' {\r\n      If ($Arguments) {\r\n        Write-OutputWithTimeStamp \"Executing '`\"$DestFile`\" $Arguments'\"\r\n        $Install = Start-Process -FilePath \"$DestFile\" -ArgumentList (Split-ArgumentString -ArgumentString $Arguments) -NoNewWindow -Wait -PassThru\r\n        Write-OutputWithTimeStamp \"Installation ended with exit code $($Install.ExitCode).\"\r\n      }\r\n      Else {\r\n        Write-OutputWithTimeStamp \"Executing `\"$DestFile`\"\"\r\n        $Install = Start-Process -FilePath \"$DestFile\" -NoNewWindow -Wait -PassThru\r\n        Write-OutputWithTimeStamp \"Installation ended with exit code $($Install.ExitCode).\"\r\n      }      \r\n    }\r\n  'msi' {\r\n    If ($Arguments) {\r\n      $Arguments = Split-ArgumentString -ArgumentString $Arguments\r\n      If ($Arguments -notcontains $DestFile) {\r\n        $InstallArg = \"/i $DestFile\"\r\n        $Arguments = @($InstallArg) + $Arguments\r\n      }\r\n      Write-OutputWithTimeStamp \"Executing 'msiexec.exe $Arguments'\"\r\n      $MsiExec = Start-Process -FilePath msiexec.exe -ArgumentList $Arguments -Wait -PassThru\r\n      Write-OutputWithTimeStamp \"Installation ended with exit code $($MsiExec.ExitCode).\"\r\n    }\r\n    Else {\r\n      Write-OutputWithTimeStamp \"Executing 'msiexec.exe /i $DestFile /qn'\"\r\n      $MsiExec = Start-Process -FilePath msiexec.exe -ArgumentList \"/i $DestFile /qn\" -Wait -PassThru\r\n      Write-OutputWithTimeStamp \"Installation ended with exit code $($MsiExec.ExitCode).\"\r\n    }    \r\n  }\r\n  'bat' {\r\n    If ($Arguments) {\r\n      Write-OutputWithTimeStamp \"Executing 'cmd.exe `\"$DestFile`\" $Arguments'\"\r\n      $Arguments = Split-ArgumentString -ArgumentString $Arguments\r\n      If ($Arguments -notcontains $DestFile) {\r\n        $Arguments = @(\"$DestFile\") + $Arguments\r\n      }\r\n      Start-Process -FilePath cmd.exe -ArgumentList $Arguments -Wait\r\n    }\r\n    Else {\r\n      Write-OutputWithTimeStamp \"Executing 'cmd.exe `\"$DestFile`\"'\"\r\n      Start-Process -FilePath cmd.exe -ArgumentList \"`\"$DestFile`\"\" -Wait\r\n    }\r\n  }\r\n  'ps1' {\r\n    If ($Arguments) {\r\n      Write-OutputWithTimeStamp \"Calling PowerShell Script '$DestFile' with arguments '$Arguments'\"\r\n      $parameterSplat = ConvertTo-ParametersSplat -ArgumentString $Arguments\r\n      & $DestFile @parameterSplat\r\n    }\r\n    Else {\r\n      Write-OutputWithTimeStamp \"Calling PowerShell Script '$DestFile'\"\r\n      & $DestFile\r\n    }\r\n  }\r\n  'zip' {\r\n    $DestinationPath = Join-Path -Path \"$TempDir\" -ChildPath $([System.IO.Path]::GetFileNameWithoutExtension($SourceFileName))\r\n    Write-OutputWithTimeStamp \"Extracting '$DestFile' to '$DestinationPath'.\"\r\n    Expand-Archive -Path $DestFile -DestinationPath $DestinationPath -Force\r\n    Write-OutputWithTimeStamp \"Finding PowerShell script in root of '$DestinationPath'.\"\r\n    $PSScript = (Get-ChildItem -Path $DestinationPath -filter '*.ps1').FullName\r\n    If ($PSScript.count -gt 1) { $PSScript = $PSScript[0] }\r\n    If ($Arguments) {\r\n      Write-OutputWithTimeStamp \"Calling PowerShell Script '$DestFile' with arguments '$Arguments'\"\r\n      $parameterSplat = ConvertTo-ParametersSplat -ArgumentString $Arguments\r\n      & $PSScript @parameterSplat\r\n    }\r\n    Else {\r\n      Write-OutputWithTimeStamp \"Calling PowerShell Script '$PSScript'\"         \r\n      & $PSScript\r\n    }\r\n  }\r\n}\r\nIf ((Split-Path $TempDir -Parent) -eq $Env:Temp) {Remove-Item -Path $TempDir -Recurse -Force -ErrorAction SilentlyContinue}\r\nStop-Transcript",
                                "apiVersion": "[[if(startsWith(environment().name, 'USN'), '2017-08-01', '2018-02-01')]"
                              },
                              "resources": [
                                {
                                  "[string('copy')]": {
                                    "name": "runCommands",
                                    "count": "[[length(variables('customizers'))]",
                                    "mode": "serial",
                                    "batchSize": 1
                                  },
                                  "type": "Microsoft.Compute/virtualMachines/runCommands",
                                  "apiVersion": "2023-03-01",
                                  "name": "[[format('{0}/{1}', parameters('virtualMachineName'), variables('customizers')[copyIndex()].name)]",
                                  "location": "[[parameters('location')]",
                                  "properties": {
                                    "parameters": [
                                      {
                                        "name": "APIVersion",
                                        "value": "[[variables('apiVersion')]"
                                      },
                                      {
                                        "name": "BlobStorageSuffix",
                                        "value": "[[format('blob.{0}', environment().suffixes.storage)]"
                                      },
                                      {
                                        "name": "UserAssignedIdentityClientId",
                                        "value": "[[parameters('userAssignedIdentityClientId')]"
                                      },
                                      {
                                        "name": "Name",
                                        "value": "[[variables('customizers')[copyIndex()].name]"
                                      },
                                      {
                                        "name": "Uri",
                                        "value": "[[variables('customizers')[copyIndex()].uri]"
                                      },
                                      {
                                        "name": "Arguments",
                                        "value": "[[variables('customizers')[copyIndex()].arguments]"
                                      }
                                    ],
                                    "source": {
                                      "script": "[[variables('$fxv#0')]"
                                    },
                                    "treatFailureAsDeploymentFailure": true
                                  }
                                }
                              ]
                            }
                          },
                          "dependsOn": [
                            "runCommand_ConfigureSessionHost",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        },
                        {
                          "[string('copy')]": {
                            "name": "updateOSDiskNetworkAccess",
                            "count": "[[length(range(0, variables('sessionHostCount')))]"
                          },
                          "type": "Microsoft.Resources/deployments",
                          "apiVersion": "2025-04-01",
                          "name": "[[format('shr-{0}-disableDiskPublicAccess-{1}', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]], parameters('deploymentSuffix'))]",
                          "properties": {
                            "expressionEvaluationOptions": {
                              "scope": "inner"
                            },
                            "mode": "Incremental",
                            "parameters": {
                              "diskAccessId": {
                                "value": ""
                              },
                              "diskName": {
                                "value": "[[reference(resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]]), '2024-03-01').storageProfile.osDisk.name]"
                              },
                              "location": {
                                "value": "[[parameters('location')]"
                              },
                              "deploymentSuffix": {
                                "value": "[[parameters('deploymentSuffix')]"
                              },
                              "vmName": {
                                "value": "[[variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]]]"
                              }
                            },
                            "template": {
                              "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                              "contentVersion": "1.0.0.0",
                              "metadata": {
                                "_generator": {
                                  "name": "bicep",
                                  "version": "0.39.26.7824",
                                  "templateHash": "18415624258013773257"
                                }
                              },
                              "parameters": {
                                "diskAccessId": {
                                  "type": "string"
                                },
                                "diskName": {
                                  "type": "string"
                                },
                                "location": {
                                  "type": "string"
                                },
                                "deploymentSuffix": {
                                  "type": "string"
                                },
                                "vmName": {
                                  "type": "string"
                                }
                              },
                              "resources": [
                                {
                                  "type": "Microsoft.Resources/deployments",
                                  "apiVersion": "2025-04-01",
                                  "name": "[[format('shr-update-osDisk-{0}-stage2-{1}', parameters('vmName'), parameters('deploymentSuffix'))]",
                                  "properties": {
                                    "expressionEvaluationOptions": {
                                      "scope": "inner"
                                    },
                                    "mode": "Incremental",
                                    "parameters": {
                                      "diskName": {
                                        "value": "[[parameters('diskName')]"
                                      },
                                      "creationData": {
                                        "value": "[[reference(resourceId('Microsoft.Compute/disks', parameters('diskName')), '2023-10-02').creationData]"
                                      },
                                      "diskAccessId": {
                                        "value": "[[parameters('diskAccessId')]"
                                      },
                                      "location": {
                                        "value": "[[parameters('location')]"
                                      }
                                    },
                                    "template": {
                                      "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                                      "contentVersion": "1.0.0.0",
                                      "metadata": {
                                        "_generator": {
                                          "name": "bicep",
                                          "version": "0.39.26.7824",
                                          "templateHash": "17290095301135652436"
                                        }
                                      },
                                      "parameters": {
                                        "creationData": {
                                          "type": "object"
                                        },
                                        "diskName": {
                                          "type": "string"
                                        },
                                        "diskAccessId": {
                                          "type": "string"
                                        },
                                        "location": {
                                          "type": "string"
                                        }
                                      },
                                      "resources": [
                                        {
                                          "type": "Microsoft.Compute/disks",
                                          "apiVersion": "2023-10-02",
                                          "name": "[[parameters('diskName')]",
                                          "location": "[[parameters('location')]",
                                          "properties": {
                                            "diskAccessId": "[[if(empty(parameters('diskAccessId')), null(), parameters('diskAccessId'))]",
                                            "creationData": "[[parameters('creationData')]",
                                            "networkAccessPolicy": "[[if(empty(parameters('diskAccessId')), 'DenyAll', 'AllowPrivate')]",
                                            "publicNetworkAccess": "Disabled"
                                          }
                                        }
                                      ]
                                    }
                                  }
                                }
                              ]
                            }
                          },
                          "dependsOn": [
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]",
                            "[[resourceId('Microsoft.Compute/virtualMachines', variables('virtualMachineNames')[range(0, variables('sessionHostCount'))[range(0, variables('sessionHostCount'))[copyIndex()]]])]"
                          ]
                        }
                      ]
                    }
                  },
                  "dependsOn": [
                    "availabilitySets",
                    "[[resourceId('Microsoft.Resources/deployments', format('shr-netAppVolumeFqdns-{0}', variables('deploymentSuffix')))]"
                  ]
                }
              ]
            }
          },
          "resources": [
            {
              "type": "Microsoft.Resources/templateSpecs",
              "apiVersion": "2022-02-01",
              "name": "[parameters('templateSpecName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "description": "Template Spec for AVD Session Host deployment used by Session Host Replacer",
                "displayName": "AVD Session Host Template"
              }
            },
            {
              "type": "Microsoft.Resources/templateSpecs/versions",
              "apiVersion": "2022-02-01",
              "name": "[format('{0}/{1}', parameters('templateSpecName'), parameters('templateSpecVersion'))]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "properties": {
                "mainTemplate": "[variables('$fxv#0')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.Resources/templateSpecs', parameters('templateSpecName'))]"
              ]
            }
          ],
          "outputs": {
            "templateSpecResourceId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Resources/templateSpecs', parameters('templateSpecName'))]"
            },
            "templateSpecVersionResourceId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Resources/templateSpecs/versions', parameters('templateSpecName'), parameters('templateSpecVersion'))]"
            }
          }
        }
      }
    },
    {
      "condition": "[empty(parameters('appServicePlanResourceId'))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('FunctionAppHostingPlan-{0}', variables('deploymentSuffix'))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "functionAppKind": {
            "value": "functionApp"
          },
          "hostingPlanType": {
            "value": "FunctionsPremium"
          },
          "logAnalyticsWorkspaceId": {
            "value": "[parameters('logAnalyticsWorkspaceResourceId')]"
          },
          "location": {
            "value": "[parameters('location')]"
          },
          "name": {
            "value": "[variables('appServicePlanName')]"
          },
          "planPricing": {
            "value": "[parameters('appServicePlanSku')]"
          },
          "tags": {
            "value": "[parameters('tags')]"
          },
          "zoneRedundant": {
            "value": "[parameters('zoneRedundant')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "8286437522501107395"
            }
          },
          "parameters": {
            "hostingPlanType": {
              "type": "string"
            },
            "location": {
              "type": "string"
            },
            "logAnalyticsWorkspaceId": {
              "type": "string"
            },
            "functionAppKind": {
              "type": "string"
            },
            "name": {
              "type": "string"
            },
            "planPricing": {
              "type": "string"
            },
            "tags": {
              "type": "object"
            },
            "zoneRedundant": {
              "type": "bool"
            }
          },
          "variables": {
            "sku": {
              "name": "[split(parameters('planPricing'), '_')[1]]",
              "tier": "[split(parameters('planPricing'), '_')[0]]",
              "capacity": "[if(parameters('zoneRedundant'), 3, 1)]"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Web/serverfarms",
              "apiVersion": "2023-12-01",
              "name": "[parameters('name')]",
              "location": "[parameters('location')]",
              "sku": "[variables('sku')]",
              "tags": "[coalesce(tryGet(parameters('tags'), 'Microsoft.Web/serverfarms'), createObject())]",
              "properties": {
                "maximumElasticWorkerCount": "[if(contains(parameters('hostingPlanType'), 'Consumption'), null(), if(equals(parameters('hostingPlanType'), 'FunctionsPremium'), 20, 1))]",
                "reserved": "[if(contains(parameters('functionAppKind'), 'linux'), true(), false())]",
                "zoneRedundant": "[parameters('zoneRedundant')]"
              }
            },
            {
              "condition": "[not(empty(parameters('logAnalyticsWorkspaceId')))]",
              "type": "Microsoft.Insights/diagnosticSettings",
              "apiVersion": "2021-05-01-preview",
              "scope": "[resourceId('Microsoft.Web/serverfarms', parameters('name'))]",
              "name": "[format('{0}-diagnosticSettings', parameters('name'))]",
              "properties": {
                "metrics": [
                  {
                    "category": "AllMetrics",
                    "enabled": true
                  }
                ],
                "workspaceId": "[parameters('logAnalyticsWorkspaceId')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.Web/serverfarms', parameters('name'))]"
              ]
            }
          ],
          "outputs": {
            "hostingPlanId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Web/serverfarms', parameters('name'))]"
            }
          }
        }
      }
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('RoleAssign-KeyVault-KVCont-{0}', variables('deploymentSuffix'))]",
      "subscriptionId": "[split(parameters('credentialsKeyVaultResourceId'), '/')[2]]",
      "resourceGroup": "[split(parameters('credentialsKeyVaultResourceId'), '/')[4]]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "principalId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
          },
          "roleDefinitionId": {
            "value": "f25e0fa2-a7c8-4377-a976-54943a77a395"
          },
          "keyVaultName": {
            "value": "[last(split(parameters('credentialsKeyVaultResourceId'), '/'))]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "17878112866154693754"
            }
          },
          "parameters": {
            "keyVaultName": {
              "type": "string"
            },
            "principalId": {
              "type": "string"
            },
            "principalType": {
              "type": "string"
            },
            "roleDefinitionId": {
              "type": "string"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.KeyVault/vaults', parameters('keyVaultName'))]",
              "name": "[guid(resourceId('Microsoft.KeyVault/vaults', parameters('keyVaultName')), parameters('principalId'), parameters('roleDefinitionId'))]",
              "properties": {
                "principalId": "[parameters('principalId')]",
                "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionId'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.KeyVault/vaults', parameters('keyVaultName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.KeyVault/vaults', parameters('keyVaultName')), parameters('principalId'), parameters('roleDefinitionId')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('RoleAssign-Sub-VirtMachCont-{0}', variables('deploymentSuffix'))]",
      "subscriptionId": "[variables('virtualMachinesSubscriptionId')]",
      "location": "[resourceGroup().location]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "principalId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
          },
          "roleDefinitionId": {
            "value": "9980e02c-c2be-4d73-94e8-173b1dc7cf3c"
          },
          "subscriptionId": {
            "value": "[variables('virtualMachinesSubscriptionId')]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "7880731019312073531"
            },
            "name": "Role Assignments (Subscription scope)",
            "description": "This module deploys a Role Assignment at a Subscription scope.",
            "owner": "Azure/module-maintainers"
          },
          "parameters": {
            "roleDefinitionId": {
              "type": "string",
              "metadata": {
                "description": "Required. You can provide either the role definition GUID or its fully qualified ID in the following format: \\'/providers/Microsoft.Authorization/roleDefinitions/c2f4ef07-c644-48eb-af81-4b1b4947fb11\\'.\nYou can find the GUIDs in the ID column on the table at https://learn.microsoft.com/en-us/azure/role-based-access-control/built-in-roles.\n"
              }
            },
            "principalId": {
              "type": "string",
              "metadata": {
                "description": "Required. The Principal or Object ID of the Security Principal (User, Group, Service Principal, Managed Identity)."
              }
            },
            "subscriptionId": {
              "type": "string",
              "defaultValue": "[subscription().subscriptionId]",
              "metadata": {
                "description": "Optional. Subscription ID of the subscription to assign the RBAC role to. If not provided, will use the current scope for deployment."
              }
            },
            "description": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional. The description of the role assignment."
              }
            },
            "delegatedManagedIdentityResourceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional. ID of the delegated managed identity resource."
              }
            },
            "condition": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional. The conditions on the role assignment. This limits the resources it can be assigned to."
              }
            },
            "conditionVersion": {
              "type": "string",
              "defaultValue": "2.0",
              "allowedValues": [
                "2.0"
              ],
              "metadata": {
                "description": "Optional. Version of the condition. Currently accepted value is \"2.0\"."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "",
              "allowedValues": [
                "ServicePrincipal",
                "Group",
                "User",
                "ForeignGroup",
                "Device",
                ""
              ],
              "metadata": {
                "description": "Optional. The principal type of the assigned principal ID."
              }
            }
          },
          "variables": {
            "roleDefinitionIdVar": "[if(contains(parameters('roleDefinitionId'), '/providers/Microsoft.Authorization/roleDefinitions/'), parameters('roleDefinitionId'), format('/providers/Microsoft.Authorization/roleDefinitions/{0}', parameters('roleDefinitionId')))]"
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "name": "[guid(parameters('subscriptionId'), variables('roleDefinitionIdVar'), parameters('principalId'))]",
              "properties": {
                "roleDefinitionId": "[variables('roleDefinitionIdVar')]",
                "principalId": "[parameters('principalId')]",
                "description": "[if(not(empty(parameters('description'))), parameters('description'), null())]",
                "principalType": "[if(not(empty(parameters('principalType'))), parameters('principalType'), null())]",
                "delegatedManagedIdentityResourceId": "[if(not(empty(parameters('delegatedManagedIdentityResourceId'))), parameters('delegatedManagedIdentityResourceId'), null())]",
                "conditionVersion": "[if(and(not(empty(parameters('conditionVersion'))), not(empty(parameters('condition')))), parameters('conditionVersion'), null())]",
                "condition": "[if(not(empty(parameters('condition'))), parameters('condition'), null())]"
              }
            }
          ],
          "outputs": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "The GUID of the Role Assignment."
              },
              "value": "[guid(parameters('subscriptionId'), variables('roleDefinitionIdVar'), parameters('principalId'))]"
            },
            "resourceId": {
              "type": "string",
              "metadata": {
                "description": "The resource ID of the Role Assignment."
              },
              "value": "[subscriptionResourceId('Microsoft.Authorization/roleAssignments', guid(parameters('subscriptionId'), variables('roleDefinitionIdVar'), parameters('principalId')))]"
            },
            "scope": {
              "type": "string",
              "metadata": {
                "description": "The scope this Role Assignment applies to."
              },
              "value": "[subscription().id]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('RoleAssign-Sub-Reader-{0}', variables('deploymentSuffix'))]",
      "subscriptionId": "[variables('hostPoolSubscriptionId')]",
      "location": "[resourceGroup().location]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "principalId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
          },
          "roleDefinitionId": {
            "value": "acdd72a7-3385-48ef-bd42-f606fba81ae7"
          },
          "subscriptionId": {
            "value": "[variables('hostPoolSubscriptionId')]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "7880731019312073531"
            },
            "name": "Role Assignments (Subscription scope)",
            "description": "This module deploys a Role Assignment at a Subscription scope.",
            "owner": "Azure/module-maintainers"
          },
          "parameters": {
            "roleDefinitionId": {
              "type": "string",
              "metadata": {
                "description": "Required. You can provide either the role definition GUID or its fully qualified ID in the following format: \\'/providers/Microsoft.Authorization/roleDefinitions/c2f4ef07-c644-48eb-af81-4b1b4947fb11\\'.\nYou can find the GUIDs in the ID column on the table at https://learn.microsoft.com/en-us/azure/role-based-access-control/built-in-roles.\n"
              }
            },
            "principalId": {
              "type": "string",
              "metadata": {
                "description": "Required. The Principal or Object ID of the Security Principal (User, Group, Service Principal, Managed Identity)."
              }
            },
            "subscriptionId": {
              "type": "string",
              "defaultValue": "[subscription().subscriptionId]",
              "metadata": {
                "description": "Optional. Subscription ID of the subscription to assign the RBAC role to. If not provided, will use the current scope for deployment."
              }
            },
            "description": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional. The description of the role assignment."
              }
            },
            "delegatedManagedIdentityResourceId": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional. ID of the delegated managed identity resource."
              }
            },
            "condition": {
              "type": "string",
              "defaultValue": "",
              "metadata": {
                "description": "Optional. The conditions on the role assignment. This limits the resources it can be assigned to."
              }
            },
            "conditionVersion": {
              "type": "string",
              "defaultValue": "2.0",
              "allowedValues": [
                "2.0"
              ],
              "metadata": {
                "description": "Optional. Version of the condition. Currently accepted value is \"2.0\"."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "",
              "allowedValues": [
                "ServicePrincipal",
                "Group",
                "User",
                "ForeignGroup",
                "Device",
                ""
              ],
              "metadata": {
                "description": "Optional. The principal type of the assigned principal ID."
              }
            }
          },
          "variables": {
            "roleDefinitionIdVar": "[if(contains(parameters('roleDefinitionId'), '/providers/Microsoft.Authorization/roleDefinitions/'), parameters('roleDefinitionId'), format('/providers/Microsoft.Authorization/roleDefinitions/{0}', parameters('roleDefinitionId')))]"
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "name": "[guid(parameters('subscriptionId'), variables('roleDefinitionIdVar'), parameters('principalId'))]",
              "properties": {
                "roleDefinitionId": "[variables('roleDefinitionIdVar')]",
                "principalId": "[parameters('principalId')]",
                "description": "[if(not(empty(parameters('description'))), parameters('description'), null())]",
                "principalType": "[if(not(empty(parameters('principalType'))), parameters('principalType'), null())]",
                "delegatedManagedIdentityResourceId": "[if(not(empty(parameters('delegatedManagedIdentityResourceId'))), parameters('delegatedManagedIdentityResourceId'), null())]",
                "conditionVersion": "[if(and(not(empty(parameters('conditionVersion'))), not(empty(parameters('condition')))), parameters('conditionVersion'), null())]",
                "condition": "[if(not(empty(parameters('condition'))), parameters('condition'), null())]"
              }
            }
          ],
          "outputs": {
            "name": {
              "type": "string",
              "metadata": {
                "description": "The GUID of the Role Assignment."
              },
              "value": "[guid(parameters('subscriptionId'), variables('roleDefinitionIdVar'), parameters('principalId'))]"
            },
            "resourceId": {
              "type": "string",
              "metadata": {
                "description": "The resource ID of the Role Assignment."
              },
              "value": "[subscriptionResourceId('Microsoft.Authorization/roleAssignments', guid(parameters('subscriptionId'), variables('roleDefinitionIdVar'), parameters('principalId')))]"
            },
            "scope": {
              "type": "string",
              "metadata": {
                "description": "The scope this Role Assignment applies to."
              },
              "value": "[subscription().id]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "copy": {
        "name": "roleAssignmentsRGs",
        "count": "[length(variables('roleAssignmentsResourceGroups'))]"
      },
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('RoleAssign-{0}-{1}-{2}', last(split(variables('roleAssignmentsResourceGroups')[copyIndex()].resourceGroupId, '/')), variables('roleAssignmentsResourceGroups')[copyIndex()].roleDescription, variables('deploymentSuffix'))]",
      "subscriptionId": "[split(variables('roleAssignmentsResourceGroups')[copyIndex()].resourceGroupId, '/')[2]]",
      "resourceGroup": "[split(variables('roleAssignmentsResourceGroups')[copyIndex()].resourceGroupId, '/')[4]]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "principalId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
          },
          "roleDefinitionId": {
            "value": "[variables('roleAssignmentsResourceGroups')[copyIndex()].roleDefinitionId]"
          },
          "resourceGroupName": {
            "value": "[last(split(variables('roleAssignmentsResourceGroups')[copyIndex()].resourceGroupId, '/'))]"
          },
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "14989425040168770091"
            }
          },
          "parameters": {
            "roleDefinitionId": {
              "type": "string",
              "metadata": {
                "description": "Required. You can provide either the role definition GUID or its fully qualified ID in the following format: \\'/providers/Microsoft.Authorization/roleDefinitions/c2f4ef07-c644-48eb-af81-4b1b4947fb11\\'.\nYou can find the GUIDs in the ID column on the table at https://learn.microsoft.com/en-us/azure/role-based-access-control/built-in-roles.\n"
              }
            },
            "principalId": {
              "type": "string",
              "metadata": {
                "description": "Required. The Principal or Object ID of the Security Principal (User, Group, Service Principal, Managed Identity)."
              }
            },
            "resourceGroupName": {
              "type": "string",
              "defaultValue": "[resourceGroup().name]",
              "metadata": {
                "description": "Optional. Name of the Resource Group to assign the RBAC role to. If not provided, will use the current scope for deployment."
              }
            },
            "subscriptionId": {
              "type": "string",
              "defaultValue": "[subscription().subscriptionId]",
              "metadata": {
                "description": "Optional. Subscription ID of the subscription to assign the RBAC role to. If not provided, will use the current scope for deployment."
              }
            },
            "principalType": {
              "type": "string",
              "defaultValue": "",
              "allowedValues": [
                "ServicePrincipal",
                "Group",
                "User",
                "ForeignGroup",
                "Device",
                ""
              ],
              "metadata": {
                "description": "Optional. The principal type of the assigned principal ID."
              }
            }
          },
          "variables": {
            "roleDefinitionIdVar": "[if(contains(parameters('roleDefinitionId'), '/providers/Microsoft.Authorization/roleDefinitions/'), parameters('roleDefinitionId'), format('/providers/Microsoft.Authorization/roleDefinitions/{0}', parameters('roleDefinitionId')))]"
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "name": "[guid(parameters('subscriptionId'), parameters('resourceGroupName'), variables('roleDefinitionIdVar'), parameters('principalId'))]",
              "properties": {
                "roleDefinitionId": "[variables('roleDefinitionIdVar')]",
                "principalId": "[parameters('principalId')]",
                "principalType": "[if(not(empty(parameters('principalType'))), parameters('principalType'), null())]"
              }
            }
          ],
          "outputs": {
            "resourceId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Authorization/roleAssignments', guid(parameters('subscriptionId'), parameters('resourceGroupName'), variables('roleDefinitionIdVar'), parameters('principalId')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('RoleAssign-TemplateSpec-Reader-{0}', variables('deploymentSuffix'))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "principalId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
          },
          "roleDefinitionId": {
            "value": "acdd72a7-3385-48ef-bd42-f606fba81ae7"
          },
          "principalType": {
            "value": "ServicePrincipal"
          },
          "templateSpecResourceId": "[if(not(empty(parameters('sessionHostTemplateSpecResourceId'))), createObject('value', parameters('sessionHostTemplateSpecResourceId')), createObject('value', reference(resourceId('Microsoft.Resources/deployments', format('SessionHostTemplateSpec-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.templateSpecResourceId.value))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "744002619297737923"
            }
          },
          "parameters": {
            "principalId": {
              "type": "string"
            },
            "principalType": {
              "type": "string"
            },
            "templateSpecResourceId": {
              "type": "string"
            },
            "roleDefinitionId": {
              "type": "string"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2020-04-01-preview",
              "scope": "[resourceId('Microsoft.Resources/templateSpecs', last(split(parameters('templateSpecResourceId'), '/')))]",
              "name": "[guid(parameters('principalId'), parameters('roleDefinitionId'), parameters('templateSpecResourceId'))]",
              "properties": {
                "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionId'))]",
                "principalId": "[parameters('principalId')]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]",
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostTemplateSpec-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "condition": "[not(empty(parameters('customImageResourceId')))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('RoleAssign-ComputeGallery-Reader-{0}', variables('deploymentSuffix'))]",
      "subscriptionId": "[split(variables('computeGalleryResourceId'), '/')[2]]",
      "resourceGroup": "[split(variables('computeGalleryResourceId'), '/')[4]]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "principalId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
          },
          "roleDefinitionId": {
            "value": "acdd72a7-3385-48ef-bd42-f606fba81ae7"
          },
          "galleryName": "[if(empty(variables('computeGalleryResourceId')), createObject('value', ''), createObject('value', last(split(variables('computeGalleryResourceId'), '/'))))]",
          "principalType": {
            "value": "ServicePrincipal"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "2495264875924736635"
            }
          },
          "parameters": {
            "galleryName": {
              "type": "string"
            },
            "principalId": {
              "type": "string"
            },
            "principalType": {
              "type": "string"
            },
            "roleDefinitionId": {
              "type": "string"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.Compute/galleries', parameters('galleryName'))]",
              "name": "[guid(resourceId('Microsoft.Compute/galleries', parameters('galleryName')), parameters('principalId'), parameters('roleDefinitionId'))]",
              "properties": {
                "principalId": "[parameters('principalId')]",
                "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionId'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.Compute/galleries', parameters('galleryName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.Compute/galleries', parameters('galleryName')), parameters('principalId'), parameters('roleDefinitionId')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "condition": "[not(empty(parameters('artifactsUserAssignedIdentityResourceId')))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('RoleAssign-UAI-Artifacts-MngdIdOperator-{0}', variables('deploymentSuffix'))]",
      "subscriptionId": "[split(parameters('artifactsUserAssignedIdentityResourceId'), '/')[2]]",
      "resourceGroup": "[split(parameters('artifactsUserAssignedIdentityResourceId'), '/')[4]]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "principalId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
          },
          "roleDefinitionId": {
            "value": "f1a07417-d97a-45cb-824c-7a7467783830"
          },
          "principalType": {
            "value": "ServicePrincipal"
          },
          "identityName": "[if(empty(parameters('artifactsUserAssignedIdentityResourceId')), createObject('value', ''), createObject('value', last(split(parameters('artifactsUserAssignedIdentityResourceId'), '/'))))]"
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "6193311948219226423"
            }
          },
          "parameters": {
            "identityName": {
              "type": "string"
            },
            "principalId": {
              "type": "string"
            },
            "principalType": {
              "type": "string"
            },
            "roleDefinitionId": {
              "type": "string"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Authorization/roleAssignments",
              "apiVersion": "2022-04-01",
              "scope": "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName'))]",
              "name": "[guid(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName')), parameters('principalId'), parameters('roleDefinitionId'))]",
              "properties": {
                "principalId": "[parameters('principalId')]",
                "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionId'))]",
                "principalType": "[parameters('principalType')]"
              }
            }
          ],
          "outputs": {
            "roleAssignmentId": {
              "type": "string",
              "value": "[extensionResourceId(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', parameters('identityName')), parameters('principalId'), parameters('roleDefinitionId')))]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "location": {
            "value": "[parameters('location')]"
          },
          "applicationInsightsName": {
            "value": "[variables('appInsightsName')]"
          },
          "azureBlobPrivateDnsZoneResourceId": {
            "value": "[parameters('azureBlobPrivateDnsZoneResourceId')]"
          },
          "azureFunctionAppPrivateDnsZoneResourceId": {
            "value": "[parameters('azureFunctionAppPrivateDnsZoneResourceId')]"
          },
          "azureTablePrivateDnsZoneResourceId": {
            "value": "[parameters('azureTablePrivateDnsZoneResourceId')]"
          },
          "deploymentSuffix": {
            "value": "[variables('deploymentSuffix')]"
          },
          "enableApplicationInsights": {
            "value": "[not(empty(parameters('logAnalyticsWorkspaceResourceId')))]"
          },
          "enableQueueStorage": {
            "value": false
          },
          "enableTableStorage": {
            "value": true
          },
          "encryptionKeyName": {
            "value": "[variables('encryptionKeyName')]"
          },
          "encryptionKeyVaultResourceId": {
            "value": "[parameters('encryptionKeyVaultResourceId')]"
          },
          "functionAppAppSettings": {
            "value": "[union(createArray(createObject('name', 'DeploymentPrefix', 'value', format('shr-{0}', variables('uniqueStringHosts'))), createObject('name', 'DrainGracePeriodHours', 'value', string(parameters('drainGracePeriodHours'))), createObject('name', 'MinimumDrainMinutes', 'value', string(parameters('minimumDrainMinutes'))), createObject('name', 'ReplacementMode', 'value', parameters('replacementMode')), createObject('name', 'MinimumCapacityPercentage', 'value', string(parameters('minimumCapacityPercentage')))), if(equals(parameters('replacementMode'), 'DeleteFirst'), createArray(createObject('name', 'MaxDeletionsPerCycle', 'value', string(parameters('maxDeletionsPerCycle')))), createArray()), createArray(createObject('name', 'EnableProgressiveScaleUp', 'value', string(parameters('enableProgressiveScaleUp'))), createObject('name', 'FixSessionHostTags', 'value', string(parameters('fixSessionHostTags'))), createObject('name', 'GraphEndpoint', 'value', variables('graphEndpoint')), createObject('name', 'HostPoolName', 'value', variables('hostPoolName')), createObject('name', 'HostPoolResourceGroupName', 'value', variables('hostPoolResourceGroupName')), createObject('name', 'HostPoolSubscriptionId', 'value', variables('hostPoolSubscriptionId')), createObject('name', 'IncludePreExistingSessionHosts', 'value', string(parameters('includePreExistingSessionHosts'))), createObject('name', 'InitialDeploymentPercentage', 'value', string(parameters('initialDeploymentPercentage')))), if(equals(parameters('replacementMode'), 'SideBySide'), createArray(createObject('name', 'MaxDeploymentBatchSize', 'value', string(parameters('maxDeploymentBatchSize')))), createArray()), createArray(createObject('name', 'MinimumHostIndex', 'value', string(parameters('minimumHostIndex')))), if(equals(parameters('replacementMode'), 'SideBySide'), createArray(createObject('name', 'EnableShutdownRetention', 'value', string(parameters('enableShutdownRetention')))), createArray()), if(equals(parameters('replacementMode'), 'SideBySide'), createArray(createObject('name', 'ShutdownRetentionDays', 'value', string(parameters('shutdownRetentionDays')))), createArray()), createArray(createObject('name', 'RemoveEntraDevice', 'value', string(parameters('removeEntraDevice'))), createObject('name', 'RemoveIntuneDevice', 'value', string(parameters('removeIntuneDevice'))), createObject('name', 'ReplaceSessionHostOnNewImageVersionDelayDays', 'value', string(parameters('replaceSessionHostOnNewImageVersionDelayDays'))), createObject('name', 'AllowImageVersionRollback', 'value', string(parameters('allowImageVersionRollback'))), createObject('name', 'ScaleUpIncrementPercentage', 'value', string(parameters('scaleUpIncrementPercentage'))), createObject('name', 'SessionHostNameIndexLength', 'value', string(parameters('sessionHostNameIndexLength'))), createObject('name', 'SessionHostNamePrefix', 'value', parameters('sessionHostNamePrefix')), createObject('name', 'SessionHostParameters', 'value', string(union(createObject('availability', parameters('availability'), 'availabilitySetNameConv', if(not(empty(parameters('availabilitySetNameConvOverride'))), parameters('availabilitySetNameConvOverride'), if(variables('nameConvReversed'), replace(replace(replace(replace(variables('nameConv_HP_Resources'), 'RESOURCETYPE', '##-RESOURCETYPE'), 'RESOURCETYPE', variables('resourceAbbreviations').availabilitySets), 'LOCATION', variables('locations')[if(startsWith(variables('cloud'), 'us'), substring(reference(parameters('virtualMachinesResourceGroupId'), '2021-04-01', 'Full').location, 5, sub(length(reference(parameters('virtualMachinesResourceGroupId'), '2021-04-01', 'Full').location), 5)), reference(parameters('virtualMachinesResourceGroupId'), '2021-04-01', 'Full').location)].abbreviation), 'TOKEN-', ''), format('{0}-##', replace(replace(replace(variables('nameConv_HP_Resources'), 'RESOURCETYPE', variables('resourceAbbreviations').availabilitySets), 'LOCATION', variables('locations')[if(startsWith(variables('cloud'), 'us'), substring(reference(parameters('virtualMachinesResourceGroupId'), '2021-04-01', 'Full').location, 5, sub(length(reference(parameters('virtualMachinesResourceGroupId'), '2021-04-01', 'Full').location), 5)), reference(parameters('virtualMachinesResourceGroupId'), '2021-04-01', 'Full').location)].abbreviation), 'TOKEN-', '')))), 'avdAgentsDSCPackage', parameters('avdAgentsDSCPackage'), 'credentialsKeyVaultResourceId', parameters('credentialsKeyVaultResourceId'), 'diskSizeGB', parameters('diskSizeGB'), 'diskSku', parameters('diskSku'), 'enableAcceleratedNetworking', parameters('enableAcceleratedNetworking'), 'enableIPv6', parameters('enableIPv6'), 'encryptionAtHost', parameters('encryptionAtHost'), 'hostPoolResourceId', parameters('hostPoolResourceId'), 'identitySolution', parameters('identitySolution'), 'imageReference', if(empty(parameters('customImageResourceId')), createObject('publisher', parameters('imagePublisher'), 'offer', parameters('imageOffer'), 'sku', parameters('imageSku')), createObject('id', parameters('customImageResourceId'))), 'location', reference(parameters('virtualMachinesResourceGroupId'), '2021-04-01', 'Full').location, 'networkInterfaceNameConv', variables('networkInterfaceNameConv'), 'osDiskNameConv', variables('diskNameConv'), 'secureBootEnabled', parameters('secureBootEnabled'), 'securityType', parameters('securityType'), 'sessionHostNameIndexLength', parameters('sessionHostNameIndexLength'), 'subnetResourceId', parameters('virtualMachineSubnetResourceId'), 'tags', parameters('tags'), 'timeZone', parameters('timeZone'), 'virtualMachineNameConv', variables('virtualMachineNameConv'), 'virtualMachineSize', parameters('virtualMachineSize'), 'vTpmEnabled', parameters('vTpmEnabled')), variables('paramArtifactsContainerUri'), variables('paramArtifactsUserAssignedIdentityResourceId'), variables('paramAvailabilityZones'), variables('paramAvdInsightsDataCollectionRulesResourceId'), variables('paramConfidentialVMOSDiskEncryption'), variables('paramDataCollectionEndpointResourceId'), variables('paramDiskEncryptionSetResourceId'), variables('paramDomainName'), variables('paramEnableMonitoring'), variables('paramIntegrityMonitoring'), variables('paramIntuneEnrollment'), variables('paramOuPath'), variables('paramSessionHostCustomizations'), variables('paramVmInsightsDataCollectionRulesResourceId'), variables('paramFslogixConfigureSessionHosts'), variables('paramFslogixContainerType'), variables('paramFslogixLocalNetAppVolumeResourceIds'), variables('paramFslogixLocalStorageAccountResourceIds'), variables('paramFslogixOSSGroups'), variables('paramFslogixRemoteNetAppVolumeResourceIds'), variables('paramFslogixRemoteStorageAccountResourceIds'), variables('paramFslogixSizeInMBs'), variables('paramFslogixStorageService')))), createObject('name', 'SessionHostTemplate', 'value', if(not(empty(parameters('sessionHostTemplateSpecResourceId'))), parameters('sessionHostTemplateSpecResourceId'), reference(resourceId('Microsoft.Resources/deployments', format('SessionHostTemplateSpec-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.templateSpecResourceId.value)), createObject('name', 'SubscriptionId', 'value', subscription().subscriptionId), createObject('name', 'SuccessfulRunsBeforeScaleUp', 'value', string(parameters('successfulRunsBeforeScaleUp'))), createObject('name', 'Tag_DeployTimestamp', 'value', parameters('tagDeployTimestamp')), createObject('name', 'Tag_IncludeInAutomation', 'value', parameters('tagIncludeInAutomation')), createObject('name', 'Tag_PendingDrainTimestamp', 'value', parameters('tagPendingDrainTimestamp')), createObject('name', 'Tag_ShutdownTimestamp', 'value', parameters('tagShutdownTimestamp')), createObject('name', 'Tag_ScalingPlanExclusionTag', 'value', parameters('tagScalingPlanExclusionTag')), createObject('name', 'TargetSessionHostCount', 'value', string(parameters('targetSessionHostCount'))), createObject('name', 'VirtualMachinesResourceGroupName', 'value', variables('virtualMachinesResourceGroupName')), createObject('name', 'VirtualMachinesSubscriptionId', 'value', variables('virtualMachinesSubscriptionId')), createObject('name', 'WEBSITE_TIME_ZONE', 'value', parameters('timeZone'))))]"
          },
          "functionAppDelegatedSubnetResourceId": {
            "value": "[parameters('functionAppDelegatedSubnetResourceId')]"
          },
          "functionAppName": {
            "value": "[variables('functionAppName')]"
          },
          "functionAppUserAssignedIdentityResourceId": {
            "value": "[parameters('sessionHostReplacerUserAssignedIdentityResourceId')]"
          },
          "hostPoolResourceId": {
            "value": "[parameters('hostPoolResourceId')]"
          },
          "keyManagementStorageAccounts": {
            "value": "[parameters('keyManagementStorageAccounts')]"
          },
          "logAnalyticsWorkspaceResourceId": {
            "value": "[parameters('logAnalyticsWorkspaceResourceId')]"
          },
          "privateEndpoint": {
            "value": "[parameters('privateEndpoint')]"
          },
          "privateEndpointNameConv": {
            "value": "[variables('privateEndpointNameConv')]"
          },
          "privateEndpointNICNameConv": {
            "value": "[variables('privateEndpointNICNameConv')]"
          },
          "privateEndpointSubnetResourceId": {
            "value": "[parameters('privateEndpointSubnetResourceId')]"
          },
          "privateLinkScopeResourceId": {
            "value": "[parameters('privateLinkScopeResourceId')]"
          },
          "serverFarmId": "[if(not(empty(parameters('appServicePlanResourceId'))), createObject('value', parameters('appServicePlanResourceId')), createObject('value', reference(resourceId('Microsoft.Resources/deployments', format('FunctionAppHostingPlan-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.hostingPlanId.value))]",
          "storageAccountName": {
            "value": "[variables('storageAccountName')]"
          },
          "storageAccountRoleDefinitionIds": {
            "value": [
              "0a9a7e1f-b9d0-4cc4-a60d-0319b160aaa3"
            ]
          },
          "tags": {
            "value": "[parameters('tags')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "3952633927330306878"
            }
          },
          "parameters": {
            "applicationInsightsName": {
              "type": "string"
            },
            "azureBlobPrivateDnsZoneResourceId": {
              "type": "string"
            },
            "azureFunctionAppPrivateDnsZoneResourceId": {
              "type": "string"
            },
            "azureQueuePrivateDnsZoneResourceId": {
              "type": "string",
              "defaultValue": ""
            },
            "azureTablePrivateDnsZoneResourceId": {
              "type": "string",
              "defaultValue": ""
            },
            "deploymentSuffix": {
              "type": "string"
            },
            "enableApplicationInsights": {
              "type": "bool"
            },
            "enableQueueStorage": {
              "type": "bool",
              "defaultValue": true
            },
            "enableTableStorage": {
              "type": "bool",
              "defaultValue": true
            },
            "encryptionKeyName": {
              "type": "string"
            },
            "encryptionKeyVaultResourceId": {
              "type": "string"
            },
            "functionAppDelegatedSubnetResourceId": {
              "type": "string"
            },
            "functionAppName": {
              "type": "string"
            },
            "functionAppAppSettings": {
              "type": "array"
            },
            "functionAppUserAssignedIdentityResourceId": {
              "type": "string",
              "defaultValue": ""
            },
            "hostPoolResourceId": {
              "type": "string"
            },
            "keyManagementStorageAccounts": {
              "type": "string",
              "allowedValues": [
                "MicrosoftManaged",
                "CustomerManaged",
                "CustomerManagedHSM"
              ]
            },
            "location": {
              "type": "string"
            },
            "logAnalyticsWorkspaceResourceId": {
              "type": "string"
            },
            "privateEndpoint": {
              "type": "bool"
            },
            "privateEndpointNameConv": {
              "type": "string"
            },
            "privateEndpointNICNameConv": {
              "type": "string"
            },
            "privateEndpointSubnetResourceId": {
              "type": "string"
            },
            "privateLinkScopeResourceId": {
              "type": "string"
            },
            "storageAccountRoleDefinitionIds": {
              "type": "array",
              "defaultValue": []
            },
            "serverFarmId": {
              "type": "string"
            },
            "storageAccountName": {
              "type": "string"
            },
            "tags": {
              "type": "object"
            }
          },
          "variables": {
            "cloudSuffix": "[replace(replace(environment().resourceManager, 'https://management.', ''), '/', '')]",
            "privateEndpointVnetName": "[if(and(not(empty(parameters('privateEndpointSubnetResourceId'))), parameters('privateEndpoint')), split(parameters('privateEndpointSubnetResourceId'), '/')[8], '')]",
            "peVnetId": "[if(less(length(variables('privateEndpointVnetName')), 37), variables('privateEndpointVnetName'), uniqueString(variables('privateEndpointVnetName')))]",
            "storageSubResources": "[union(createArray('blob'), if(parameters('enableQueueStorage'), createArray('queue'), createArray()), if(parameters('enableTableStorage'), createArray('table'), createArray()))]",
            "azureStoragePrivateDnsZoneResourceIds": "[union(createArray(parameters('azureBlobPrivateDnsZoneResourceId')), if(and(parameters('enableQueueStorage'), not(empty(parameters('azureQueuePrivateDnsZoneResourceId')))), createArray(parameters('azureQueuePrivateDnsZoneResourceId')), createArray()), if(and(parameters('enableTableStorage'), not(empty(parameters('azureTablePrivateDnsZoneResourceId')))), createArray(parameters('azureTablePrivateDnsZoneResourceId')), createArray()))]",
            "storageAccountRoleDefinitions": "[union(createArray('ba92f5b4-2d11-453d-a403-e96b0029c9fe', '974c5e8b-45b9-4653-ba55-5f855dd0fb88'), parameters('storageAccountRoleDefinitionIds'))]"
          },
          "resources": [
            {
              "type": "Microsoft.Storage/storageAccounts/blobServices",
              "apiVersion": "2024-01-01",
              "name": "[format('{0}/{1}', parameters('storageAccountName'), 'default')]",
              "dependsOn": [
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
              ]
            },
            {
              "type": "Microsoft.Storage/storageAccounts",
              "apiVersion": "2024-01-01",
              "name": "[parameters('storageAccountName')]",
              "location": "[parameters('location')]",
              "tags": "[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Storage/storageAccounts'), createObject()))]",
              "sku": {
                "name": "Standard_LRS"
              },
              "kind": "StorageV2",
              "identity": "[if(not(equals(parameters('keyManagementStorageAccounts'), 'MicrosoftManaged')), createObject('type', 'SystemAssigned'), null())]",
              "properties": {
                "accessTier": "Hot",
                "allowBlobPublicAccess": false,
                "allowCrossTenantReplication": false,
                "allowedCopyScope": "[if(parameters('privateEndpoint'), 'PrivateLink', 'AAD')]",
                "allowSharedKeyAccess": false,
                "defaultToOAuthAuthentication": true,
                "dnsEndpointType": "Standard",
                "encryption": {
                  "requireInfrastructureEncryption": true,
                  "services": "[union(createObject('blob', createObject('keyType', 'Account', 'enabled', true())), if(parameters('enableQueueStorage'), createObject('queue', createObject('keyType', 'Account', 'enabled', true())), createObject()), if(parameters('enableTableStorage'), createObject('table', createObject('keyType', 'Account', 'enabled', true())), createObject()))]"
                },
                "minimumTlsVersion": "TLS1_2",
                "networkAcls": {
                  "bypass": "AzureServices",
                  "virtualNetworkRules": [],
                  "ipRules": [],
                  "defaultAction": "[if(parameters('privateEndpoint'), 'Deny', 'Allow')]"
                },
                "publicNetworkAccess": "[if(parameters('privateEndpoint'), 'Disabled', 'Enabled')]",
                "sasPolicy": {
                  "expirationAction": "Log",
                  "sasExpirationPeriod": "180.00:00:00"
                },
                "supportsHttpsTrafficOnly": true
              }
            },
            {
              "copy": {
                "name": "privateEndpoints_storage",
                "count": "[length(variables('storageSubResources'))]"
              },
              "condition": "[parameters('privateEndpoint')]",
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2023-04-01",
              "name": "[replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', variables('storageSubResources')[copyIndex()]), 'RESOURCE', parameters('storageAccountName')), 'VNETID', variables('peVnetId'))]",
              "location": "[parameters('location')]",
              "properties": {
                "customNetworkInterfaceName": "[replace(replace(replace(parameters('privateEndpointNICNameConv'), 'SUBRESOURCE', variables('storageSubResources')[copyIndex()]), 'RESOURCE', parameters('storageAccountName')), 'VNETID', variables('peVnetId'))]",
                "privateLinkServiceConnections": [
                  {
                    "name": "[replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', variables('storageSubResources')[copyIndex()]), 'RESOURCE', parameters('storageAccountName')), 'VNETID', variables('peVnetId'))]",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]",
                      "groupIds": [
                        "[variables('storageSubResources')[copyIndex()]]"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[parameters('privateEndpointSubnetResourceId')]"
                }
              },
              "tags": "[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Network/privateEndpoints'), createObject()))]",
              "dependsOn": [
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
              ]
            },
            {
              "copy": {
                "name": "privateDnsZoneGroups_storage",
                "count": "[length(range(0, length(variables('azureStoragePrivateDnsZoneResourceIds'))))]"
              },
              "condition": "[and(parameters('privateEndpoint'), not(empty(variables('azureStoragePrivateDnsZoneResourceIds')[range(0, length(variables('azureStoragePrivateDnsZoneResourceIds')))[copyIndex()]])))]",
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', variables('storageSubResources')[range(0, length(variables('azureStoragePrivateDnsZoneResourceIds')))[copyIndex()]]), 'RESOURCE', parameters('storageAccountName')), 'VNETID', variables('peVnetId')), parameters('storageAccountName'))]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "ipconfig1",
                    "properties": {
                      "privateDnsZoneId": "[variables('azureStoragePrivateDnsZoneResourceIds')[range(0, length(variables('azureStoragePrivateDnsZoneResourceIds')))[copyIndex()]]]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateEndpoints', replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', variables('storageSubResources')[range(0, length(variables('azureStoragePrivateDnsZoneResourceIds')))[copyIndex()]]), 'RESOURCE', parameters('storageAccountName')), 'VNETID', variables('peVnetId')))]",
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
              ]
            },
            {
              "condition": "[parameters('enableApplicationInsights')]",
              "type": "microsoft.insights/diagnosticSettings",
              "apiVersion": "2017-05-01-preview",
              "scope": "[resourceId('Microsoft.Storage/storageAccounts/blobServices', parameters('storageAccountName'), 'default')]",
              "name": "[format('{0}-blob-diagnosticSettings', parameters('storageAccountName'))]",
              "properties": {
                "logs": [
                  {
                    "category": "StorageWrite",
                    "enabled": true
                  }
                ],
                "metrics": [
                  {
                    "category": "Transaction",
                    "enabled": true
                  }
                ],
                "workspaceId": "[parameters('logAnalyticsWorkspaceResourceId')]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.Storage/storageAccounts/blobServices', parameters('storageAccountName'), 'default')]"
              ]
            },
            {
              "condition": "[parameters('enableApplicationInsights')]",
              "type": "Microsoft.Insights/components",
              "apiVersion": "2020-02-02",
              "name": "[parameters('applicationInsightsName')]",
              "location": "[parameters('location')]",
              "tags": "[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Insights/components'), createObject()))]",
              "properties": {
                "Application_Type": "web",
                "publicNetworkAccessForIngestion": "[if(empty(parameters('privateLinkScopeResourceId')), 'Enabled', 'Disabled')]",
                "publicNetworkAccessForQuery": "[if(empty(parameters('privateLinkScopeResourceId')), 'Enabled', 'Disabled')]",
                "WorkspaceResourceId": "[parameters('logAnalyticsWorkspaceResourceId')]"
              },
              "kind": "web"
            },
            {
              "type": "Microsoft.Web/sites",
              "apiVersion": "2024-11-01",
              "name": "[parameters('functionAppName')]",
              "location": "[parameters('location')]",
              "tags": "[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Web/sites'), createObject()))]",
              "kind": "functionapp",
              "identity": "[if(not(empty(parameters('functionAppUserAssignedIdentityResourceId'))), createObject('type', 'UserAssigned', 'userAssignedIdentities', createObject(format('{0}', parameters('functionAppUserAssignedIdentityResourceId')), createObject())), createObject('type', 'SystemAssigned'))]",
              "properties": {
                "clientAffinityEnabled": false,
                "httpsOnly": true,
                "publicNetworkAccess": "[if(parameters('privateEndpoint'), 'Disabled', 'Enabled')]",
                "serverFarmId": "[parameters('serverFarmId')]",
                "siteConfig": {
                  "alwaysOn": true,
                  "appSettings": "[union(if(empty(parameters('functionAppUserAssignedIdentityResourceId')), createArray(), createArray(createObject('name', 'AzureWebJobsStorage__clientId', 'value', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[2], split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[4]), 'Microsoft.ManagedIdentity/userAssignedIdentities', last(split(parameters('functionAppUserAssignedIdentityResourceId'), '/'))), '2024-11-30').clientId), createObject('name', 'UserAssignedIdentityClientId', 'value', reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[2], split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[4]), 'Microsoft.ManagedIdentity/userAssignedIdentities', last(split(parameters('functionAppUserAssignedIdentityResourceId'), '/'))), '2024-11-30').clientId))), createArray(createObject('name', 'AzureWebJobsStorage__credential', 'value', 'managedidentity'), createObject('name', 'AzureWebJobsStorage__blobServiceUri', 'value', format('https://{0}.blob.{1}', parameters('storageAccountName'), environment().suffixes.storage))), if(parameters('enableQueueStorage'), createArray(createObject('name', 'AzureWebJobsStorage__queueServiceUri', 'value', format('https://{0}.queue.{1}', parameters('storageAccountName'), environment().suffixes.storage))), createArray()), if(parameters('enableTableStorage'), createArray(createObject('name', 'AzureWebJobsStorage__tableServiceUri', 'value', format('https://{0}.table.{1}', parameters('storageAccountName'), environment().suffixes.storage))), createArray()), createArray(createObject('name', 'FUNCTIONS_EXTENSION_VERSION', 'value', '~4'), createObject('name', 'FUNCTIONS_WORKER_RUNTIME', 'value', 'powershell'), createObject('name', 'WEBSITE_LOAD_USER_PROFILE', 'value', '1'), createObject('name', 'EnvironmentName', 'value', environment().name), createObject('name', 'ResourceManagerUri', 'value', environment().resourceManager), createObject('name', 'StorageSuffix', 'value', environment().suffixes.storage), createObject('name', 'TenantId', 'value', subscription().tenantId)), if(parameters('enableApplicationInsights'), createArray(createObject('name', 'APPLICATIONINSIGHTS_CONNECTION_STRING', 'value', reference(resourceId('Microsoft.Insights/components', parameters('applicationInsightsName')), '2020-02-02').ConnectionString)), createArray()), parameters('functionAppAppSettings'))]",
                  "cors": {
                    "allowedOrigins": [
                      "[format('{0}', environment().portal)]",
                      "[format('https://functions-next.{0}', variables('cloudSuffix'))]",
                      "[format('https://functions-staging.{0}', variables('cloudSuffix'))]",
                      "[format('https://functions.{0}', variables('cloudSuffix'))]"
                    ],
                    "supportCredentials": false
                  },
                  "ftpsState": "Disabled",
                  "functionAppScaleLimit": 200,
                  "minimumElasticInstanceCount": 0,
                  "netFrameworkVersion": "v6.0",
                  "powerShellVersion": "7.4",
                  "ipSecurityRestrictions": "[if(parameters('privateEndpoint'), createArray(createObject('ipAddress', 'AzureCloud', 'action', 'Allow', 'tag', 'ServiceTag', 'priority', 100, 'name', 'AzureCloud'), createObject('ipAddress', 'Any', 'action', 'Deny', 'priority', 2147483647, 'name', 'Deny all', 'description', 'Deny all access')), null())]",
                  "ipSecurityRestrictionsDefaultAction": "[if(parameters('privateEndpoint'), 'Deny', null())]",
                  "scmIpSecurityRestrictions": "[if(parameters('privateEndpoint'), createArray(createObject('ipAddress', 'Any', 'action', 'Deny', 'priority', 2147483647, 'name', 'Deny all', 'description', 'Deny all access')), null())]",
                  "scmIpSecurityRestrictionsDefaultAction": "[if(parameters('privateEndpoint'), 'Deny', null())]",
                  "scmIpSecurityRestrictionsUseMain": "[if(parameters('privateEndpoint'), true(), null())]",
                  "publicNetworkAccess": "Enabled",
                  "use32BitWorkerProcess": false
                },
                "outboundVnetRouting": "[if(empty(parameters('functionAppDelegatedSubnetResourceId')), null(), createObject('allTraffic', true(), 'applicationTraffic', true()))]",
                "virtualNetworkSubnetId": "[if(not(empty(parameters('functionAppDelegatedSubnetResourceId'))), parameters('functionAppDelegatedSubnetResourceId'), null())]"
              },
              "dependsOn": [
                "[resourceId('Microsoft.Insights/components', parameters('applicationInsightsName'))]",
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
              ]
            },
            {
              "condition": "[parameters('privateEndpoint')]",
              "type": "Microsoft.Network/privateEndpoints",
              "apiVersion": "2023-04-01",
              "name": "[replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', 'sites'), 'RESOURCE', parameters('functionAppName')), 'VNETID', variables('peVnetId'))]",
              "location": "[parameters('location')]",
              "properties": {
                "customNetworkInterfaceName": "[replace(replace(replace(parameters('privateEndpointNICNameConv'), 'SUBRESOURCE', 'sites'), 'RESOURCE', parameters('functionAppName')), 'VNETID', variables('peVnetId'))]",
                "privateLinkServiceConnections": [
                  {
                    "name": "[replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', 'sites'), 'RESOURCE', parameters('functionAppName')), 'VNETID', variables('peVnetId'))]",
                    "properties": {
                      "privateLinkServiceId": "[resourceId('Microsoft.Web/sites', parameters('functionAppName'))]",
                      "groupIds": [
                        "sites"
                      ]
                    }
                  }
                ],
                "subnet": {
                  "id": "[parameters('privateEndpointSubnetResourceId')]"
                }
              },
              "tags": "[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Network/privateEndpoints'), createObject()))]",
              "dependsOn": [
                "[resourceId('Microsoft.Web/sites', parameters('functionAppName'))]"
              ]
            },
            {
              "condition": "[and(parameters('privateEndpoint'), not(empty(parameters('azureFunctionAppPrivateDnsZoneResourceId'))))]",
              "type": "Microsoft.Network/privateEndpoints/privateDnsZoneGroups",
              "apiVersion": "2021-08-01",
              "name": "[format('{0}/{1}', replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', 'sites'), 'RESOURCE', parameters('functionAppName')), 'VNETID', variables('peVnetId')), 'default')]",
              "properties": {
                "privateDnsZoneConfigs": [
                  {
                    "name": "ipconfig1",
                    "properties": {
                      "privateDnsZoneId": "[parameters('azureFunctionAppPrivateDnsZoneResourceId')]"
                    }
                  }
                ]
              },
              "dependsOn": [
                "[resourceId('Microsoft.Network/privateEndpoints', replace(replace(replace(parameters('privateEndpointNameConv'), 'SUBRESOURCE', 'sites'), 'RESOURCE', parameters('functionAppName')), 'VNETID', variables('peVnetId')))]"
              ]
            },
            {
              "condition": "[not(equals(parameters('keyManagementStorageAccounts'), 'MicrosoftManaged'))]",
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "[format('encryptionKey-storageAccount-{0}', parameters('deploymentSuffix'))]",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "encryptionKeyName": {
                    "value": "[parameters('encryptionKeyName')]"
                  },
                  "hostPoolResourceId": {
                    "value": "[parameters('hostPoolResourceId')]"
                  },
                  "deploymentSuffix": {
                    "value": "[parameters('deploymentSuffix')]"
                  },
                  "keyManagementStorageAccounts": {
                    "value": "[parameters('keyManagementStorageAccounts')]"
                  },
                  "keyVaultResourceId": {
                    "value": "[parameters('encryptionKeyVaultResourceId')]"
                  },
                  "storageAccountPrincipalId": {
                    "value": "[reference(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2024-01-01', 'full').identity.principalId]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "13153425445175558891"
                    }
                  },
                  "parameters": {
                    "hostPoolResourceId": {
                      "type": "string"
                    },
                    "keyManagementStorageAccounts": {
                      "type": "string"
                    },
                    "keyVaultResourceId": {
                      "type": "string"
                    },
                    "keyExpirationInDays": {
                      "type": "int",
                      "defaultValue": 180
                    },
                    "storageAccountPrincipalId": {
                      "type": "string"
                    },
                    "encryptionKeyName": {
                      "type": "string"
                    },
                    "deploymentSuffix": {
                      "type": "string"
                    }
                  },
                  "variables": {
                    "keyVaultName": "[last(split(parameters('keyVaultResourceId'), '/'))]",
                    "keyVaultSubscriptionId": "[split(parameters('keyVaultResourceId'), '/')[2]]",
                    "keyVaultResourceGroup": "[split(parameters('keyVaultResourceId'), '/')[4]]"
                  },
                  "resources": [
                    {
                      "type": "Microsoft.Resources/deployments",
                      "apiVersion": "2025-04-01",
                      "name": "[format('StorageEncryptionKey-{0}', parameters('deploymentSuffix'))]",
                      "subscriptionId": "[variables('keyVaultSubscriptionId')]",
                      "resourceGroup": "[variables('keyVaultResourceGroup')]",
                      "properties": {
                        "expressionEvaluationOptions": {
                          "scope": "inner"
                        },
                        "mode": "Incremental",
                        "parameters": {
                          "attributesExportable": {
                            "value": false
                          },
                          "keySize": {
                            "value": 4096
                          },
                          "keyVaultName": {
                            "value": "[variables('keyVaultName')]"
                          },
                          "kty": "[if(contains(parameters('keyManagementStorageAccounts'), 'HSM'), createObject('value', 'RSA-HSM'), createObject('value', 'RSA'))]",
                          "name": {
                            "value": "[parameters('encryptionKeyName')]"
                          },
                          "rotationPolicy": {
                            "value": {
                              "attributes": {
                                "expiryTime": "[format('P{0}D', string(parameters('keyExpirationInDays')))]"
                              },
                              "lifetimeActions": [
                                {
                                  "action": {
                                    "type": "Notify"
                                  },
                                  "trigger": {
                                    "timeBeforeExpiry": "P10D"
                                  }
                                },
                                {
                                  "action": {
                                    "type": "Rotate"
                                  },
                                  "trigger": {
                                    "timeAfterCreate": "[format('P{0}D', string(sub(parameters('keyExpirationInDays'), 7)))]"
                                  }
                                }
                              ]
                            }
                          },
                          "tags": {
                            "value": {
                              "cm-resource-parent": "[toLower(parameters('hostPoolResourceId'))]"
                            }
                          }
                        },
                        "template": {
                          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                          "contentVersion": "1.0.0.0",
                          "metadata": {
                            "_generator": {
                              "name": "bicep",
                              "version": "0.40.2.10011",
                              "templateHash": "3537915357704697883"
                            }
                          },
                          "parameters": {
                            "keyVaultName": {
                              "type": "string"
                            },
                            "name": {
                              "type": "string"
                            },
                            "tags": {
                              "type": "object",
                              "defaultValue": {}
                            },
                            "attributesEnabled": {
                              "type": "bool",
                              "defaultValue": true
                            },
                            "attributesExp": {
                              "type": "int",
                              "defaultValue": -1
                            },
                            "attributesNbf": {
                              "type": "int",
                              "defaultValue": -1
                            },
                            "curveName": {
                              "type": "string",
                              "defaultValue": "P-256"
                            },
                            "attributesExportable": {
                              "type": "bool",
                              "defaultValue": false
                            },
                            "keyOps": {
                              "type": "array",
                              "defaultValue": []
                            },
                            "keySize": {
                              "type": "int",
                              "defaultValue": -1
                            },
                            "kty": {
                              "type": "string",
                              "defaultValue": "EC"
                            },
                            "release_policy": {
                              "type": "object",
                              "defaultValue": {}
                            },
                            "rotationPolicy": {
                              "type": "object",
                              "defaultValue": {}
                            }
                          },
                          "resources": [
                            {
                              "type": "Microsoft.KeyVault/vaults/keys",
                              "apiVersion": "2022-07-01",
                              "name": "[format('{0}/{1}', parameters('keyVaultName'), parameters('name'))]",
                              "tags": "[if(empty(parameters('tags')), null(), parameters('tags'))]",
                              "properties": {
                                "attributes": {
                                  "enabled": "[parameters('attributesEnabled')]",
                                  "exportable": "[parameters('attributesExportable')]",
                                  "exp": "[if(not(equals(parameters('attributesExp'), -1)), parameters('attributesExp'), null())]",
                                  "nbf": "[if(not(equals(parameters('attributesNbf'), -1)), parameters('attributesNbf'), null())]"
                                },
                                "curveName": "[parameters('curveName')]",
                                "keyOps": "[parameters('keyOps')]",
                                "keySize": "[if(not(equals(parameters('keySize'), -1)), parameters('keySize'), null())]",
                                "kty": "[parameters('kty')]",
                                "release_policy": "[if(empty(parameters('release_policy')), null(), parameters('release_policy'))]",
                                "rotationPolicy": "[if(empty(parameters('rotationPolicy')), null(), parameters('rotationPolicy'))]"
                              }
                            }
                          ],
                          "outputs": {
                            "name": {
                              "type": "string",
                              "value": "[parameters('name')]"
                            },
                            "resourceId": {
                              "type": "string",
                              "value": "[resourceId('Microsoft.KeyVault/vaults/keys', parameters('keyVaultName'), parameters('name'))]"
                            }
                          }
                        }
                      }
                    },
                    {
                      "type": "Microsoft.Resources/deployments",
                      "apiVersion": "2025-04-01",
                      "name": "[format('RA-Encryption-Key-{0}', parameters('deploymentSuffix'))]",
                      "subscriptionId": "[variables('keyVaultSubscriptionId')]",
                      "resourceGroup": "[variables('keyVaultResourceGroup')]",
                      "properties": {
                        "expressionEvaluationOptions": {
                          "scope": "inner"
                        },
                        "mode": "Incremental",
                        "parameters": {
                          "keyName": {
                            "value": "[parameters('encryptionKeyName')]"
                          },
                          "keyVaultName": {
                            "value": "[variables('keyVaultName')]"
                          },
                          "principalId": {
                            "value": "[parameters('storageAccountPrincipalId')]"
                          },
                          "principalType": {
                            "value": "ServicePrincipal"
                          },
                          "roleDefinitionId": {
                            "value": "e147488a-f6f5-4113-8e2d-b22465e65bf6"
                          }
                        },
                        "template": {
                          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                          "contentVersion": "1.0.0.0",
                          "metadata": {
                            "_generator": {
                              "name": "bicep",
                              "version": "0.40.2.10011",
                              "templateHash": "11110463680693508695"
                            }
                          },
                          "parameters": {
                            "keyVaultName": {
                              "type": "string"
                            },
                            "principalId": {
                              "type": "string"
                            },
                            "principalType": {
                              "type": "string"
                            },
                            "keyName": {
                              "type": "string"
                            },
                            "roleDefinitionId": {
                              "type": "string"
                            }
                          },
                          "resources": [
                            {
                              "type": "Microsoft.Authorization/roleAssignments",
                              "apiVersion": "2022-04-01",
                              "scope": "[resourceId('Microsoft.KeyVault/vaults/keys', parameters('keyVaultName'), parameters('keyName'))]",
                              "name": "[guid(resourceId('Microsoft.KeyVault/vaults/keys', parameters('keyVaultName'), parameters('keyName')), parameters('principalId'), parameters('roleDefinitionId'))]",
                              "properties": {
                                "principalId": "[parameters('principalId')]",
                                "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionId'))]",
                                "principalType": "[parameters('principalType')]"
                              }
                            }
                          ],
                          "outputs": {
                            "roleAssignmentId": {
                              "type": "string",
                              "value": "[extensionResourceId(resourceId('Microsoft.KeyVault/vaults/keys', parameters('keyVaultName'), parameters('keyName')), 'Microsoft.Authorization/roleAssignments', guid(resourceId('Microsoft.KeyVault/vaults/keys', parameters('keyVaultName'), parameters('keyName')), parameters('principalId'), parameters('roleDefinitionId')))]"
                            }
                          }
                        }
                      }
                    }
                  ],
                  "outputs": {
                    "encryptionKeyName": {
                      "type": "string",
                      "value": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', variables('keyVaultSubscriptionId'), variables('keyVaultResourceGroup')), 'Microsoft.Resources/deployments', format('StorageEncryptionKey-{0}', parameters('deploymentSuffix'))), '2025-04-01').outputs.name.value]"
                    }
                  }
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
              ]
            },
            {
              "condition": "[and(parameters('enableApplicationInsights'), not(empty(parameters('privateLinkScopeResourceId'))))]",
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "[format('PrivateLlinkScope-{0}', parameters('deploymentSuffix'))]",
              "subscriptionId": "[subscription().subscriptionId]",
              "location": "[resourceGroup().location]",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "privateLinkScopeResourceId": {
                    "value": "[parameters('privateLinkScopeResourceId')]"
                  },
                  "scopedResourceIds": {
                    "value": [
                      "[resourceId('Microsoft.Insights/components', parameters('applicationInsightsName'))]"
                    ]
                  },
                  "deploymentSuffix": {
                    "value": "[parameters('deploymentSuffix')]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2018-05-01/subscriptionDeploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "14014809249376933795"
                    }
                  },
                  "parameters": {
                    "privateLinkScopeResourceId": {
                      "type": "string"
                    },
                    "scopedResourceIds": {
                      "type": "array"
                    },
                    "deploymentSuffix": {
                      "type": "string"
                    }
                  },
                  "resources": [
                    {
                      "type": "Microsoft.Resources/deployments",
                      "apiVersion": "2025-04-01",
                      "name": "[format('addScopedResources-{0}', parameters('deploymentSuffix'))]",
                      "subscriptionId": "[split(parameters('privateLinkScopeResourceId'), '/')[2]]",
                      "resourceGroup": "[split(parameters('privateLinkScopeResourceId'), '/')[4]]",
                      "properties": {
                        "expressionEvaluationOptions": {
                          "scope": "inner"
                        },
                        "mode": "Incremental",
                        "parameters": {
                          "privateLinkScopeResourceId": {
                            "value": "[parameters('privateLinkScopeResourceId')]"
                          },
                          "scopedResourceIds": {
                            "value": "[parameters('scopedResourceIds')]"
                          }
                        },
                        "template": {
                          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                          "contentVersion": "1.0.0.0",
                          "metadata": {
                            "_generator": {
                              "name": "bicep",
                              "version": "0.40.2.10011",
                              "templateHash": "2919254825473931406"
                            }
                          },
                          "parameters": {
                            "scopedResourceIds": {
                              "type": "array"
                            },
                            "privateLinkScopeResourceId": {
                              "type": "string"
                            }
                          },
                          "resources": [
                            {
                              "copy": {
                                "name": "scopedResources",
                                "count": "[length(parameters('scopedResourceIds'))]"
                              },
                              "type": "Microsoft.Insights/privateLinkScopes/scopedResources",
                              "apiVersion": "2021-07-01-preview",
                              "name": "[format('{0}/{1}', last(split(parameters('privateLinkScopeResourceId'), '/')), uniqueString(parameters('scopedResourceIds')[copyIndex()]))]",
                              "properties": {
                                "linkedResourceId": "[parameters('scopedResourceIds')[copyIndex()]]"
                              }
                            }
                          ]
                        }
                      }
                    }
                  ]
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Insights/components', parameters('applicationInsightsName'))]"
              ]
            },
            {
              "copy": {
                "name": "roleAssignment_storageAccount",
                "count": "[length(variables('storageAccountRoleDefinitions'))]"
              },
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "[format('set-role-assignment-storage-{0}-{1}', uniqueString(variables('storageAccountRoleDefinitions')[copyIndex()]), parameters('deploymentSuffix'))]",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "principalIds": {
                    "value": [
                      "[if(not(empty(parameters('functionAppUserAssignedIdentityResourceId'))), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[2], split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[4]), 'Microsoft.ManagedIdentity/userAssignedIdentities', last(split(parameters('functionAppUserAssignedIdentityResourceId'), '/'))), '2024-11-30').principalId, reference(resourceId('Microsoft.Web/sites', parameters('functionAppName')), '2024-11-01', 'full').identity.principalId)]"
                    ]
                  },
                  "principalType": {
                    "value": "ServicePrincipal"
                  },
                  "roleDefinitionId": {
                    "value": "[variables('storageAccountRoleDefinitions')[copyIndex()]]"
                  },
                  "storageAccountResourceId": {
                    "value": "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "14494216343304504955"
                    }
                  },
                  "parameters": {
                    "principalIds": {
                      "type": "array"
                    },
                    "principalType": {
                      "type": "string"
                    },
                    "storageAccountResourceId": {
                      "type": "string"
                    },
                    "roleDefinitionId": {
                      "type": "string"
                    }
                  },
                  "resources": [
                    {
                      "copy": {
                        "name": "roleAssignments",
                        "count": "[length(range(0, length(parameters('principalIds'))))]"
                      },
                      "type": "Microsoft.Authorization/roleAssignments",
                      "apiVersion": "2020-04-01-preview",
                      "scope": "[resourceId('Microsoft.Storage/storageAccounts', last(split(parameters('storageAccountResourceId'), '/')))]",
                      "name": "[guid(parameters('principalIds')[range(0, length(parameters('principalIds')))[copyIndex()]], parameters('roleDefinitionId'), parameters('storageAccountResourceId'))]",
                      "properties": {
                        "roleDefinitionId": "[resourceId('Microsoft.Authorization/roleDefinitions', parameters('roleDefinitionId'))]",
                        "principalId": "[parameters('principalIds')[range(0, length(parameters('principalIds')))[copyIndex()]]]",
                        "principalType": "[parameters('principalType')]"
                      }
                    }
                  ]
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Web/sites', parameters('functionAppName'))]",
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
              ]
            },
            {
              "condition": "[not(equals(parameters('keyManagementStorageAccounts'), 'MicrosoftManaged'))]",
              "type": "Microsoft.Resources/deployments",
              "apiVersion": "2025-04-01",
              "name": "[format('update-encryptionKey-storageAccount-{0}', parameters('deploymentSuffix'))]",
              "properties": {
                "expressionEvaluationOptions": {
                  "scope": "inner"
                },
                "mode": "Incremental",
                "parameters": {
                  "storageAccountName": {
                    "value": "[parameters('storageAccountName')]"
                  },
                  "storageAccountSku": {
                    "value": "[reference(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2024-01-01', 'full').sku]"
                  },
                  "encryptionKeyName": {
                    "value": "[reference(resourceId('Microsoft.Resources/deployments', format('encryptionKey-storageAccount-{0}', parameters('deploymentSuffix'))), '2025-04-01').outputs.encryptionKeyName.value]"
                  },
                  "keyVaultResourceId": {
                    "value": "[parameters('encryptionKeyVaultResourceId')]"
                  },
                  "location": {
                    "value": "[parameters('location')]"
                  },
                  "privateEndpoint": {
                    "value": "[parameters('privateEndpoint')]"
                  },
                  "storageAccountKind": {
                    "value": "[reference(resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName')), '2024-01-01', 'full').kind]"
                  }
                },
                "template": {
                  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
                  "contentVersion": "1.0.0.0",
                  "metadata": {
                    "_generator": {
                      "name": "bicep",
                      "version": "0.40.2.10011",
                      "templateHash": "3943722023111753482"
                    }
                  },
                  "parameters": {
                    "keyVaultResourceId": {
                      "type": "string"
                    },
                    "location": {
                      "type": "string"
                    },
                    "privateEndpoint": {
                      "type": "bool"
                    },
                    "storageAccountKind": {
                      "type": "string"
                    },
                    "storageAccountName": {
                      "type": "string"
                    },
                    "storageAccountSku": {
                      "type": "object"
                    },
                    "encryptionKeyName": {
                      "type": "string"
                    }
                  },
                  "variables": {
                    "keyVaultName": "[last(split(parameters('keyVaultResourceId'), '/'))]",
                    "keyVaultSubscriptionId": "[split(parameters('keyVaultResourceId'), '/')[2]]",
                    "keyVaultResourceGroup": "[split(parameters('keyVaultResourceId'), '/')[4]]"
                  },
                  "resources": [
                    {
                      "type": "Microsoft.Storage/storageAccounts",
                      "apiVersion": "2024-01-01",
                      "name": "[parameters('storageAccountName')]",
                      "location": "[parameters('location')]",
                      "sku": "[parameters('storageAccountSku')]",
                      "kind": "[parameters('storageAccountKind')]",
                      "identity": {
                        "type": "SystemAssigned"
                      },
                      "properties": {
                        "allowBlobPublicAccess": false,
                        "allowedCopyScope": "[if(parameters('privateEndpoint'), 'PrivateLink', 'AAD')]",
                        "allowCrossTenantReplication": false,
                        "allowSharedKeyAccess": false,
                        "encryption": {
                          "keySource": "Microsoft.KeyVault",
                          "keyvaultproperties": {
                            "keyname": "[parameters('encryptionKeyName')]",
                            "keyvaulturi": "[reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', variables('keyVaultSubscriptionId'), variables('keyVaultResourceGroup')), 'Microsoft.KeyVault/vaults', variables('keyVaultName')), '2024-11-01').vaultUri]"
                          },
                          "requireInfrastructureEncryption": true
                        },
                        "minimumTlsVersion": "TLS1_2",
                        "networkAcls": {
                          "bypass": "AzureServices",
                          "virtualNetworkRules": [],
                          "ipRules": [],
                          "defaultAction": "[if(parameters('privateEndpoint'), 'Deny', 'Allow')]"
                        },
                        "publicNetworkAccess": "[if(parameters('privateEndpoint'), 'Disabled', 'Enabled')]",
                        "sasPolicy": {
                          "expirationAction": "Log",
                          "sasExpirationPeriod": "180.00:00:00"
                        }
                      }
                    }
                  ]
                }
              },
              "dependsOn": [
                "[resourceId('Microsoft.Resources/deployments', format('encryptionKey-storageAccount-{0}', parameters('deploymentSuffix')))]",
                "[resourceId('Microsoft.Web/sites', parameters('functionAppName'))]",
                "[resourceId('Microsoft.Storage/storageAccounts', parameters('storageAccountName'))]"
              ]
            }
          ],
          "outputs": {
            "functionAppName": {
              "type": "string",
              "value": "[parameters('functionAppName')]"
            },
            "functionAppPrincipalId": {
              "type": "string",
              "value": "[if(not(empty(parameters('functionAppUserAssignedIdentityResourceId'))), reference(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[2], split(parameters('functionAppUserAssignedIdentityResourceId'), '/')[4]), 'Microsoft.ManagedIdentity/userAssignedIdentities', last(split(parameters('functionAppUserAssignedIdentityResourceId'), '/'))), '2024-11-30').principalId, reference(resourceId('Microsoft.Web/sites', parameters('functionAppName')), '2024-11-01', 'full').identity.principalId)]"
            },
            "applicationInsightsResourceId": {
              "type": "string",
              "value": "[if(parameters('enableApplicationInsights'), resourceId('Microsoft.Insights/components', parameters('applicationInsightsName')), '')]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('FunctionAppHostingPlan-{0}', variables('deploymentSuffix')))]",
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostTemplateSpec-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('SessionHostReplacerFunction-{0}', variables('deploymentSuffix'))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "files": {
            "value": {
              "run.ps1": "[variables('$fxv#2')]",
              "../profile.ps1": "[variables('$fxv#3')]",
              "../requirements.psd1": "[variables('$fxv#4')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.Core.psm1": "[variables('$fxv#5')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.Deployment.psm1": "[variables('$fxv#6')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.ImageManagement.psm1": "[variables('$fxv#7')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.Planning.psm1": "[variables('$fxv#8')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.DeviceCleanup.psm1": "[variables('$fxv#9')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.Lifecycle.psm1": "[variables('$fxv#10')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.Monitoring.psm1": "[variables('$fxv#11')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.psm1": "[variables('$fxv#12')]",
              "../Modules/SessionHostReplacer/SessionHostReplacer.psd1": "[variables('$fxv#13')]"
            }
          },
          "functionAppName": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppName.value]"
          },
          "functionName": {
            "value": "session-host-replacer"
          },
          "schedule": {
            "value": "[parameters('timerSchedule')]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "180185396569108974"
            }
          },
          "parameters": {
            "files": {
              "type": "object"
            },
            "functionAppName": {
              "type": "string"
            },
            "functionName": {
              "type": "string"
            },
            "schedule": {
              "type": "string"
            }
          },
          "resources": [
            {
              "type": "Microsoft.Web/sites/functions",
              "apiVersion": "2024-11-01",
              "name": "[format('{0}/{1}', parameters('functionAppName'), parameters('functionName'))]",
              "properties": {
                "config": {
                  "disabled": false,
                  "bindings": [
                    {
                      "type": "timerTrigger",
                      "direction": "in",
                      "name": "Timer",
                      "schedule": "[parameters('schedule')]"
                    }
                  ]
                },
                "files": "[parameters('files')]"
              }
            }
          ]
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    },
    {
      "condition": "[and(parameters('deployWorkbook'), not(empty(parameters('logAnalyticsWorkspaceResourceId'))))]",
      "type": "Microsoft.Resources/deployments",
      "apiVersion": "2025-04-01",
      "name": "[format('SessionHostReplacerWorkbook-{0}', variables('deploymentSuffix'))]",
      "properties": {
        "expressionEvaluationOptions": {
          "scope": "inner"
        },
        "mode": "Incremental",
        "parameters": {
          "workbookName": {
            "value": "[variables('workbookName')]"
          },
          "location": {
            "value": "[parameters('workbookLocation')]"
          },
          "applicationInsightsResourceId": {
            "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.applicationInsightsResourceId.value]"
          },
          "tags": {
            "value": "[union(createObject('cm-resource-parent', parameters('hostPoolResourceId')), coalesce(tryGet(parameters('tags'), 'Microsoft.Insights/workbooks'), createObject()))]"
          }
        },
        "template": {
          "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
          "contentVersion": "1.0.0.0",
          "metadata": {
            "_generator": {
              "name": "bicep",
              "version": "0.40.2.10011",
              "templateHash": "2631345058714834099"
            }
          },
          "parameters": {
            "workbookName": {
              "type": "string",
              "metadata": {
                "description": "Required. The name of the workbook."
              }
            },
            "location": {
              "type": "string",
              "metadata": {
                "description": "Required. The location for the workbook."
              }
            },
            "applicationInsightsResourceId": {
              "type": "string",
              "metadata": {
                "description": "Required. The resource ID of the Application Insights instance for this region."
              }
            },
            "tags": {
              "type": "object",
              "defaultValue": {},
              "metadata": {
                "description": "Optional. Tags for the workbook."
              }
            }
          },
          "variables": {
            "$fxv#0": {
              "version": "Notebook/1.0",
              "items": [
                {
                  "type": 1,
                  "content": {
                    "json": "## AVD Session Host Replacer - Enterprise Dashboard\n\nThis dashboard provides real-time visibility across all Session Host Replacer deployments in your subscription, including replacement status, deployment progress, and host pool consistency.\n\n---"
                  },
                  "name": "title"
                },
                {
                  "type": 9,
                  "content": {
                    "version": "KqlParameterItem/1.0",
                    "parameters": [
                      {
                        "id": "f1e2d3c4-5b6a-7h8i-9j0k-1l2m3n4o5p6q",
                        "version": "KqlParameterItem/1.0",
                        "name": "ApplicationInsights",
                        "type": 5,
                        "isRequired": true,
                        "multiSelect": true,
                        "quote": "'",
                        "delimiter": ",",
                        "query": "resources\n| where type == 'microsoft.insights/components'\n| where name contains 'sessionhostreplacer'\n| order by name asc\n| project value = id, label = name, selected = true",
                        "typeSettings": {
                          "additionalResourceOptions": [
                            "value::all"
                          ],
                          "showDefault": false
                        },
                        "queryType": 1,
                        "resourceType": "microsoft.resourcegraph/resources",
                        "value": [
                          "value::all"
                        ],
                        "label": "Application Insights"
                      },
                      {
                        "id": "a1b2c3d4-5e6f-7g8h-9i0j-1k2l3m4n5o6p",
                        "version": "KqlParameterItem/1.0",
                        "name": "HostPool",
                        "type": 2,
                        "isRequired": true,
                        "query": "traces\n| where timestamp > ago(30d)\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where isnotempty(HostPoolName)\n| where HostPoolName !in ('bool', 'string', 'int', 'object', 'array')\n| distinct HostPoolName\n| order by HostPoolName asc\n| project value = HostPoolName, label = HostPoolName, selected = false\n| union (datatable(value:string, label:string, selected:bool) [\n    \"*\", \"All Host Pools\", true\n])",
                        "crossComponentResources": [
                          "{ApplicationInsights}"
                        ],
                        "typeSettings": {
                          "additionalResourceOptions": [],
                          "showDefault": false
                        },
                        "queryType": 0,
                        "resourceType": "microsoft.insights/components",
                        "value": "*",
                        "label": "Host Pool"
                      },
                      {
                        "id": "b8f9c5e7-6f88-4c5a-a7c3-5e8d9f0c1a2b",
                        "version": "KqlParameterItem/1.0",
                        "name": "TimeRange",
                        "type": 4,
                        "isRequired": true,
                        "value": {
                          "durationMs": 86400000
                        },
                        "typeSettings": {
                          "selectableValues": [
                            {
                              "durationMs": 3600000
                            },
                            {
                              "durationMs": 14400000
                            },
                            {
                              "durationMs": 43200000
                            },
                            {
                              "durationMs": 86400000
                            },
                            {
                              "durationMs": 172800000
                            },
                            {
                              "durationMs": 604800000
                            },
                            {
                              "durationMs": 2592000000
                            }
                          ]
                        },
                        "timeContext": {
                          "durationMs": 86400000
                        },
                        "label": "Time Range"
                      }
                    ],
                    "style": "pills",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components"
                  },
                  "name": "parameters"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Configuration Settings"
                  },
                  "name": "config-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| where message contains \"SETTINGS |\"\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where isnotempty(HostPoolName)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| extend ReplacementMode = extract(@\"ReplacementMode: ([A-Za-z]+)\", 1, message)\n| extend MinimumDrainMinutes = extract(@\"MinimumDrainMinutes: (\\d+)\", 1, message)\n| extend DrainGracePeriodHours = extract(@\"DrainGracePeriodHours: (\\d+)\", 1, message)\n| extend MinimumCapacityPercent = extract(@\"MinimumCapacityPercent: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend MaxDeletionsPerCycle = extract(@\"MaxDeletionsPerCycle: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend EnableProgressiveScaleUp = extract(@\"EnableProgressiveScaleUp: ([A-Za-z]+)\", 1, message)\n| extend InitialDeploymentPercent = extract(@\"InitialDeploymentPercent: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend ScaleUpIncrementPercent = extract(@\"ScaleUpIncrementPercent: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend SuccessfulRunsBeforeScaleUp = extract(@\"SuccessfulRunsBeforeScaleUp: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend MaxDeploymentBatchSize = extract(@\"MaxDeploymentBatchSize: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend MinimumHostIndex = extract(@\"MinimumHostIndex: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend EnableShutdownRetention = extract(@\"EnableShutdownRetention: ([A-Za-z\\/]+)\", 1, message)\n| extend ShutdownRetentionDays = extract(@\"ShutdownRetentionDays: ([\\d\\/A-Za-z]+)\", 1, message)\n| extend TargetSessionHostCount = extract(@\"TargetSessionHostCount: ([\\d\\/A-Za-z]+)\", 1, message)\n| summarize arg_max(timestamp, *) by HostPoolName\n| project \n    ['Host Pool'] = HostPoolName,\n    ['Replacement Mode'] = ReplacementMode,\n    ['Min Drain (min)'] = MinimumDrainMinutes,\n    ['Grace Period (hrs)'] = DrainGracePeriodHours,\n    ['Target Count'] = case(TargetSessionHostCount == \"0\" or TargetSessionHostCount == \"Auto\", \"Auto-Detect\", TargetSessionHostCount),\n    ['Progressive Scale-Up'] = case(EnableProgressiveScaleUp == \"True\", strcat(\" Enabled (\", InitialDeploymentPercent, \"%  +\", ScaleUpIncrementPercent, \"% every \", SuccessfulRunsBeforeScaleUp, \" success)\"), \" Disabled\"),\n    ['Min Capacity %'] = case(ReplacementMode == \"DeleteFirst\", strcat(MinimumCapacityPercent, \"%\"), \"N/A\"),\n    ['Max Deletions/Cycle'] = case(ReplacementMode == \"DeleteFirst\", MaxDeletionsPerCycle, \"N/A\"),\n    ['Max Batch Size'] = case(ReplacementMode == \"SideBySide\", MaxDeploymentBatchSize, \"N/A\"),\n    ['Min Host Index'] = case(ReplacementMode == \"SideBySide\", MinimumHostIndex, \"N/A\"),\n    ['Shutdown Retention'] = case(ReplacementMode == \"SideBySide\" and EnableShutdownRetention == \"True\", strcat(\" Enabled (\", ShutdownRetentionDays, \" days)\"), ReplacementMode == \"SideBySide\" and EnableShutdownRetention != \"True\", \" Disabled\", \"N/A\")",
                    "size": 3,
                    "title": "Function App Settings",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Replacement Mode",
                          "formatter": 18,
                          "formatOptions": {
                            "thresholdsOptions": "colors",
                            "thresholdsGrid": [
                              {
                                "operator": "==",
                                "thresholdValue": "DeleteFirst",
                                "representation": "blue",
                                "text": " DeleteFirst"
                              },
                              {
                                "operator": "==",
                                "thresholdValue": "SideBySide",
                                "representation": "green",
                                "text": " SideBySide"
                              },
                              {
                                "operator": "Default",
                                "thresholdValue": null,
                                "representation": "gray",
                                "text": "{0}"
                              }
                            ]
                          }
                        },
                        {
                          "columnMatch": "Progressive Scale-Up",
                          "formatter": 0
                        },
                        {
                          "columnMatch": "Min Capacity %",
                          "formatter": 0
                        },
                        {
                          "columnMatch": "Max Deletions/Cycle",
                          "formatter": 0
                        },
                        {
                          "columnMatch": "Max Batch Size",
                          "formatter": 0
                        },
                        {
                          "columnMatch": "Min Host Index",
                          "formatter": 0
                        },
                        {
                          "columnMatch": "Shutdown Retention",
                          "formatter": 0
                        }
                      ],
                      "labelSettings": []
                    }
                  },
                  "customWidth": "100",
                  "name": "config-table"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "---\n###  Key Performance Indicators"
                  },
                  "name": "kpi-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nlet deployingFromRunning = toscalar(\n    traces\n    | where timestamp {TimeRange}\n    | extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n    | where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n    | where message contains \"running deployments\" and message contains \"Found\"\n    | extend RunningCount = toint(extract(@\"Found (\\d+) running deployments\", 1, message))\n    | where isnotempty(RunningCount)\n    | summarize arg_max(timestamp, *) by HostPoolName\n    | summarize sum(RunningCount)\n);\nlet deployingFromSubmitted = toscalar(\n    traces\n    | where timestamp > ago(2h)\n    | extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n    | where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n    | where message contains \"Deployment submitted:\"\n    | extend VMCount = toint(extract(@\"Deployment submitted: (\\d+) VMs\", 1, message))\n    | where isnotempty(VMCount)\n    | summarize arg_max(timestamp, *)\n    | project VMCount\n);\ntraces\n| where timestamp {TimeRange}\n| where message contains \"METRICS\"\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where isnotempty(HostPoolName)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| extend Total = toint(extract(@\"Total:\\s*(\\d+)\", 1, message))\n| extend Enabled = toint(extract(@\"Enabled:\\s*(\\d+)\", 1, message))\n| extend Target = toint(extract(@\"Target:\\s*(\\d+)\", 1, message))\n| extend ToReplace = toint(extract(@\"ToReplace:\\s*(\\d+)\", 1, message))\n| extend InDrain = toint(extract(@\"InDrain:\\s*(\\d+)\", 1, message))\n| extend PendingDelete = toint(extract(@\"PendingDelete:\\s*(\\d+)\", 1, message))\n| extend ShutdownRetention = toint(extract(@\"ShutdownRetention:\\s*(\\d+)\", 1, message))\n| extend ToDeployNow = toint(extract(@\"ToDeployNow:\\s*(\\d+)\", 1, message))\n| where isnotempty(Total)\n| summarize arg_max(timestamp, *) by HostPoolName\n| extend Deploying = toint(coalesce(deployingFromRunning, 0) + coalesce(deployingFromSubmitted, 0))\n| project \n    Column1 = 'Total Hosts', Value1 = Total,\n    Column2 = 'Enabled', Value2 = Enabled,\n    Column3 = 'Target', Value3 = Target,\n    Column4 = 'To Replace', Value4 = ToReplace,\n    Column5 = 'In Drain', Value5 = InDrain,\n    Column6 = 'Pending Delete', Value6 = PendingDelete,\n    Column7 = 'Shutdown Retention', Value7 = ShutdownRetention,\n    Column8 = 'To Deploy', Value8 = ToDeployNow,\n    Column9 = 'Currently Deploying', Value9 = Deploying\n| mv-expand Column = pack_array(Column1, Column2, Column3, Column4, Column5, Column6, Column7, Column8, Column9), Value = pack_array(Value1, Value2, Value3, Value4, Value5, Value6, Value7, Value8, Value9)\n| project Column = tostring(Column), Value = toint(Value)",
                    "size": 4,
                    "title": "Current Status",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "tiles",
                    "tileSettings": {
                      "titleContent": {
                        "columnMatch": "Column",
                        "formatter": 1
                      },
                      "leftContent": {
                        "columnMatch": "Value",
                        "formatter": 12,
                        "formatOptions": {
                          "palette": "auto"
                        },
                        "numberFormat": {
                          "unit": 17,
                          "options": {
                            "style": "decimal",
                            "useGrouping": false,
                            "maximumFractionDigits": 2,
                            "maximumSignificantDigits": 3
                          }
                        }
                      },
                      "showBorder": true
                    }
                  },
                  "customWidth": "100",
                  "name": "kpi-tiles"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Schedule Information"
                  },
                  "name": "schedule-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nlet results = traces\n| where timestamp > ago(7d)\n| where message contains \"SCHEDULE\" and message contains \"completed\"\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where isnotempty(HostPoolName)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| summarize LastRun = max(timestamp) by HostPoolName\n| extend MinutesSinceLastRun = datetime_diff('minute', now(), LastRun)\n| extend Status = case(\n    MinutesSinceLastRun > 45, \" Delayed\",\n    MinutesSinceLastRun > 35, \" Due Soon\",\n    \" On Schedule\"\n)\n| project HostPool = HostPoolName, ['Last Execution'] = LastRun, ['Minutes Ago'] = MinutesSinceLastRun, Status;\nresults\n| union (datatable(HostPool:string, ['Last Execution']:datetime, ['Minutes Ago']:long, Status:string) ['No Data', datetime(null), 0, ' No Data'])\n| where HostPool != 'No Data' or toscalar(results | count) == 0\n| order by HostPool asc",
                    "size": 0,
                    "title": "Recent Execution History",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Last Execution",
                          "formatter": 6
                        },
                        {
                          "columnMatch": "Minutes Ago",
                          "formatter": 1
                        },
                        {
                          "columnMatch": "Status",
                          "formatter": 18,
                          "formatOptions": {
                            "thresholdsOptions": "icons",
                            "thresholdsGrid": [
                              {
                                "operator": "contains",
                                "thresholdValue": "Delayed",
                                "representation": "warning",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "contains",
                                "thresholdValue": "Due",
                                "representation": "2",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "Default",
                                "thresholdValue": null,
                                "representation": "success",
                                "text": "{0}{1}"
                              }
                            ]
                          }
                        }
                      ]
                    }
                  },
                  "name": "schedule-table"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Host Pool Consistency"
                  },
                  "name": "consistency-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nlet results = traces\n| where timestamp {TimeRange}\n| where message contains \"IMAGE_INFO\"\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where isnotempty(HostPoolName)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| extend ImageType = extract(@\"Type:\\s*([^\\|]+)\", 1, message)\n| extend Publisher = extract(@\"Publisher:\\s*([^\\|]+)\", 1, message)\n| extend Offer = extract(@\"Offer:\\s*([^\\|]+)\", 1, message)\n| extend Sku = extract(@\"Sku:\\s*([^\\|]+)\", 1, message)\n| extend Gallery = extract(@\"Gallery:\\s*([^\\|]+)\", 1, message)\n| extend ImageDefinition = extract(@\"ImageDefinition:\\s*([^\\|]+)\", 1, message)\n| extend Version = extract(@\"Version:\\s*([^\\s]+)\", 1, message)\n| where isnotempty(ImageType)\n| summarize arg_max(timestamp, *) by HostPoolName\n| project \n    HostPool = HostPoolName,\n    ['Image Type'] = trim_end(@\"\\s\", ImageType),\n    ['Image Details'] = case(\n        trim_end(@\"\\s\", ImageType) == \"Marketplace\", strcat(trim_end(@\"\\s\", Publisher), \"/\", trim_end(@\"\\s\", Offer), \"/\", trim_end(@\"\\s\", Sku)),\n        trim_end(@\"\\s\", ImageType) == \"Gallery\", strcat(trim_end(@\"\\s\", Gallery), \"/\", trim_end(@\"\\s\", ImageDefinition)),\n        \"Unknown\"\n    ),\n    Version = trim_end(@\"\\s\", Version),\n    ['Last Updated'] = timestamp;\nresults\n| union (datatable(HostPool:string, ['Image Type']:string, ['Image Details']:string, Version:string, ['Last Updated']:datetime) ['No Data', 'N/A', 'N/A', 'N/A', datetime(null)])\n| where HostPool != 'No Data' or toscalar(results | count) == 0\n| order by HostPool asc",
                    "size": 0,
                    "title": "Current Image Configuration",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Image Type",
                          "formatter": 18,
                          "formatOptions": {
                            "thresholdsOptions": "icons",
                            "thresholdsGrid": [
                              {
                                "operator": "==",
                                "thresholdValue": "Marketplace",
                                "representation": "success",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "==",
                                "thresholdValue": "Gallery",
                                "representation": "info",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "Default",
                                "thresholdValue": null,
                                "representation": "unknown",
                                "text": "{0}{1}"
                              }
                            ]
                          }
                        },
                        {
                          "columnMatch": "Last Updated",
                          "formatter": 6
                        }
                      ]
                    }
                  },
                  "customWidth": "60",
                  "name": "image-table"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| where message contains \"METRICS\"\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where isnotempty(HostPoolName)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| extend Total = toint(extract(@\"Total:\\s*(\\d+)\", 1, message))\n| extend Enabled = toint(extract(@\"Enabled:\\s*(\\d+)\", 1, message))\n| extend ShutdownRetention = toint(extract(@\"ShutdownRetention:\\s*(\\d+)\", 1, message))\n| extend ToReplace = toint(extract(@\"ToReplace:\\s*(\\d+)\", 1, message))\n| where isnotempty(Total)\n| summarize arg_max(timestamp, *) by HostPoolName\n| extend ActiveHosts = Total - coalesce(ShutdownRetention, 0)\n| extend OnLatestImage = ActiveHosts - ToReplace\n| extend PercentGood = round(todouble(OnLatestImage) / todouble(ActiveHosts) * 100.0, 2)\n| project ['Host Pool'] = HostPoolName, ['On Latest Image'] = OnLatestImage, ['Needs Replacement'] = ToReplace, ['% Compliant'] = PercentGood\n| order by ['Host Pool'] asc",
                    "size": 0,
                    "title": "Image Version Compliance",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "On Latest Image",
                          "formatter": 4,
                          "formatOptions": {
                            "palette": "green"
                          }
                        },
                        {
                          "columnMatch": "Needs Replacement",
                          "formatter": 4,
                          "formatOptions": {
                            "palette": "orange"
                          }
                        },
                        {
                          "columnMatch": "% Compliant",
                          "formatter": 18,
                          "formatOptions": {
                            "thresholdsOptions": "colors",
                            "thresholdsGrid": [
                              {
                                "operator": "<",
                                "thresholdValue": "25",
                                "representation": "redBright",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "<",
                                "thresholdValue": "75",
                                "representation": "yellow",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "Default",
                                "thresholdValue": null,
                                "representation": "green",
                                "text": "{0}{1}"
                              }
                            ]
                          },
                          "numberFormat": {
                            "unit": 1,
                            "options": {
                              "style": "decimal",
                              "minimumFractionDigits": 2,
                              "maximumFractionDigits": 2
                            }
                          }
                        }
                      ]
                    }
                  },
                  "customWidth": "40",
                  "name": "consistency-table"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Deployment Progress"
                  },
                  "name": "deployment-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where (message contains \"Previous deployment\" and message contains \"succeeded\") or (message contains \"Previous deployment\" and message contains \"failed\")\n| summarize Count = count() by bin(timestamp, 1h)\n| render timechart",
                    "size": 0,
                    "title": "Deployment Activity Over Time",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components"
                  },
                  "customWidth": "50",
                  "name": "deployment-timeline"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where (message contains \"Previous deployment\" and (message contains \"succeeded\" or message contains \"failed\")) or (message contains \"Deployment submitted successfully\")\n| extend Status = case(\n    message contains \"succeeded\" or message contains \"submitted successfully\", \"Success\",\n    message contains \"failed\", \"Failed\",\n    \"Unknown\")\n| summarize Count = count() by Status\n| render piechart",
                    "size": 0,
                    "title": "Deployment Success Rate",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components"
                  },
                  "customWidth": "50",
                  "name": "consistency-pie"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nlet results = traces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where message contains \"ConsecutiveSuccesses\"\n| extend ConsecutiveSuccesses = toint(extract(@\"ConsecutiveSuccesses: (\\d+)\", 1, message))\n| where isnotempty(ConsecutiveSuccesses)\n| summarize arg_max(timestamp, *) by HostPoolName\n| extend Status = case(\n    ConsecutiveSuccesses == 0, \" Starting\",\n    ConsecutiveSuccesses < 3, \" In Progress\",\n    \" Stable\"\n)\n| project HostPool = HostPoolName, ['Consecutive Successes'] = ConsecutiveSuccesses, Status, ['Last Updated'] = timestamp;\nresults\n| union (datatable(HostPool:string, ['Consecutive Successes']:int, Status:string, ['Last Updated']:datetime) ['No Data', 0, ' No deployment activity', datetime(null)])\n| where HostPool != 'No Data' or toscalar(results | count) == 0\n| order by HostPool asc",
                    "size": 0,
                    "title": "Progressive Scale-Up Status",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Consecutive Successes",
                          "formatter": 4,
                          "formatOptions": {
                            "palette": "green"
                          }
                        },
                        {
                          "columnMatch": "Status",
                          "formatter": 18,
                          "formatOptions": {
                            "thresholdsOptions": "icons",
                            "thresholdsGrid": [
                              {
                                "operator": "contains",
                                "thresholdValue": "Starting",
                                "representation": "failed",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "contains",
                                "thresholdValue": "Progress",
                                "representation": "warning",
                                "text": "{0}{1}"
                              },
                              {
                                "operator": "Default",
                                "thresholdValue": null,
                                "representation": "success",
                                "text": "{0}{1}"
                              }
                            ]
                          }
                        },
                        {
                          "columnMatch": "Last Updated",
                          "formatter": 6
                        }
                      ]
                    }
                  },
                  "customWidth": "50",
                  "name": "scaleup-table"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Session Drain Status"
                  },
                  "name": "drain-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nlet results = traces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where message contains \"is in drain mode\" or (message contains \"drain\" and message contains \"sessions\" and message contains \"timestamp\")\n| project timestamp, message\n| top 20 by timestamp desc;\nresults\n| union (print timestamp = now(), message = ' No hosts currently in drain mode')\n| where message != ' No hosts currently in drain mode' or toscalar(results | count) == 0\n| top 20 by timestamp desc",
                    "size": 0,
                    "title": "Hosts Currently in Drain Mode",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "SessionCount",
                          "formatter": 4,
                          "formatOptions": {
                            "palette": "blue"
                          }
                        },
                        {
                          "columnMatch": "LastCheck",
                          "formatter": 6
                        }
                      ]
                    }
                  },
                  "name": "drain-table"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Failed Deployment Cleanup"
                  },
                  "name": "failed-deployment-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where message contains \"failed deployment\" or message contains \"Failed deployment\"\n| where message !contains \"Found 0\"\n| project timestamp, HostPoolName, Message = message\n| order by timestamp desc\n| take 20\n| union (print timestamp = now(), HostPoolName = 'N/A', Message = ' No failed deployments in selected time range')\n| order by timestamp desc\n| take 20",
                    "size": 0,
                    "title": "Recent Failed Deployment Activity",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "timestamp",
                          "formatter": 6
                        },
                        {
                          "columnMatch": "Message",
                          "formatter": 7,
                          "formatOptions": {
                            "linkTarget": "GenericDetails"
                          }
                        }
                      ]
                    }
                  },
                  "customWidth": "50",
                  "name": "failed-deployment-table"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nlet results = traces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where message contains \"session hosts from failed deployments\" or message contains \"Marking session host\" and message contains \"failed deployment\"\n| extend VmCount = case(\n    message contains \"Found\", toint(extract(@\"Found (\\d+) session hosts\", 1, message)),\n    1\n)\n| summarize HostsMarkedForCleanup = sum(VmCount) by bin(timestamp, 1h);\nresults\n| union (print timestamp = now(), HostsMarkedForCleanup = 0)\n| where HostsMarkedForCleanup > 0 or toscalar(results | count) == 0\n| render timechart",
                    "size": 0,
                    "title": "VMs Marked for Cleanup from Failed Deployments",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components"
                  },
                  "customWidth": "50",
                  "name": "failed-deployment-cleanup-chart"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Deletion Activity"
                  },
                  "name": "deletion-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where message contains \"Deleting session host\"\n| summarize Count = count() by bin(timestamp, 1h)\n| render areachart",
                    "size": 0,
                    "title": "Deletion Operations Over Time",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components"
                  },
                  "name": "deletion-chart"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Errors and Warnings"
                  },
                  "name": "errors-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nunion traces, exceptions\n| where severityLevel >= 2\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, coalesce(message, outerMessage, ''))\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| project timestamp, message = coalesce(message, outerMessage), severityLevel\n| extend Severity = case(\n    severityLevel == 4, \" Critical\",\n    severityLevel == 3, \" Error\",\n    severityLevel == 2, \" Warning\",\n    \" Info\")\n| summarize Count = count() by Severity, bin(timestamp, 1h)\n| render barchart",
                    "size": 0,
                    "title": "Errors and Warnings Over Time",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components"
                  },
                  "customWidth": "50",
                  "name": "errors-chart"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\nlet results = union traces, exceptions\n| where severityLevel >= 3\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, coalesce(message, outerMessage, ''))\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| project timestamp, message = coalesce(message, outerMessage), severityLevel\n| where message !contains \"The listener for function\"\n| top 20 by timestamp desc\n| project Timestamp = timestamp, Message = substring(message, 0, 200);\nresults\n| union (datatable(Timestamp:datetime, Message:string) [datetime(null), ' No errors in selected time range'])\n| where Message != ' No errors in selected time range' or toscalar(results | count) == 0\n| take 20",
                    "size": 0,
                    "title": "Recent Errors (Top 20)",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "visualization": "table",
                    "gridSettings": {
                      "formatters": [
                        {
                          "columnMatch": "Timestamp",
                          "formatter": 6
                        }
                      ]
                    }
                  },
                  "customWidth": "50",
                  "name": "errors-table"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "###  Historical Trends"
                  },
                  "name": "trends-header"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| where message contains \"SessionHostReplacer function started\"\n| summarize Executions = count() by bin(timestamp, 1h)\n| render timechart",
                    "size": 0,
                    "title": "Function Execution Frequency",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components"
                  },
                  "customWidth": "50",
                  "name": "frequency-chart"
                },
                {
                  "type": 3,
                  "content": {
                    "version": "KqlItem/1.0",
                    "query": "let hostPoolFilter = '{HostPool}';\ntraces\n| where timestamp {TimeRange}\n| where message contains \"METRICS\"\n| extend HostPoolName = extract(@\"\\[([a-z0-9\\-]+)\\]\", 1, message)\n| where isnotempty(HostPoolName)\n| where hostPoolFilter == '*' or HostPoolName == hostPoolFilter\n| extend Total = toint(extract(@\"Total:\\s*(\\d+)\", 1, message))\n| where isnotempty(Total)\n| extend TimeBin = bin(timestamp, 1h)\n| summarize arg_max(timestamp, Total) by HostPoolName, TimeBin\n| summarize ['Total Hosts'] = sum(Total) by TimeBin\n| project TimeBin, ['Total Hosts']\n| render timechart",
                    "size": 0,
                    "title": "Total Host Pool Size Over Time",
                    "timeContext": {
                      "durationMs": 0
                    },
                    "timeContextFromParameter": "TimeRange",
                    "crossComponentResources": [
                      "{ApplicationInsights}"
                    ],
                    "queryType": 0,
                    "resourceType": "microsoft.insights/components",
                    "chartSettings": {
                      "showLegend": true,
                      "showDataPoints": false,
                      "showMetrics": false,
                      "ySettings": {
                        "numberFormatSettings": {
                          "unit": 0,
                          "options": {
                            "style": "decimal",
                            "useGrouping": true
                          }
                        }
                      }
                    }
                  },
                  "customWidth": "50",
                  "name": "hostpool-size-chart"
                },
                {
                  "type": 1,
                  "content": {
                    "json": "---\n\n **Tip:** Use the time range selector at the top to adjust the dashboard view. For more detailed analysis, click on any chart to explore the underlying data in Application Insights."
                  },
                  "name": "footer"
                }
              ],
              "fallbackResourceIds": [
                "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/placeholder/providers/Microsoft.Insights/components/placeholder"
              ],
              "$schema": "https://github.com/Microsoft/Application-Insights-Workbooks/blob/master/schema/workbook.json"
            },
            "workbookDisplayName": "AVD Session Host Replacer - Enterprise Dashboard",
            "workbookSourceId": "[parameters('applicationInsightsResourceId')]",
            "workbookTemplateBase": "[variables('$fxv#0')]",
            "workbookTemplateWithFallback": "[union(variables('workbookTemplateBase'), createObject('fallbackResourceIds', createArray(parameters('applicationInsightsResourceId'))))]"
          },
          "resources": [
            {
              "type": "Microsoft.Insights/workbooks",
              "apiVersion": "2023-06-01",
              "name": "[parameters('workbookName')]",
              "location": "[parameters('location')]",
              "tags": "[parameters('tags')]",
              "kind": "shared",
              "properties": {
                "displayName": "[variables('workbookDisplayName')]",
                "serializedData": "[string(variables('workbookTemplateWithFallback'))]",
                "version": "1.0",
                "sourceId": "[variables('workbookSourceId')]",
                "category": "workbook"
              }
            }
          ],
          "outputs": {
            "workbookId": {
              "type": "string",
              "value": "[resourceId('Microsoft.Insights/workbooks', parameters('workbookName'))]"
            },
            "workbookName": {
              "type": "string",
              "value": "[parameters('workbookName')]"
            }
          }
        }
      },
      "dependsOn": [
        "[resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix')))]"
      ]
    }
  ],
  "outputs": {
    "functionAppName": {
      "type": "string",
      "metadata": {
        "description": "The name of the deployed function app."
      },
      "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppName.value]"
    },
    "functionAppPrincipalId": {
      "type": "string",
      "metadata": {
        "description": "The principal ID of the identity used by the function app (either user-assigned or system-assigned)."
      },
      "value": "[reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerFunctionApp-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.functionAppPrincipalId.value]"
    },
    "identityType": {
      "type": "string",
      "metadata": {
        "description": "The type of managed identity used by the function app."
      },
      "value": "[if(not(empty(parameters('sessionHostReplacerUserAssignedIdentityResourceId'))), 'UserAssigned', 'SystemAssigned')]"
    },
    "workbookId": {
      "type": "string",
      "metadata": {
        "description": "The resource ID of the monitoring workbook."
      },
      "value": "[if(and(parameters('deployWorkbook'), not(empty(parameters('logAnalyticsWorkspaceResourceId')))), reference(resourceId('Microsoft.Resources/deployments', format('SessionHostReplacerWorkbook-{0}', variables('deploymentSuffix'))), '2025-04-01').outputs.workbookId.value, '')]"
    }
  }
}