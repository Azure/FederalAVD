{
  "mode": "All",
  "metadata": {
    "category": "Compute"
  },
  "parameters": {
    "fslogixContainerType": {
      "type": "String",
      "allowedValues": [
        "CloudCacheProfileContainer",
        "CloudCacheProfileOfficeContainer",
        "ProfileContainer",
        "ProfileOfficeContainer"
      ],
      "defaultValue": "ProfileContainer",
      "metadata": {
        "displayName": "FSLogix Container Type(s)",
        "description": "The Container Type(s) for FSLogix"
      }
    },
    "fslogixFileShareNames": {
      "type": "Array",
      "allowedValues": [
        "profile-containers",
        "office-containers"
      ],
      "defaultValue": [
        "profile-containers"
      ],
      "metadata": {
        "displayName": "FSLogix File Share Name(s)",
        "description": "The File Share Name(s) for FSLogix"
      }
    },
    "fslogixLocalStorageAccountResourceIds": {
      "type": "Array",
      "metadata": {
        "displayName": "Local FSLogix Azure Storage Account Resource Ids",
        "description": "A sorted array of local Azure Storage Account Resource Ids"
      }
    },
    "fslogixLocalNetAppServerFqdns": {
      "type": "Array",
      "metadata": {
        "displayName": "Local FSLogix NetApp Server FQDNs",
        "description": "A sorted array of local NetApp Server FQDNs"
      }
    },
    "fslogixOSSGroups": {
      "type": "Array",
      "metadata": {
        "displayName": "An array of objects containing the FSLogix Shard Groups",
        "description": ""
      }
    },
    "fslogixRemoteStorageAccountResourceIds": {
      "type": "Array",
      "metadata": {
        "displayName": "Remote FSLogix Azure Storage Account Resource Ids",
        "description": "A sorted array of remote Azure Storage Account Resource Ids"
      }
    },
    "fslogixRemoteNetAppServerFqdns": {
      "type": "Array",
      "metadata": {
        "displayName": "Remote FSLogix NetApp Server FQDNs",
        "description": "A sorted array of remote NetApp Server FQDNs"
      }
    },
    "fslogixStorageService": {
      "type": "String",
      "allowedValues": [
        "AzureNetAppFiles",
        "AzureFiles"
      ],
      "defaultValue": "AzureFiles",
      "metadata": {
        "displayName": "FSLogix Storage Service",
        "description": "The Storage Service for FSLogix"
      }
    },
    "identitySolution": {
      "type": "String",
      "allowedValues": [
        "ActiveDirectoryDomainServices",
        "EntraDomainServices",
        "EntraId",
        "EntraIdIntuneEnrollment"
      ],
      "metadata": {
        "displayName": "Identity Solution",
        "description": "The AVD Identity Solution"
      }
    },
    "runCommandName": {
      "type": "String",
      "defaultValue": "ConfigureFSLogix",
      "metadata": {
        "displayName": "Run Command Name",
        "description": "The name of the Run Command"
      }
    }
  },
  "policyRule": {
    "if": {
      "allOf": [
        {
          "field": "type",
          "equals": "Microsoft.Compute/virtualMachines"
        },
        {
          "field": "Microsoft.Compute/virtualMachines/storageProfile.osDisk.osType",
          "equals": "Windows"
        }
      ]
    },
    "then": {
      "effect": "DeployIfNotExists",
      "details": {
        "roleDefinitionIds": [
          "/providers/Microsoft.Authorization/roleDefinitions/9980e02c-c2be-4d73-94e8-173b1dc7cf3c"
        ],
        "type": "Microsoft.Compute/virtualMachines/runCommands",
        "existenceCondition": {
          "allOf": [
            {
              "count": {
                "field": "Microsoft.Compute/virtualMachines/runCommands/parameters[*]",
                "where": {
                  "allOf": [
                    {
                      "field": "Microsoft.Compute/virtualMachines/runCommands/parameters[*].name",
                      "equals": "runCommandName"
                    },
                    {
                      "field": "Microsoft.Compute/virtualMachines/runCommands/parameters[*].value",
                      "equals": "[parameters('runCommandName')]"
                    }
                  ]
                },
                "equals": 1
              }
            },
            {
              "field": "Microsoft.Compute/virtualMachines/runCommands/provisioningState",
              "equals": "Succeeded"
            }
          ]
        },
        "deployment": {
          "properties": {
            "mode": "Incremental",
            "parameters": {
              "fslogixContainerType": {
                "value": "[parameters('fslogixContainerType')]"
              },
              "fslogixFileShareNames": {
                "value": "[parameters('fslogixFileShareNames')]"
              },
              "fslogixLocalStorageAccountResourceIds": {
                "value": "[parameters('fslogixLocalStorageAccountResourceIds')]"
              },
              "fslogixLocalNetAppServerFqdns": {
                "value": "[parameters('fslogixLocalNetAppServerFqdns')]"
              },
              "fslogixOSSGroups": {
                "value": "[parameters('fslogixOSSGroups')]"
              },
              "fslogixRemoteStorageAccountResourceIds": {
                "value": "[parameters('fslogixRemoteStorageAccountResourceIds')]"
              },
              "fslogixRemoteNetAppServerFqdns": {
                "value": "[parameters('fslogixRemoteNetAppServerFqdns')]"
              },
              "fslogixStorageService": {
                "value": "[parameters('fslogixStorageService')]"
              },
              "identitySolution": {
                "value": "[parameters('identitySolution')]"
              },
              "location": {
                "value": "[field('location')]"
              },
              "runCommandName": {
                "value": "[parameters('runCommandName')]"
              },
              "virtualMachineName": {
                "value": "[field('name')]"
              }
            },
            "template": {
              "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
              "contentVersion": "1.0.0.0",
              "parameters": {
                "fslogixContainerType": {
                  "type": "string"
                },
                "fslogixFileShareNames": {
                  "type": "array"
                },
                "fslogixLocalStorageAccountResourceIds": {
                  "type": "array"
                },
                "fslogixLocalNetAppServerFqdns": {
                  "type": "array"
                },
                "fslogixOSSGroups": {
                  "type": "array"
                },
                "fslogixRemoteStorageAccountResourceIds": {
                  "type": "array"
                },
                "fslogixRemoteNetAppServerFqdns": {
                  "type": "array"
                },
                "fslogixStorageService": {
                  "type": "string"
                },
                "identitySolution": {
                  "type": "string"
                },
                "location": {
                  "type": "string"
                },
                "runCommandName": {
                  "type": "string"
                },
                "virtualMachineName": {
                  "type": "string"
                }
              },
              "variables": {
                "copy": [
                  {
                    "name": "fslogixLocalStorageAccountNames",
                    "count": "[length(parameters('fslogixLocalStorageAccountResourceIds'))]",
                    "input": "[last(split(parameters('fslogixLocalStorageAccountResourceIds')[copyIndex('fslogixLocalStorageAccountNames')], '/'))]"
                  },
                  {
                    "name": "fslogixRemoteStorageAccountNames",
                    "count": "[length(parameters('fslogixRemoteStorageAccountResourceIds'))]",
                    "input": "[last(split(parameters('fslogixRemoteStorageAccountResourceIds')[copyIndex('fslogixRemoteStorageAccountNames')], '/'))]"
                  }
                ],
                "$fxv#0": "[CmdletBinding(SupportsShouldProcess = $true)]\r\nparam (\r\n    [string]$CloudCache = 'false',\r\n    [string]$LocalNetAppServers,\r\n    [string]$LocalStorageAccountNames,\r\n    [string]$LocalStorageAccountKeys,\r\n    [string]$OSSGroups,\r\n    [string]$RemoteNetAppServers,\r\n    [string]$RemoteStorageAccountNames,\r\n    [string]$RemoteStorageAccountKeys,\r\n    [string]$RunCommandName,\r\n    [string]$Shares,\r\n    [string]$StorageAccountDNSSuffix,\r\n    [string]$StorageService\r\n)\r\n[string]$Script:LogDir = \"C:\\Windows\\Logs\\Configuration\"\r\n[string]$Script:Name = 'Set-FSLogixConfiguration'\r\n\r\n#region Functions\r\n\r\nfunction New-Log {\r\n    <#\r\n    .SYNOPSIS\r\n    Sets default log file and stores in a script accessible variable $script:Log\r\n    Log File name \"packageExecution_$date.log\"\r\n\r\n    .PARAMETER Path\r\n    Path to the log file\r\n\r\n    .EXAMPLE\r\n    New-Log c:\\Windows\\Logs\r\n    Create a new log file in c:\\Windows\\Logs\r\n    #>\r\n\r\n    Param (\r\n        [Parameter(Mandatory = $true, Position = 0)]\r\n        [string] $Path\r\n    )\r\n\r\n    # Create central log file with given date\r\n\r\n    $date = Get-Date -UFormat \"%Y-%m-%d %H-%M-%S\"\r\n    Set-Variable logFile -Scope Script\r\n    $script:logFile = \"$Script:Name-$date.log\"\r\n\r\n    if ((Test-Path $path ) -eq $false) {\r\n        $null = New-Item -Path $path -type directory\r\n    }\r\n\r\n    $script:Log = Join-Path $path $logfile\r\n\r\n    Add-Content $script:Log \"Date`t`t`tCategory`t`tDetails\"\r\n}\r\n\r\nfunction Write-Log {\r\n\r\n    <#\r\n    .SYNOPSIS\r\n    Creates a log file and stores logs based on categories with tab seperation\r\n\r\n    .PARAMETER category\r\n    Category to put into the trace\r\n\r\n    .PARAMETER message\r\n    Message to be loged\r\n\r\n    .EXAMPLE\r\n    Log 'Info' 'Message'\r\n\r\n    #>\r\n\r\n    Param (\r\n        [Parameter(Mandatory = $false, Position = 0)]\r\n        [ValidateSet(\"Info\", \"Warning\", \"Error\")]\r\n        $category = 'Info',\r\n        [Parameter(Mandatory = $true, Position = 1)]\r\n        $message\r\n    )\r\n\r\n    $date = get-date\r\n    $content = \"[$date]`t$category`t`t$message\" \r\n    Add-Content $Script:Log $content -ErrorAction Stop\r\n}\r\n\r\nFunction ConvertFrom-JsonString {\r\n    [CmdletBinding()]\r\n    param (\r\n        [string]$JsonString,\r\n        [string]$Name,\r\n        [switch]$SensitiveValues      \r\n    )\r\n    If ($JsonString -ne '[]' -and $JsonString -ne $null) {\r\n        [array]$Array = $JsonString.replace('\\', '') | ConvertFrom-Json\r\n        If ($Array.Length -gt 0) {\r\n            If ($SensitiveValues) {Write-Log -message \"Array '$Name' has $($Array.Length) members\"} Else {Write-Log -message \"$($Name): '$($Array -join \"', '\")'\"}\r\n            Return $Array\r\n        } Else {\r\n            Return $null\r\n        }            \r\n    } Else {\r\n        Return $null\r\n    }    \r\n}\r\n\r\nFunction Convert-GroupToSID {\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Parameter(Mandatory = $true)]\r\n        [string]$DomainName,\r\n\r\n        [Parameter(Mandatory = $true)]\r\n        [string]$GroupName\r\n    )\r\n    Begin {\r\n        [string]$groupSID = ''\r\n    }\r\n    Process {\r\n        Try {\r\n            $groupSID = (New-Object System.Security.Principal.NTAccount(\"$GroupName\")).Translate([System.Security.Principal.SecurityIdentifier]).Value\r\n        }\r\n        Catch {\r\n            Try {\r\n                $groupSID = (New-Object System.Security.Principal.NTAccount($DomainName,\"$GroupName\")).Translate([System.Security.Principal.SecurityIdentifier]).Value\r\n            }\r\n            Catch {\r\n                Write-Error -Message \"Failed to convert group name '$GroupName' to SID.\"\r\n            }\r\n        }\r\n        Write-Output -InputObject $groupSID\r\n    }\r\n}\r\n\r\nFunction Get-InstalledApplication {\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Parameter(Mandatory = $false)]\r\n        [ValidateNotNullorEmpty()]\r\n        [string[]]$Name,\r\n        [Parameter(Mandatory = $false)]\r\n        [ValidateNotNullorEmpty()]\r\n        [string]$ProductCode\r\n    )\r\n\r\n    Begin {\r\n        [string[]]$regKeyApplications = 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall', 'Registry::HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall'\r\n    }\r\n    Process { \r\n        ## Enumerate the installed applications from the registry for applications that have the \"DisplayName\" property\r\n        [psobject[]]$regKeyApplication = @()\r\n        ForEach ($regKey in $regKeyApplications) {\r\n            If (Test-Path -LiteralPath $regKey -ErrorAction 'SilentlyContinue' -ErrorVariable '+ErrorUninstallKeyPath') {\r\n                [psobject[]]$UninstallKeyApps = Get-ChildItem -LiteralPath $regKey -ErrorAction 'SilentlyContinue' -ErrorVariable '+ErrorUninstallKeyPath'\r\n                ForEach ($UninstallKeyApp in $UninstallKeyApps) {\r\n                    Try {\r\n                        [psobject]$regKeyApplicationProps = Get-ItemProperty -LiteralPath $UninstallKeyApp.PSPath -ErrorAction 'Stop'\r\n                        If ($regKeyApplicationProps.DisplayName) { [psobject[]]$regKeyApplication += $regKeyApplicationProps }\r\n                    }\r\n                    Catch {\r\n                        Continue\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        ## Create a custom object with the desired properties for the installed applications and sanitize property details\r\n        [psobject[]]$installedApplication = @()\r\n        ForEach ($regKeyApp in $regKeyApplication) {\r\n            Try {\r\n                [string]$appDisplayName = ''\r\n                [string]$appDisplayVersion = ''\r\n                [string]$appPublisher = ''\r\n\r\n                ## Bypass any updates or hotfixes\r\n                If (($regKeyApp.DisplayName -match '(?i)kb\\d+') -or ($regKeyApp.DisplayName -match 'Cumulative Update') -or ($regKeyApp.DisplayName -match 'Security Update') -or ($regKeyApp.DisplayName -match 'Hotfix')) {\r\n                    Continue\r\n                }\r\n\r\n                ## Remove any control characters which may interfere with logging and creating file path names from these variables\r\n                $appDisplayName = $regKeyApp.DisplayName -replace '[^\\u001F-\\u007F]', ''\r\n                $appDisplayVersion = $regKeyApp.DisplayVersion -replace '[^\\u001F-\\u007F]', ''\r\n                $appPublisher = $regKeyApp.Publisher -replace '[^\\u001F-\\u007F]', ''\r\n\r\n                ## Determine if application is a 64-bit application\r\n                [boolean]$Is64BitApp = If (($is64Bit) -and ($regKeyApp.PSPath -notmatch '^Microsoft\\.PowerShell\\.Core\\\\Registry::HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Wow6432Node')) { $true } Else { $false }\r\n\r\n                If ($ProductCode) {\r\n                    ## Verify if there is a match with the product code passed to the script\r\n                    If ($regKeyApp.PSChildName -match [regex]::Escape($productCode)) {\r\n                        $installedApplication += New-Object -TypeName 'PSObject' -Property @{\r\n                            UninstallSubkey    = $regKeyApp.PSChildName\r\n                            ProductCode        = If ($regKeyApp.PSChildName -match $MSIProductCodeRegExPattern) { $regKeyApp.PSChildName } Else { [string]::Empty }\r\n                            DisplayName        = $appDisplayName\r\n                            DisplayVersion     = $appDisplayVersion\r\n                            UninstallString    = $regKeyApp.UninstallString\r\n                            InstallSource      = $regKeyApp.InstallSource\r\n                            InstallLocation    = $regKeyApp.InstallLocation\r\n                            InstallDate        = $regKeyApp.InstallDate\r\n                            Publisher          = $appPublisher\r\n                            Is64BitApplication = $Is64BitApp\r\n                        }\r\n                    }\r\n                }\r\n\r\n                If ($name) {\r\n                    ## Verify if there is a match with the application name(s) passed to the script\r\n                    ForEach ($application in $Name) {\r\n                        $applicationMatched = $false\r\n                        #  Check for a contains application name match\r\n                        If ($regKeyApp.DisplayName -match [regex]::Escape($application)) {\r\n                            $applicationMatched = $true\r\n                        }\r\n\r\n                        If ($applicationMatched) {\r\n                            $installedApplication += New-Object -TypeName 'PSObject' -Property @{\r\n                                UninstallSubkey    = $regKeyApp.PSChildName\r\n                                ProductCode        = If ($regKeyApp.PSChildName -match $MSIProductCodeRegExPattern) { $regKeyApp.PSChildName } Else { [string]::Empty }\r\n                                DisplayName        = $appDisplayName\r\n                                DisplayVersion     = $appDisplayVersion\r\n                                UninstallString    = $regKeyApp.UninstallString\r\n                                InstallSource      = $regKeyApp.InstallSource\r\n                                InstallLocation    = $regKeyApp.InstallLocation\r\n                                InstallDate        = $regKeyApp.InstallDate\r\n                                Publisher          = $appPublisher\r\n                                Is64BitApplication = $Is64BitApp\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            Catch {\r\n                Continue\r\n            }\r\n        }\r\n        Write-Output -InputObject $installedApplication\r\n    }\r\n}\r\n\r\nFunction Set-RegistryValue {\r\n    [CmdletBinding()]\r\n    param (\r\n        [Parameter()]\r\n        [string]\r\n        $Name,\r\n        [Parameter()]\r\n        [string]\r\n        $Path,\r\n        [Parameter()]\r\n        [string]$PropertyType,\r\n        [Parameter()]\r\n        $Value\r\n    )\r\n    Begin {\r\n        Write-Log -message \"[Set-RegistryValue]: Setting Registry Value: $Name\"\r\n    }\r\n    Process {\r\n        # Create the registry Key(s) if necessary.\r\n        If (!(Test-Path -Path $Path)) {\r\n            Write-Log -message \"[Set-RegistryValue]: Creating Registry Key: $Path\"\r\n            New-Item -Path $Path -Force | Out-Null\r\n        }\r\n        # Check for existing registry setting\r\n        $RemoteValue = Get-ItemProperty -Path $Path -Name $Name -ErrorAction SilentlyContinue\r\n        If ($RemoteValue) {\r\n            # Get current Value\r\n            $CurrentValue = Get-ItemPropertyValue -Path $Path -Name $Name\r\n            Write-Log -message \"[Set-RegistryValue]: Current Value of $($Path)\\$($Name) : $CurrentValue\"\r\n            If ($Value -ne $CurrentValue) {\r\n                Write-Log -message \"[Set-RegistryValue]: Setting Value of $($Path)\\$($Name) : $Value\"\r\n                Set-ItemProperty -Path $Path -Name $Name -Value $Value -Force | Out-Null\r\n            } Else {\r\n                Write-Log -message \"[Set-RegistryValue]: Value of $($Path)\\$($Name) is already set to $Value\"\r\n            }           \r\n        }\r\n        Else {\r\n            Write-Log -message \"[Set-RegistryValue]: Setting Value of $($Path)\\$($Name) : $Value\"\r\n            New-ItemProperty -Path $Path -Name $Name -PropertyType $PropertyType -Value $Value -Force | Out-Null\r\n        }\r\n        Start-Sleep -Milliseconds 500\r\n    }\r\n    End {\r\n    }\r\n}\r\n\r\n#endregion Functions\r\n\r\nNew-Log -Path $Script:LogDir\r\nwrite-log -message \"*** Parameter Values ***\"\r\n\r\n#Convert CloudCache to Boolean\r\n$CloudCache = [System.Convert]::ToBoolean($CloudCache)\r\nWrite-Log -message \"CloudCache: $CloudCache\"\r\n#Convert Shares to Array\r\n[array]$Shares = ConvertFrom-JsonString -JsonString $Shares -Name 'Shares'\r\n$ProfileShareName = $Shares[0]\r\nif ($Shares.Count -gt 1) {\r\n    $OfficeShareName = $Shares[1]\r\n} Else {\r\n    $OfficeShareName = $null\r\n}\r\n\r\nWrite-Log -message \"ProfileShareName: $ProfileShareName\"\r\nWrite-Log -message \"OfficeShareName: $OfficeShareName\"\r\nWrite-Log -message \"StorageService: $StorageService\"\r\n\r\n# Create Array Lists so it is easy to add them\r\n[System.Collections.ArrayList]$LocalProfileContainerPaths = @()\r\n[System.Collections.ArrayList]$LocalCloudCacheProfileContainerPaths = @()\r\n[System.Collections.ArrayList]$LocalOfficeContainerPaths = @()\r\n[System.Collections.ArrayList]$LocalCloudCacheOfficeContainerPaths = @()\r\n[System.Collections.ArrayList]$RemoteProfileContainerPaths = @()\r\n[System.Collections.ArrayList]$RemoteCloudCacheProfileContainerPaths = @()\r\n[System.Collections.ArrayList]$RemoteOfficeContainerPaths = @()\r\n[System.Collections.ArrayList]$RemoteCloudCacheOfficeContainerPaths = @()\r\n\r\nswitch($StorageService) {\r\n    'AzureFiles' {\r\n        Write-Log -message \"Gathering Azure Files Storage Account Parameters\"\r\n        # Convert escaped JSON strings to arrays\r\n        [array]$OSSGroups = ConvertFrom-JsonString -JsonString $OSSGroups -Name 'OSSGroups'\r\n        [array]$LocalStorageAccountNames = ConvertFrom-JsonString -JsonString $LocalStorageAccountNames -Name 'LocalStorageAccountNames'\r\n        [array]$LocalStorageAccountKeys = ConvertFrom-JsonString -JsonString $LocalStorageAccountKeys -Name 'LocalStorageAccountKeys' -SensitiveValues\r\n        [array]$RemoteStorageAccountNames = ConvertFrom-JsonString -JsonString $RemoteStorageAccountNames -Name 'RemoteStorageAccountNames'\r\n        [array]$RemoteStorageAccountKeys = ConvertFrom-JsonString -JsonString $RemoteStorageAccountKeys -Name 'RemoteStorageAccountKeys' -SensitiveValues\r\n        \r\n        Write-Log -message \"*** Begin Processing Storage Accounts ***\"\r\n        # Local Storage Accounts\r\n        Write-Log -message \"Processing Local Storage Accounts\"\r\n        For ($i = 0; $i -lt $LocalStorageAccountNames.Count; $i++) {\r\n            $SAFQDN = \"$($LocalStorageAccountNames[$i]).file.$StorageAccountDNSSuffix\"\r\n            Write-Log -message \"LocalStorageAccountFQDN: '$SAFQDN'\"\r\n            If ($LocalStorageAccountKeys.Count -gt 0) {\r\n                If ($LocalStorageAccountKeys[$i]) {\r\n                    Write-Log -message \"Adding Local Storage Account Key for '$SAFQDN' to Credential Manager\"\r\n                    Start-Process -FilePath 'cmdkey.exe' -ArgumentList \"/add:$SAFQDN /user:localhost\\$($LocalStorageAccountNames[$i]) /pass:$($LocalStorageAccountKeys[$i])\" -NoNewWindow -Wait\r\n                }\r\n            }\r\n            If ($OfficeShareName) {\r\n                $LocalOfficeContainerPaths.Add(\"\\\\$SAFQDN\\$OfficeShareName\")\r\n                Write-Log -message \"LocalOfficeContainerPath: '\\\\$($SAFQDN)\\$($OfficeShareName)'\"                \r\n                $LocalCloudCacheOfficeContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)\")\r\n                Write-Log -message \"LocalCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)'\"\r\n            }\r\n            $LocalProfileContainerPaths.Add(\"\\\\$($SAFQDN)\\$($ProfileShareName)\")\r\n            Write-Log -message \"LocalProfileContainerPath: \\\\$($SAFQDN)\\$($ProfileShareName)\"\r\n            $LocalCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)\")\r\n            Write-Log -message \"LocalCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)'\"\r\n        }\r\n        # Remote / Existing Storage Accounts\r\n        If ($RemoteStorageAccountNames.Count -gt 0) {\r\n            Write-Log Info \"Processing Remote Storage Accounts\"\r\n            For ($i = 0; $i -lt $RemoteStorageAccountNames.Count; $i++) {\r\n                $SAFQDN = \"$($RemoteStorageAccountNames[$i]).file.$StorageAccountDNSSuffix\"\r\n                Write-Log -message \"RemoteStorageAccountFQDN: '$SAFQDN'\"\r\n                If ($RemoteStorageAccountKeys.Count -gt 0) {\r\n                    If ($RemoteStorageAccountKeys[$i]) {\r\n                        Write-Log -message \"Adding Remote Storage Account Key for '$SAFQDN' to Credential Manager\"\r\n                        Start-Process -FilePath 'cmdkey.exe' -ArgumentList \"/add:$($SAFQDN) /user:localhost\\$($RemoteStorageAccountNames[$i]) /pass:$($RemoteStorageAccountKeys[$i])\" -NoNewWindow -Wait\r\n                    }\r\n                }\r\n                If ($OfficeShareName) {\r\n                    $RemoteOfficeContainerPaths.Add(\"\\\\$($SAFQDN)\\$($OfficeShareName)\")\r\n                    Write-Log -message \"RemoteOfficeContainerPath: '\\\\$($SAFQDN)\\$($OfficeShareName)'\"\r\n                    $RemoteCloudCacheOfficeContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)\")\r\n                    Write-Log -message \"RemoteCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($OfficeShareName)\"\r\n                }\r\n                $RemoteProfileContainerPaths.Add(\"\\\\$(SAFQDN)\\$(ProfileShareName)\")\r\n                Write-Log -message \"RemoteProfileContainerPath: '\\\\$($SAFQDN)\\$(ProfileShareName)'\"\r\n                $RemoteCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)\")\r\n                Write-Log -message \"RemoteCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($SAFQDN)\\$($ProfileShareName)'\"\r\n            }\r\n        }\r\n        Write-Log -message \"Done Adding UNC Paths to arrays.\"\r\n    }\r\n    'AzureNetAppFiles' {\r\n        Write-Log -message \"Gathering Azure NetApp Files Storage Account Parameters\"\r\n        # Convert escaped JSON strings to arrays\r\n        [array]$LocalNetAppServers = ConvertFrom-JsonString -JsonString $LocalNetAppServers -Name 'LocalNetAppServers'\r\n        [array]$RemoteNetAppServers = ConvertFrom-JsonString -JsonString $RemoteNetAppServers -Name 'RemoteNetAppServers' \r\n        Write-Log -message \"Processing Local Azure NetApp Servers\"        \r\n        $LocalProfileContainerPaths.Add(\"\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)\")\r\n        Write-Log -message \"LocalProfileContainerPath: '\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)'\"\r\n        $LocalCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)\")\r\n        Write-Log -message \"LocalCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($LocalNetAppServers[0])\\$($ProfileShareName)'\"\r\n        If($LocalNetAppServers.Length -gt 1 -and $OfficeShareName) {            \r\n            $LocalOfficeContainerPaths.Add(\"\\\\$($LocalNetAppServers[1])\\$($OfficeShareName)\")\r\n            Write-Log -message \"LocalOfficeContainerPath: \\\\$($LocalNetAppServers[1])\\$($OfficeShareName)\"\r\n            $LocalCloudCacheOfficeContainerPaths.Add(\"type=smb,connectionString=\\\\$($LocalNetAppServers[1])\\$($OfficeShareName)\")\r\n            Write-Log -message \"LocalCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($LocalNetAppServers[1])\\$($OfficeShareName)'\"\r\n        }\r\n        \r\n        If ($RemoteNetAppServers.Count -gt 0) {\r\n            Write-Log -message \"Processing Remote Azure NetApp Servers\"\r\n            $RemoteProfileContainerPaths.Add(\"\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)\")\r\n            Write-Log -message \"RemoteProfileContainerPath: '\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)'\"\r\n            $RemoteCloudCacheProfileContainerPaths.Add(\"type=smb,connectionString=\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)\")\r\n            Write-Log -message \"RemoteCloudCacheProfileContainerPath: 'type=smb,connectionString=\\\\$($RemoteNetAppServers[0])\\$($ProfileShareName)\"\r\n            If ($RemoteNetAppShares.Length -gt 1 -and $OfficeShareName) {\r\n                $RemoteOfficeContainerPaths.Add(\"\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)\")\r\n                Write-Log -message \"RemoteOfficeContainerPath: '\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)'\"\r\n                $RemoteCloudCacheOfficeContainers.Add(\"type=smb,connectionString=\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)\")\r\n                Write-Log -message \"RemoteCloudCacheOfficeContainerPath: 'type=smb,connectionString=\\\\$($RemoteNetAppServers[1])\\$($OfficeShareName)'\"\r\n            }        \r\n        }\r\n    }\r\n}\r\n\r\n# from https://learn.microsoft.com/en-us/microsoftteams/new-teams-vdi-requirements-deploy#recommended-for-exclusion\r\n# only specifying the folders that do not affect performance per article\r\n$redirectionsXMLContent = @'\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<FrxProfileFolderRedirection ExcludeCommonFolders=\"0\">\r\n<Excludes>\r\n<Exclude Copy=\"0\">AppData\\Local\\Packages\\MSTeams_8wekyb3d8bbwe\\LocalCache\\Microsoft\\MSTeams\\Logs</Exclude>\r\n<Exclude Copy=\"0\">AppData\\Local\\Packages\\MSTeams_8wekyb3d8bbwe\\LocalCache\\Microsoft\\MSTeams\\PerfLog</Exclude>\r\n<Exclude Copy=\"0\">AppData\\Local\\Packages\\MSTeams_8wekyb3d8bbwe\\LocalCache\\Microsoft\\MSTeams\\EBWebView\\WV2Profile_tfw\\GPUCache</Exclude>\r\n</Excludes>\r\n<Includes>\r\n</Includes>\r\n</FrxProfileFolderRedirection>\r\n'@\r\n\r\nWrite-Log -message \"*** Creating an ArrayList for all the registry settings ***\"\r\n# Common Settings\r\n$RegSettings = New-Object -TypeName 'System.Collections.ArrayList'\r\nWrite-Log -message \"Adding Common Settings\"\r\n# Cleans up an invalid sessions to enable a successful sign-in: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#cleanupinvalidsessions\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'CleanupInvalidSessions'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Apps'; PropertyType = 'DWord'; Value = 1 })\r\n# Enables Fslogix profile containers: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#enabled\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'Enabled'; Path = 'HKLM:\\SOFTWARE\\Fslogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n# Deletes a local profile if it exists and matches the profile being loaded from VHD: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#deletelocalprofilewhenvhdshouldapply\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'DeleteLocalProfileWhenVHDShouldApply'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n# The folder created in the Fslogix fileshare will begin with the username instead of the SID: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#flipflopprofiledirectoryname\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'FlipFlopProfileDirectoryName'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n# Prevent Login with a failure: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#preventloginwithfailure\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithFailure'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n# Prevent Login with a temporary profile: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#preventloginwithtempprofile\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithTempProfile'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n# Specifies the number of seconds to wait between retries when attempting to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#reattachintervalseconds\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachIntervalSeconds'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 15 })\r\n# Specifies the number of times the system should attempt to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#reattachretrycount\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachRetryCount'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 3 })\r\n# Specifies the maximum size of the user's container in megabytes. Newly created VHD(x) containers are of this size: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#sizeinmbs\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'SizeInMBs'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 30000 })\r\n# Specifies the file extension for the profile containers: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=profiles#volumetype\r\n$RegSettings.Add([PSCustomObject]@{ Name = 'VolumeType'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'String'; Value = 'VHDX' })\r\n\r\nIf ($LocalStorageAccountKeys.Count -gt 0) {\r\n    Write-Log -message \"Adding AccessNetworkAsComputerObject for cloud only identities.\"\r\n    # Attach the users VHD(x) as the computer: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#accessnetworkascomputerobject\r\n    $RegSettings.Add([PSCustomObject]@{Name = 'AccessNetworkAsComputerObject'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n}\r\n\r\nif ($CloudCache -eq $True) {\r\n    Write-Log -message \"Adding Cloud Cache Settings\"\r\n    # Clear the cloud cache on logoff: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#clearcacheonlogoff\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'ClearCacheOnLogoff'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'DWord'; Value = 1 })\r\n}\r\n\r\nIf ($LocalOfficeContainerPaths.Count -gt 0) {\r\n    Write-Log -message \"Adding Office Container Settings\"    \r\n    # Enables Fslogix office containers: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#enabled-1   \r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'Enabled'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })   \r\n    # The folder created in the Fslogix fileshare will begin with the username instead of the SID: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#flipflopprofiledirectoryname-1\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'FlipFlopProfileDirectoryName'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n    # Specifies the number of retries attempted when a VHD(x) file is locked: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#lockedretrycount\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'LockedRetryCount'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 3 })\r\n    # Specifies the number of seconds to wait between retries: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#lockedretryinterval\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'LockedRetryInterval'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 15 })\r\n    # Prevent Login with a failure: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#preventloginwithfailure-1\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithFailure'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n    # Prevent Login with Temporary Profile: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#preventloginwithtempprofile-1\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'PreventLoginWithTempProfile'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })    \r\n    # Specifies the number of seconds to wait between retries when attempting to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#reattachintervalseconds\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachIntervalSeconds'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 15 })\r\n    # Specifies the number of times the system should attempt to reattach the VHD(x) container if it's disconnected unexpectedly: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#reattachretrycount\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'ReAttachRetryCount'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 3 })\r\n    # Specifies the maximum size of the user's container in megabytes: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#sizeinmbs\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'SizeInMBs'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 30000 })\r\n    # Specifies the type of container: https://learn.microsoft.com/fslogix/reference-configuration-settings?tabs=odfc#volumetype\r\n    $RegSettings.Add([PSCustomObject]@{ Name = 'VolumeType'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'String'; Value = 'VHDX' })\r\n    If ($LocalStorageAccountKeys.Count -gt 0) {\r\n        Write-Log -message \"Adding AccessNetworkAsComputerObject for cloud only identities.\"\r\n        # Attach the users VHD(x) as the computer: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#accessnetworkascomputerobject-1\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'AccessNetworkAsComputerObject'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n    }\r\n    If ($CloudCache -eq $True) {\r\n        Write-Log -message \"Adding Cloud Cache Settings\"\r\n        # Clear the cloud cache on logoff: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#clearcacheonlogoff\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'ClearCacheOnLogoff'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'DWord'; Value = 1 })\r\n    }   \r\n}\r\n\r\nIf ($OSSGroups.Count -gt 0) {\r\n    Write-Log -message \"Adding Object Specific Settings\"\r\n    # Object Specific Settings\r\n    $DomainName = Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object -ExpandProperty Domain\r\n    Write-Log -message \"DomainName: $DomainName\"\r\n    For ($i = 0; $i -lt $OSSGroups.Count; $i++) {\r\n        # Get Domain information\r\n        Write-Log -message \"Getting SID for $($OSSGroups[$i])\"        \r\n        $OSSGroupSID = Convert-GroupToSID -DomainName $DomainName -GroupName $OSSGroups[$i]\r\n        [string]$LocalProfileContainerPath = $LocalProfileContainerPaths[$i]\r\n        Write-Log -message \"LocalProfileContainerPath: '$LocalProfileContainerPath'\"\r\n        [string]$LocalCloudCacheProfileContainerPath = $LocalCloudCacheProfileContainerPaths[$i]\r\n        Write-Log -message \"LocalCloudCacheProfileContainerPath: '$LocalCloudCacheProfileContainerPath'\"\r\n\r\n        If ($RemoteStorageAccountNames) {\r\n            [string]$RemoteProfileContainerPath = $RemoteProfileContainerPaths[$i]\r\n            Write-Log -message \"RemoteProfileContainerPath: '$RemoteProfileContainerPath'\"\r\n            [string]$RemoteCloudCacheProfileContainerPath = $RemoteCloudCacheProfilePaths[$i]\r\n            Write-Log -message \"RemoteCloudCacheProfileContainerPath: '$RemoteCloudCacheProfileContainerPath'\"\r\n            [array]$ProfileContainerPaths = @($LocalProfileContainerPath + $RemoteProfileContainerPath)\r\n            [array]$CloudCacheProfileContainerPaths = @($LocalCloudCacheProfileContainerPath + $RemoteCloudCacheProfileContainerPath)\r\n        } Else {\r\n            [array]$ProfileContainerPaths = @($LocalProfileContainerPath)\r\n            [array]$CloudCacheProfileContainerPaths = @($LocalCloudCacheProfileContainerPath)\r\n        }\r\n\r\n        If ($CloudCache -eq $True) {\r\n            Write-Log -message \"Adding Cloud Cache Profile Container Settings: $OSSGroupSID : '$($CloudCacheProfileContainerPaths -join \"', '\")'\"\r\n            # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations\r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = \"HKLM:\\SOFTWARE\\FSLogix\\Profiles\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $CloudCacheProfileContainerPaths })\r\n        } Else {\r\n            Write-Log -message \"Adding Profile Container Settings: $OSSGroupSID : '$($ProfileContainerPaths -join \"', '\")'\"\r\n            # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#vhdlocations\r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = \"HKLM:\\SOFTWARE\\FSLogix\\Profiles\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $ProfileContainerPaths })\r\n        }   \r\n\r\n        If ($LocalOfficeContainerPaths.Count -gt 0) {\r\n            [string]$LocalOfficeContainerPath = $LocalOfficeContainerPaths[$i]\r\n            Write-Log -message \"LocalOfficeContainerPath: '$LocalOfficeContainerPath'\"\r\n            [string]$LocalCloudCacheOfficeContainerPath = $LocalCloudCacheOfficeContainerPaths[$i]\r\n            Write-Log -message \"LocalCloudCacheOfficeContainerPath: '$LocalCloudCacheOfficeContainerPath'\"\r\n            If ($RemoteStorageAccountNames) {\r\n                [string]$RemoteOfficeContainerPath = $RemoteOfficeContainerPaths[$i]\r\n                Write-Log -message \"RemoteOfficeContainerPath: '$RemoteOfficeContainerPath'\"\r\n                [string]$RemoteCloudCacheOfficeContainerPath = $RemoteCloudCacheOfficePaths[$i]\r\n                Write-Log -message \"RemoteCloudCacheOfficeContainerPath: '$RemoteCloudCacheOfficeContainerPath'\"\r\n                [array]$OfficeContainerPaths = @($LocalOfficeContainerPath + $RemoteOfficeContainerPath)\r\n                [array]$CloudCacheOfficeContainerPaths = @($LocalCloudCacheOfficeContainerPath + $RemoteCloudCacheOfficeContainerPath)\r\n            } Else {\r\n                [array]$OfficeContainerPaths = @($LocalOfficeContainerPath)\r\n                [array]$CloudCacheOfficeContainerPaths = @($LocalCloudCacheOfficeContainerPath)\r\n            }\r\n            If ($CloudCache -eq $True) {\r\n                Write-Log -message \"Adding Cloud Cache Office Container Settings: $OSSGroupSID : '$($CloudCacheOfficeContainerPaths -join \"', '\")'\"\r\n                # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations\r\n                $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = \"HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $CloudCacheOfficeContainerPaths })\r\n            } Else {\r\n                Write-Log -message \"Adding Office Container Settings: $OSSGroupSID : '$($OfficeContainerPaths -join \"', '\")'\"\r\n                # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#vhdlocations-1\r\n                $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = \"HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC\\ObjectSpecific\\$OSSGroupSID\"; PropertyType = 'MultiString'; Value = $OfficeContainerPaths })\r\n            }\r\n        }  \r\n    }          \r\n} Else {\r\n    If ($RemoteStorageAccountNames.Count -gt 0) {\r\n        $ProfileContainerPaths = $LocalProfileContainerPaths + $RemoteProfileContainerPaths\r\n        $CloudCacheProfileContainerPaths = $LocalCloudCacheProfileContainerPaths + $RemoteCloudCacheProfileContainerPaths\r\n    } Else {\r\n        $ProfileContainerPaths = $LocalProfileContainerPaths\r\n        $CloudCacheProfileContainerPaths = $LocalCloudCacheProfileContainerPaths\r\n    }\r\n    If ($CloudCache -eq $True) {\r\n        Write-Log -message \"Adding Cloud Cache Profile Container Settings: '$($CloudCacheProfileContainerPaths -join \"', '\")'\"   \r\n        # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations \r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'MultiString'; Value = $CloudCacheProfileContainerPaths })             \r\n    } Else {\r\n        Write-Log -message \"Adding Profile Container Settings: '$($ProfileContainerPaths -join \"', '\")'\"\r\n        # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/fslogix/profile-container-configuration-reference#vhdlocations\r\n        $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'; PropertyType = 'MultiString'; Value = $ProfileContainerPaths })\r\n    }\r\n    If ($LocalOfficeContainerPaths.Count -gt 0) {\r\n        If ($RemoteStorageAccountNames.Count -gt 0) {\r\n            $OfficeContainerPaths = $LocalOfficeContainerPaths + $RemoteOfficeContainerPaths\r\n            $CloudCacheOfficeContainerPaths = $LocalCloudCacheOfficeContainerPaths + $RemoteCloudCacheOfficeContainerPaths\r\n        } Else {\r\n            $OfficeContainerPaths = $LocalOfficeContainerPaths\r\n            $CloudCacheOfficeContainerPaths = $LocalCloudCacheOfficeContainerPaths\r\n        }\r\n        If ($CloudCache -eq $True) {\r\n            Write-Log -message \"Adding Cloud Cache Office Container Settings: '$($CloudCacheOfficeContainerPaths -join \"', '\")'\"\r\n            # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=ccd#ccdlocations\r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'CCDLocations'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'MultiString'; Value = $CloudCacheOfficeContainerPaths })\r\n        } Else {\r\n            Write-Log -message \"Adding Office Container Settings: '$($OfficeContainerPaths -join \"', '\")'\"\r\n            # List of file system locations to search for the user's profile VHD(X) file: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=odfc#vhdlocations-1\r\n            $RegSettings.Add([PSCustomObject]@{ Name = 'VHDLocations'; Path = 'HKLM:\\SOFTWARE\\Policies\\FSLogix\\ODFC'; PropertyType = 'MultiString'; Value = $OfficeContainerPaths })\r\n        }\r\n    }    \r\n}\r\nWrite-Log -message \"Checking for Teams\"\r\nIf (Get-InstalledApplication 'Teams') {\r\n    Write-Log -message \"Teams is installed\"\r\n    $customRedirFolder = \"$env:ProgramData\\FSLogix_CustomRedirections\"\r\n    Write-Log -message \"Creating custom redirections.xml file in $customRedirFolder\"\r\n    If (-not (Test-Path $customRedirFolder )) {\r\n        New-Item -Path $customRedirFolder -ItemType Directory -Force\r\n    }\r\n    $customRedirFilePath = \"$customRedirFolder\\redirections.xml\"\r\n    $redirectionsXMLContent | Out-File -FilePath $customRedirFilePath -Encoding unicode\r\n    # Path where FSLogix looks for the redirections.xml file to copy from and into the user's profile: https://learn.microsoft.com/en-us/fslogix/reference-configuration-settings?tabs=profiles#redirxmlsourcefolder\r\n    \r\n    $RegSettings.Add(\r\n        [PSCustomObject]@{\r\n            Name         = 'RedirXMLSourceFolder'\r\n            Path         = 'HKLM:\\SOFTWARE\\FSLogix\\Profiles'\r\n            PropertyType = 'String'\r\n            Value        = $customRedirFolder\r\n        }\r\n    )\r\n}\r\nWrite-Log -message \"*** Setting Registry Values ***\"\r\nForEach ($Setting in $RegSettings) {\r\n    Set-RegistryValue -Name $Setting.Name -Path $Setting.Path -PropertyType $Setting.PropertyType -Value $Setting.Value -Verbose\r\n}\r\n$LocalAdministrator = (Get-LocalUser | Where-Object { $_.SID -like '*-500' }).Name\r\n$LocalGroups = 'FSLogix Profile Exclude List', 'FSLogix ODFC Exclude List'\r\nForEach ($Group in $LocalGroups) {\r\n    If (-not (Get-LocalGroupMember -Group $Group | Where-Object { $_.Name -like \"*$LocalAdministrator\" })) {\r\n        Add-LocalGroupMember -Group $Group -Member $LocalAdministrator\r\n    }\r\n}\r\nWrite-Log -message \"Done\""
              },
              "resources": [
                {
                  "type": "Microsoft.Compute/virtualMachines/runCommands",
                  "apiVersion": "2023-09-01",
                  "name": "[format('{0}/{1}', parameters('virtualMachineName'), parameters('runCommandName'))]",
                  "location": "[parameters('location')]",
                  "properties": {
                    "parameters": [
                      {
                        "name": "CloudCache",
                        "value": "[if(contains(parameters('fslogixContainerType'), 'CloudCache'), 'true', 'false')]"
                      },
                      {
                        "name": "LocalNetAppServers",
                        "value": "[string(parameters('fslogixLocalNetAppServerFqdns'))]"
                      },
                      {
                        "name": "LocalStorageAccountNames",
                        "value": "[string(variables('fslogixLocalStorageAccountNames'))]"
                      },
                      {
                        "name": "OSSGroups",
                        "value": "[string(parameters('fslogixOSSGroups'))]"
                      },
                      {
                        "name": "RemoteNetAppServers",
                        "value": "[string(parameters('fslogixRemoteNetAppServerFqdns'))]"
                      },
                      {
                        "name": "RemoteStorageAccountNames",
                        "value": "[string(variables('fslogixRemoteStorageAccountNames'))]"
                      },
                      {
                        "name": "RunCommandName",
                        "value": "[parameters('runCommandName')]"
                      },
                      {
                        "name": "Shares",
                        "value": "[string(parameters('fslogixFileShareNames'))]"
                      },
                      {
                        "name": "StorageAccountDNSSuffix",
                        "value": "[environment().suffixes.storage]"
                      },
                      {
                        "name": "StorageService",
                        "value": "[parameters('fslogixStorageService')]"
                      }
                    ],
                    "protectedParameters": [
                      {
                        "name": "LocalStorageAccountKeys",
                        "value": "[string(union(if(and(contains(parameters('identitySolution'), 'EntraId'), not(empty(parameters('fslogixLocalStorageAccountResourceIds')))), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixLocalStorageAccountResourceIds')[0], '/')[2], split(parameters('fslogixLocalStorageAccountResourceIds')[0], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixLocalStorageAccountResourceIds')[0], '/'))), '2023-01-01').keys[0].value), createArray()), if(and(contains(parameters('identitySolution'), 'EntraId'), greater(length(parameters('fslogixLocalStorageAccountResourceIds')), 1)), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixLocalStorageAccountResourceIds')[1], '/')[2], split(parameters('fslogixLocalStorageAccountResourceIds')[1], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixLocalStorageAccountResourceIds')[1], '/'))), '2023-01-01').keys[0].value), createArray())))]"
                      },
                      {
                        "name": "RemoteStorageAccountKeys",
                        "value": "[string(union(if(and(contains(parameters('identitySolution'), 'EntraId'), not(empty(parameters('fslogixRemoteStorageAccountResourceIds')))), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixRemoteStorageAccountResourceIds')[0], '/')[2], split(parameters('fslogixRemoteStorageAccountResourceIds')[0], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixRemoteStorageAccountResourceIds')[0], '/'))), '2023-01-01').keys[0].value), createArray()), if(and(contains(parameters('identitySolution'), 'EntraId'), greater(length(parameters('fslogixRemoteStorageAccountResourceIds')), 1)), createArray(listkeys(extensionResourceId(format('/subscriptions/{0}/resourceGroups/{1}', split(parameters('fslogixRemoteStorageAccountResourceIds')[1], '/')[2], split(parameters('fslogixRemoteStorageAccountResourceIds')[1], '/')[4]), 'Microsoft.Storage/storageAccounts', last(split(parameters('fslogixRemoteStorageAccountResourceIds')[1], '/'))), '2023-01-01').keys[0].value), createArray())))]"
                      }
                    ],
                    "source": {
                      "script": "[variables('$fxv#0')]"
                    },
                    "timeoutInSeconds": 180,
                    "treatFailureAsDeploymentFailure": true
                  }
                }
              ]
            }
          }
        }
      }
    }
  }
}