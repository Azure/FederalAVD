Function Get-AccessToken {
    param (
        [parameter(Mandatory = $true)]
        [string]$ResourceManagerUrl
    )
    $TokenAuthURI = $env:IDENTITY_ENDPOINT + '?resource=' + $ResourceManagerUrl + '&api-version=2019-08-01'
	$TokenResponse = Invoke-RestMethod -Method Get -Headers @{"X-IDENTITY-HEADER"="$env:IDENTITY_HEADER"} -Uri $TokenAuthURI
	$AccessToken = $TokenResponse.access_token
    Return $AccessToken
}

Function Get-GraphToken {
    param(
        [parameter(Mandatory = $false)]
        [string]$GraphEndpoint = $env:GRAPH_ENDPOINT,
        [parameter(Mandatory = $false)]
        [string]$ClientId,
        [parameter(Mandatory = $false)]
        [string]$TenantId,
        [parameter(Mandatory = $false)]
        [string]$LoginUrl

    )
    $Body = @{
        client_id     = $ClientId
        scope         = $GraphEndpoint + '/.default'
        grant_type    = 'client_credentials'
    }
    $TokenResponse = Invoke-RestMethod -Method Post -Uri ($LoginUrl + '/' + $TenantId + '/oauth2/v2.0/token') -Body $Body -ContentType 'application/x-www-form-urlencoded'
    $AccessToken = $TokenResponse.access_token
    Return $AccessToken
}

Function Invoke-AzureRestMethod {
    <#
        .SYNOPSIS
            Run an Azure REST call with paging support.           
        .PARAMETER AccessToken
            An access token generated by Connect-DCMsGraphAsDelegated or Connect-DCMsGraphAsApplication (depending on what permissions you use in Graph).
        .PARAMETER Method
            The HTTP method for the Graph call, like GET, POST, PUT, PATCH, DELETE. Default is GET.
        .PARAMETER Uri
            The Microsoft Graph URI for the query. Example: https://graph.microsoft.com/v1.0/users/
        .PARAMETER Body
            The request body of the Graph call. This is often used with methids like POST, PUT and PATCH. It is not used with GET.
        .EXAMPLE
            Invoke-AzureRestMethod -AccessToken $AccessToken -Method 'GET' -Uri 'https://graph.microsoft.com/v1.0/users/'
    #>

    param (
        [parameter(Mandatory = $true)]
        [string]$AccessToken,

        [parameter(Mandatory = $false)]
        [string]$Method = 'GET',

        [parameter(Mandatory = $true)]
        [string]$Uri,

        [parameter(Mandatory = $false)]
        [string]$Body = '',

        [parameter(Mandatory = $false)]
        [hashtable]$AdditionalHeaders
    )

    # Check if authentication was successfull.
    if ($AccessToken) {
        # Format headers.
        $HeaderParams = @{
            'Content-Type'  = "application\json"
            'Authorization' = "Bearer $AccessToken"
        }
        If ($AdditionalHeaders) {
            $HeaderParams += $AdditionalHeaders
        }

        # Create an empty array to store the result.
        $QueryRequest = @()
        $dataToUpload = @()

        # Run the first query.
        if ($Method -eq 'GET') {
            $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -UseBasicParsing -Method $Method -ContentType "application/json" -Verbose:$false
        }
        else {
            $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -UseBasicParsing -Method $Method -ContentType "application/json" -Body $Body -Verbose:$false
        }
        if ($QueryRequest.value) {
            $dataToUpload += $QueryRequest.value
        }
        else {
            $dataToUpload += $QueryRequest
        }

        # Invoke REST methods and fetch data until there are no pages left.
        if ($Uri -notlike "*`$top*") {
            while ($QueryRequest.'@odata.nextLink' -and $QueryRequest.'@odata.nextLink' -is [string]) {
                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $QueryRequest.'@odata.nextLink' -UseBasicParsing -Method $Method -ContentType "application/json" -Verbose:$false
                $dataToUpload += $QueryRequest.value
            }
            While ($QueryRequest.nextLink -and $QueryRequest.nextLink -is [string]) {
                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $QueryRequest.'nextLink' -UseBasicParsing -Method $Method -ContentType "application/json" -Verbose:$false #4>$null
                $dataToUpload += $QueryRequest.value
            }
            While ($QueryRequest.'$skipToken' -and $QueryRequest.'$skipToken' -is [string] -and $Body -ne '') {
                $tempBody = $Body | ConvertFrom-Json -AsHashtable
                $tempBody.'$skipToken' = $QueryRequest.'$skipToken'
                $Body = $tempBody | ConvertTo-Json -Depth 99
                $QueryRequest = Invoke-RestMethod -Headers $HeaderParams -Uri $Uri -UseBasicParsing -Method $Method -ContentType "application/json" -Body $Body -Verbose:$false #4>$null
                $dataToUpload += $QueryRequest.data
            }
        }
        $dataToUpload
    }
    else {
        Write-Error "No Access Token"
    }
}

function Deploy-SHRSessionHost {
    [CmdletBinding()]
    param (
        [Parameter()]
        [string[]] $ExistingSessionHostVMNames = @(),

        [Parameter(Mandatory = $true)]
        [int] $NewSessionHostsCount,

        [Parameter(Mandatory = $false)]
        [string] $HostPoolResourceGroupName = (Get-FunctionConfig _HostPoolResourceGroupName),

        [Parameter(Mandatory = $true)]
        [string] $SessionHostResourceGroupName,

        [Parameter()]
        [string] $HostPoolName = (Get-FunctionConfig _HostPoolName),

        [Parameter()]
        [string] $SessionHostNamePrefix = (Get-FunctionConfig _SessionHostNamePrefix),

        [Parameter()]
        [string] $SessionHostNameSeparator = (Get-FunctionConfig _SessionHostNameSeparator),

        [Parameter()]
        [int] $SessionHostInstanceNumberPadding = (Get-FunctionConfig _SessionHostInstanceNumberPadding),

        [Parameter()]
        [string] $DeploymentPrefix = (Get-FunctionConfig _SHRDeploymentPrefix),

        [Parameter()]
        [string] $SessionHostTemplate = (Get-FunctionConfig _SessionHostTemplate),

        [Parameter()]
        [string] $SessionHostTemplateParametersPS1Uri = (Get-FunctionConfig _SessionHostTemplateParametersPS1Uri),

        [Parameter()]
        [string] $TagIncludeInAutomation = (Get-FunctionConfig _Tag_IncludeInAutomation),
        [Parameter()]
        [string] $TagDeployTimestamp = (Get-FunctionConfig _Tag_DeployTimestamp),

        [Parameter()]
        [hashtable] $SessionHostParameters = (Get-FunctionConfig _SessionHostParameters | ConvertTo-CaseInsensitiveHashtable), #TODO: Port this into AzureFunctionConfiguration module and make it ciHashtable type.

        [Parameter()]
        [string] $VMNamesTemplateParameterName = (Get-FunctionConfig _VMNamesTemplateParameterName)
    )

    Write-HostDetailed -Message "Generating new token for the host pool $HostPoolName in Resource Group $HostPoolResourceGroupName"
    $Body = @{
        properties = @{
            registrationInfo = @{
                expirationTime = (Get-Date).AddHours(8)
                registrationTokenOperation = 'Update'
            }
        }
    }
    Invoke-AzureRestMethod `
        -AccessToken $AccessToken `
        -Body ($Body | ConvertTo-Json -depth 10) `
        -Method Post `
        -Uri ($ResourceManagerUrl + '/subscriptions/' + $SubscriptionId + '/resourceGroups/' + $HostPoolResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '?api-version=2024-04-03') | Out-Null
    
    # Calculate Session Host Names
    Write-HostDetailed -Level Host -Message "Existing session host VM names: {0}" -StringValues ($ExistingSessionHostVMNames -join ',')
    [array] $sessionHostNames = for ($i = 0; $i -lt $NewSessionHostsCount; $i++) {
        $vmNumber = 1
        While (("$SessionHostNamePrefix$SessionHostNameSeparator{0:d$SessionHostInstanceNumberPadding}" -f $vmNumber) -in $ExistingSessionHostVMNames) {
            $vmNumber++
        }
        $vmName = "$SessionHostNamePrefix$SessionHostNameSeparator{0:d$SessionHostInstanceNumberPadding}" -f $vmNumber
        $ExistingSessionHostVMNames += $vmName
        $vmName
    }
    Write-HostDetailed -Message "Creating session host(s) " + ($sessionHostNames -join ', ')

    # Update Session Host Parameters
    $sessionHostParameters[$VMNamesTemplateParameterName]   = $sessionHostNames
    $sessionHostParameters['Tags'][$TagIncludeInAutomation] = $true
    $sessionHostParameters['Tags'][$TagDeployTimestamp]     = (Get-Date -AsUTC -Format 'o')
    $deploymentTimestamp = Get-Date -AsUTC -Format 'FileDateTime'
    $deploymentName = "{0}_{1}_Count_{2}_VMs" -f $DeploymentPrefix, $deploymentTimestamp, $sessionHostNames.count
    
    Write-HostDetailed -Message "Deployment name: $deploymentName"
    Write-HostDetailed -Message "Deploying using Template Spec: $sessionHostTemplate"
    $templateSpecVersionResourceId = Get-SHRTemplateSpecVersionResourceId -ResourceId $SessionHostTemplate

    Write-HostDetailed -Message "Deploying $NewSessionHostCount session host(s) to resource group $sessionHostResourceGroupName" 
    
    $Body = @{
        properties = @{
            parameters = $sessionHostParameters
            templateLink = @{
                id = $templateSpecVersionResourceId
            }
        }
    }
    $Uri = $ResourceManagerUrl + '/subscriptions/' + $SubscriptionId + '/resourceGroups/' + $SessionHostResourceGroupName + '/providers/Microsoft.Resources/deployments/' + $deploymentName + '?api-version=2021-04-01'
    $DeploymentJob = Invoke-AzureRestMethod `
                        -AccessToken $AccessToken `
                        -Body ($Body | ConvertTo-Json -depth 10) `
                        -Method Put `
                        -Uri $Uri
    #TODO: Add logic to test if deployment is running (aka template is accepted) then finish running the function and let the deployment run in the background.
    Write-HostDetailed -Message 'Pausing for 30 seconds to allow deployment to start'
    Start-Sleep -Seconds 30
    # Check deployment status, if any has failed we report an error
    if ($deploymentJob.Error) {
        Write-HostDetailed "DeploymentFailed"
        throw $deploymentJob.Error
    }
}

function Get-SHRLatestImageVersion {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string] $ResourceManagerUrl,

        [Parameter(Mandatory = $true)]
        [string] $SubscriptionId,

        # An Image reference object. Can be from Marketplace or Shared Image Gallery.
        [Parameter()]
        [hashtable] $ImageReference,

        [Parameter()]
        [string] $Location
    )

    # Marketplace image
    if ($ImageReference.publisher) {
        #TODO Do we need to change location here?
        if ($ImageReference.version -ne 'latest') {
            Write-HostDetailed  "Image version is not set to latest. Returning version '$($ImageReference.version)'"
            $azImageVersion = $ImageReference.version
        }
        else {
            # Get the Images and select the latest version.           
            Write-HostDetailed "Getting latest version of image publisher: $($ImageReference.publisher), offer: $($ImageReference.offer), sku: $($ImageReference.sku) in region: $($Location)"
                      
            $Uri = $ResourceManagerUrl + "/subscriptions/$SubscriptionId/providers/Microsoft.Compute/locations/$Location/publishers/$($ImageReference.publisher)/artifacttypes/vmimage/offers/$($ImageReference.offer)/skus/$($ImageReference.sku)/versions?api-version=2024-07-01"
            
            $Versions = Invoke-AzureRestMethod -AccessToken $AccessToken -Uri $Uri -Method Get

            $azImageVersion = ($Versions | Sort-Object -Property {[version] $_.Name} -Descending | Select-Object -First 1).Name
            Write-HostDetailed  "Latest version of image is $azImageVersion"

            if ($azImageVersion -match "\d+\.\d+\.(?<Year>\d{2})(?<Month>\d{2})(?<Day>\d{2})") {
                $azImageDate = Get-Date -Date ("20{0}-{1}-{2}" -f $Matches.Year, $Matches.Month, $Matches.Day)
                Write-HostDetailed  "Image date is $azImageDate"
            } else {
                throw "Image version does not match expected format. Could not extract image date."
            }
        }
    }
    elseif ($ImageReference.Id) {
        # Shared Image Gallery
        Write-HostDetailed "Image is from Shared Image Gallery: $($ImageReference.Id)"
        $imageDefinitionResourceIdPattern = '^\/subscriptions\/(?<subscription>[a-z0-9\-]+)\/resourceGroups\/(?<resourceGroup>[^\/]+)\/providers\/Microsoft\.Compute\/galleries\/(?<gallery>[^\/]+)\/images\/(?<image>[^\/]+)$'
        $imageVersionResourceIdPattern = '^\/subscriptions\/(?<subscription>[a-z0-9\-]+)\/resourceGroups\/(?<resourceGroup>[^\/]+)\/providers\/Microsoft\.Compute\/galleries\/(?<gallery>[^\/]+)\/images\/(?<image>[^\/]+)\/versions\/(?<version>[^\/]+)$'
        if ($ImageReference.Id -match $imageDefinitionResourceIdPattern) {
            Write-HostDetailed 'Image reference is an Image Definition resource.'
            $imageSubscriptionId = $Matches.subscription
            $imageResourceGroup = $Matches.resourceGroup
            $imageGalleryName = $Matches.gallery
            $imageDefinitionName = $Matches.image

            # Get the latest version of the image
            $Uri = $ResourceManagerUri + "/subscriptions/$imageSubscriptionId/resourceGroups/$imageResourceGroup/providers/Microsoft.Compute/galleries/$imageGalleryName/images/$imageDefinitionName/versions?api-version=2023-07-03"
            $latestImageVersion = Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri |
                                         Where-Object { $_.PublishingProfile.ExcludeFromLatest -eq $false } |
                                         Sort-Object -Property {$_.PublishingProfile.PublishedDate} -Descending |
                                         Select-Object -First 1
            if (-not $latestImageVersion) {
                throw "No available image versions found."
            }
            Write-HostDetailed "Selected image version with resource Id {0}" -StringValues $latestImageVersion.Id
            $azImageVersion = $latestImageVersion.Name
            $azImageDate = $latestImageVersion.PublishingProfile.PublishedDate
            Write-HostDetailed "Image version is {0} and date is {1}" -StringValues $azImageVersion, $azImageDate.ToString('o')
        }
        elseif ($ImageReference.Id -match $imageVersionResourceIdPattern ) {
            Write-HostDetailed 'Image reference is an Image Version resource.'
            $Uri = $ResourceManagerUri + "$($ImageReference.Id)?api-version=2023-07-03"
            $azImageVersion = Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri
            $azImageVersion = $imageVersion.Name
            $azImageDate = $imageVersion.PublishingProfile.PublishedDate
            Write-HostDetailed "Image version is {0} and date is {1}" -StringValues $azImageVersion, $azImageDate.ToString('o')
        }
        else {
            throw "Image reference Id does not match expected format for an Image Definition resource."
        }
    }
    else {
        throw "Image reference does not contain a publisher or Id property. ImageReference, publisher, and Id are case sensitive!!"
    }
    #return output
    [PSCustomObject]@{
        Version = $azImageVersion
        Date    = $azImageDate
    }
}

function Get-SHRHostPoolDecision {
    <#
    .SYNOPSIS
        This function will decide how many session hosts to deploy and if we should decommission any session hosts.
    #>
    [CmdletBinding()]
    param (
        # Session hosts to consider
        [Parameter()]
        [array] $SessionHosts = @(),

        # Running deployments
        [Parameter()]
        $RunningDeployments,

        # Target age of session hosts in days - after this many days we consider a session host for replacement.
        [Parameter()]
        [int] $TargetVMAgeDays = (Get-FunctionConfig _TargetVMAgeDays),

        # Target number of session hosts in the host pool. If we have more than or equal to this number of session hosts we will decommission some.
        [Parameter()]
        [int] $TargetSessionHostCount = (Get-FunctionConfig _TargetSessionHostCount),

        [Parameter()]
        [int] $TargetSessionHostBuffer = (Get-FunctionConfig _TargetSessionHostBuffer),

        # Latest image version
        [Parameter()]
        [PSCustomObject] $LatestImageVersion,

        # Should we replace session hosts on new image version
        [Parameter()]
        [bool] $ReplaceSessionHostOnNewImageVersion = (Get-FunctionConfig _ReplaceSessionHostOnNewImageVersion),

        # Delay days before replacing session hosts on new image version
        [Parameter()]
        [int] $ReplaceSessionHostOnNewImageVersionDelayDays = (Get-FunctionConfig _ReplaceSessionHostOnNewImageVersionDelayDays)
    )
    # Basic Info
    Write-HostDetailed "We have $($SessionHosts.Count) session hosts (included in Automation)"
    # Identify Session hosts that should be replaced
    if ($TargetVMAgeDays -gt 0) {
        $targetReplacementDate = (Get-Date).AddDays(-$TargetVMAgeDays)
        [array] $sessionHostsOldAge = $SessionHosts | Where-Object { $_.DeployTimestamp -lt $targetReplacementDate }
        Write-HostDetailed "Found $($sessionHostsOldAge.Count) hosts to replace due to old age. $($($sessionHostsOldAge.VMName) -join ',')"

    }

    if ($ReplaceSessionHostOnNewImageVersion) {
        $latestImageAge = (New-TimeSpan -Start $LatestImageVersion.Date -End (Get-Date -AsUTC)).TotalDays
        Write-HostDetailed "Latest Image $($LatestImageVersion.Version) is $latestImageAge days old."
        if ($latestImageAge -ge $ReplaceSessionHostOnNewImageVersionDelayDays) {
            Write-HostDetailed "Latest Image age is older than (or equal) New Image Delay value $ReplaceSessionHostOnNewImageVersionDelayDays"
            [array] $sessionHostsOldVersion = $sessionHosts | Where-Object { $_.ImageVersion -ne $LatestImageVersion.Version }
            Write-HostDetailed "Found $($sessionHostsOldVersion.Count) session hosts to replace due to new image version. $($($sessionHostsOldVersion.VMName) -Join ',')"
        }
    }

    [array] $sessionHostsToReplace = ($sessionHostsOldAge + $sessionHostsOldVersion) | Select-Object -Property * -Unique
    Write-HostDetailed "Found $($sessionHostsToReplace.Count) session hosts to replace in total. $($($sessionHostsToReplace.VMName) -join ',')"

    # Good Session Hosts
    $goodSessionHosts = $SessionHosts | Where-Object { $_.VMName -notin $sessionHostsToReplace.VMName }
    $sessionHostsCurrentTotal = ([array]$goodSessionHosts.VMName + [array]$runningDeployments.SessionHostNames ) | Select-Object -Unique
    Write-HostDetailed "We have $($sessionHostsCurrentTotal.Count) good session hosts including $($runningDeployments.SessionHostName.Count) session hosts being deployed"
    Write-HostDetailed "We target having $TargetSessionHostCount session hosts in good shape"
    Write-HostDetailed "We have a buffer of $TargetSessionHostBuffer session hosts more than the target."
    $weCanDeployUpTo = $TargetSessionHostCount + $TargetSessionHostBuffer - $SessionHosts.count - $RunningDeployments.SessionHostNames.Count
    if ($weCanDeployUpTo -ge 0) {
        Write-HostDetailed "We can deploy up to $weCanDeployUpTo session hosts" 

        $weNeedToDeploy = $TargetSessionHostCount - $sessionHostsCurrentTotal.Count
        if ($weNeedToDeploy -gt 0) {
            Write-HostDetailed "We need to deploy $weNeedToDeploy new session hosts"
            $weCanDeploy = if ($weNeedToDeploy -gt $weCanDeployUpTo) { $weCanDeployUpTo } else { $weNeedToDeploy } # If we need to deploy 10 machines, and we can deploy 5, we should only deploy 5.
            Write-HostDetailed "Buffer allows deploying $weCanDeploy session hosts"
        }
        else {
            $weCanDeploy = 0
            Write-HostDetailed "We have enough session hosts in good shape."
        }
    }
    else {
        Write-HostDetailed "Buffer is full. We can not deploy more session hosts"
        $weCanDeploy = 0
    }
    $weCanDelete = $SessionHosts.Count - $TargetSessionHostCount
    if ($weCanDelete -gt 0) {
        Write-HostDetailed "We need to delete $weCanDelete session hosts"
        if ($weCanDelete -gt $sessionHostsToReplace.Count) {
            Write-HostDetailed "Host pool is over populated"

            $goodSessionHostsToDeleteCount = $weCanDelete - $sessionHostsToReplace.Count
            Write-HostDetailed "We will delete $goodSessionHostsToDeleteCount good session hosts"

            $selectedGoodHostsTotDelete = [array] ($goodSessionHosts | Sort-Object -Property Session | Select-Object -First $goodSessionHostsToDeleteCount)
            Write-HostDetailed "Selected the following good session hosts to delete: $($($selectedGoodHostsTotDelete.VMName) -join ',')"
        }
        else {
            $selectedGoodHostsTotDelete = @()
            Write-HostDetailed "Host pool is not over populated"
        }
        $sessionHostsPendingDelete = ($sessionHostsToReplace + $selectedGoodHostsTotDelete) | Select-Object -First $weCanDelete
        Write-HostDetailed "The following Session Hosts are now pending delete: $($($SessionHostsPendingDelete.VMName) -join ',')"
    }
    elseif ($sessionHostsToReplace.Count -gt 0) {
        Write-HostDetailed "We need to delete $($sessionHostsToReplace.Count) session hosts but we don't have enough session hosts in the host pool."
    }
    else { Write-HostDetailed "We do not need to delete any session hosts" }

    [PSCustomObject]@{
        PossibleDeploymentsCount       = $weCanDeploy
        PossibleSessionHostDeleteCount = $weCanDelete
        SessionHostsPendingDelete      = $sessionHostsPendingDelete
        ExistingSessionHostVMNames     = ([array]$SessionHosts.VMName + [array]$runningDeployments.SessionHostNames) | Select-Object -Unique
    }
}

function Get-SHRRunningDeployment {
    <#
    .SYNOPSIS
        This function gets status of all AVD Session Host Replacer deployments in the target resource group.
    .DESCRIPTION
        The function will fail if there are any failed deployments. These should be cleaned up before automation can resume.
        This behavior is to avoid compounding issues due to failing deployments.
        Ideally, the AVD administrator should setup a notification (alert action) when there are failing deployments. # TODO: Add alert setup.
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string] $ResourceGroupName,

        [Parameter()]
        [string] $DeploymentPrefix = (Get-FunctionConfig _SHRDeploymentPrefix),

        [Parameter()]
        [string] $VMNamesTemplateParameterName = (Get-FunctionConfig _VMNamesTemplateParameterName)
    )

    Write-HostDetailed -Message "Getting deployments for resource group '$ResourceGroupName'"
    $Uri = $ResourceManagerUri + "/subscriptions/" + $SubscriptionId + '/resourceGroups/' + $ResourceGroupName + '/providers/Microsoft.Resources/deployments/?api-version=2021-04-01'
    $deployments = Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri
    $deployments = Get-AzResourceGroupDeployment -ResourceGroupName $ResourceGroupName -ErrorAction Stop
    $deployments = $deployments | Where-Object { $_.DeploymentName -like "$DeploymentPrefix*" }
    Write-HostDetailed -Message "Found $($deployments.Count) deployments marked with $DeploymentPrefix."
    # Check for failed deployments
    $failedDeployments = $deployments | Where-Object { $_.ProvisioningState -eq 'Failed' }
    # Terminate if there are any failed deployments
    if ($failedDeployments) {
        Write-HostDetailed -Err -Message "Found $($failedDeployments.Count) failed deployments. These should be cleaned up before automation can resume."
        throw "Found {0} failed deployments. These should be cleaned up before automation can resume." -f $failedDeployments.Count
    }
    # Check for running deployments
    $runningDeployments = $deployments | Where-Object { $_.ProvisioningState -eq 'Running' }
    Write-HostDetailed -Message "Found $($runningDeployments.Count) running deployments."
    # Check for long running deployments
    $warningThreshold = (Get-Date -AsUTC).AddHours(-2)
    $longRunningDeployments = $runningDeployments | Where-Object { $_.Timestamp -lt $warningThreshold }
    if ($longRunningDeployments) {
        Write-HostDetailed -Warn -Message "Found $($longRunningDeployments.Count) deployments that have been running for more than 2 hours. This could block future deployments"
    }

    # Parse deployment names to get VM name
    $output = foreach ($item in $runningDeployments) {
        $parameters = $item.Parameters | ConvertTo-CaseInsensitiveHashtable
        Write-HostDetailed -Message "Deployment $($item.DeploymentName) is running and deploying: $(($parameters[$VMNamesTemplateParameterName].Value -join ','))"
        [PSCustomObject]@{
            DeploymentName   = $item.DeploymentName
            SessionHostNames = $parameters[$VMNamesTemplateParameterName].Value
            Timestamp        = $item.Timestamp
            Status           = $item.ProvisioningState
        }
    }
    $output
}

function Get-SHRSessionHost {
    [CmdletBinding()]
    param (
        [Parameter()]
        [string] $ResourceGroupName = (Get-FunctionConfig _HostPoolResourceGroupName),
        [Parameter()]
        [string] $HostPoolName = (Get-FunctionConfig _HostPoolName),
        [Parameter()]
        [string] $TagIncludeInAutomation = (Get-FunctionConfig _Tag_IncludeInAutomation),
        [Parameter()]
        [string] $TagDeployTimestamp = (Get-FunctionConfig _Tag_DeployTimestamp),
        [Parameter()]
        [string] $TagPendingDrainTimeStamp = (Get-FunctionConfig _Tag_PendingDrainTimestamp),
        [Parameter()]
        [switch] $FixSessionHostTags,
        [Parameter()]
        [bool] $IncludePreExistingSessionHosts = (Get-FunctionConfig _IncludePreExistingSessionHosts)

    )
    # Get current session hosts
    Write-HostDetailed -Message "Getting current session hosts in host pool $HostPoolName"
    $Uri = $ResourceManagerUri + '/subscriptions/' + $subscriptionId + '/resourceGroups/' + $ResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + 'sessionHosts?api-version=2024-04-03'
    $sessionHosts = Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri | Select-Object Name, ResourceId, Session, AllowNewSession, Status
    Write-HostDetailed -Message "Found $($sessionHosts.Count) session hosts"
    # For each session host, get the VM details
    $result = foreach ($sh in $sessionHosts) {
        Write-HostDetailed -Message "Getting VM details for $($sh.Name)"
        $Uri = $ResourceManagerUri + $sh.ResourceId + '?api-version=2024-03-01'
        $vm = Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri | Select-Object Name, TimeCreated,StorageProfile
        Write-HostDetailed -Message "VM was created on $($vm.TimeCreated)"
        Write-HostDetailed -Message "VM exact version is $($vm.StorageProfile.ImageReference.ExactVersion)"
        Write-HostDetailed -Message 'Getting VM tags'
        $Uri = $ResourceManagerUri + $sh.ResourceId + '/providers/Microsoft.Resources/tags/default?api-version=2021-04-01'
        $vmTags = Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri
        $vmDeployTimeStamp = $vmTags.Properties.TagsProperty[$TagDeployTimestamp]
        try {
            $vmDeployTimeStamp = [DateTime]::Parse($vmDeployTimeStamp)
            Write-HostDetailed -Message "VM has a tag $TagDeployTimestamp with value $vmDeployTimeStamp"
        }
        catch {
            $value = if ($null -eq $vmDeployTimeStamp) { 'null' } else { $vmDeployTimeStamp }
            Write-HostDetailed -Message "VM tag $TagDeployTimestamp with value $value is not a valid date"
            if ($FixSessionHostTags) {
                Write-HostDetailed -Message "Copying VM CreateTime to tag $TagDeployTimestamp with value $($vm.TimeCreated.ToString('o'))"
                $Body = @{
                    operation = 'Merge'
                    properties = @{
                        $TagDeployTimestamp = $vm.TimeCreated.ToString('o')
                    }
                }
                Invoke-AzureRestMethod -AccessToken $AccessToken -Body ($Body | ConvertTo-Json -Depth 10) -Method PATCH -Uri $Uri
            }
            $vmDeployTimeStamp = $vm.TimeCreated
        }
        $vmIncludeInAutomation = $vmTags.Properties.TagsProperty[$TagIncludeInAutomation]
        if ($vmIncludeInAutomation -eq "True") {
            Write-HostDetailed -Message "VM has a tag $TagIncludeInAutomation with value $vmIncludeInAutomation" 
            $vmIncludeInAutomation = $true
        }
        elseif ($vmIncludeInAutomation -eq "False") {
            Write-HostDetailed -Message "VM has a tag $TagIncludeInAutomation with value $vmIncludeInAutomation"
            $vmIncludeInAutomation = $false
        }
        else {
            $value = if ($null -eq $vmIncludeInAutomation) { 'null' } else { $vmIncludeInAutomation }
            Write-HostDetailed -Message "VM tag with $TagIncludeInAutomation value $value is not set to True/False"
            if ($FixSessionHostTags) {
                Write-HostDetailed -Message "Setting tag $TagIncludeInAutomation to $IncludePreExistingSessionHosts"
                $Body = @{
                    operation = 'Merge'
                    properties = @{
                        $TagIncludeInAutomation = $IncludePreExistingSessionHosts
                    }
                }
                Invoke-AzureRestMethod -AccessToken $AccessToken -Body ($Body | ConvertTo-Json -Depth 10) -Method PATCH -Uri $Uri
            }
            $vmIncludeInAutomation = $IncludePreExistingSessionHosts
        }
        $vmPendingDrainTimeStamp = $vmTags.Properties.TagsProperty[$TagPendingDrainTimeStamp]
        try {
            $vmPendingDrainTimeStamp = [DateTime]::Parse($vmPendingDrainTimeStamp)
            Write-OutputDetailed -Message "VM has a tag $TagPendingDrainTimeStamp with value $vmPendingDrainTimeStamp" 
        }
        catch {
            Write-OutputDetailed -Message "VM tag $TagPendingDrainTimeStamp is not set." 
            $vmPendingDrainTimeStamp = $null
        }

        $vmOutput = @{ # We are combining the VM details and SessionHost objects into a single PS Custom Object
            VMName                = $vm.Name
            FQDN                  = $item.Name -replace ".+\/(.+)", '$1'
            DeployTimestamp       = $vmDeployTimeStamp
            IncludeInAutomation   = $vmIncludeInAutomation
            PendingDrainTimeStamp = $vmPendingDrainTimeStamp
            ImageVersion          = $vm.StorageProfile.ImageReference.ExactVersion
        }
        $item.PSObject.Properties.ForEach{ $vmOutput[$_.Name] = $_.Value }
        [PSCustomObject]$vmOutput
    }
    $result
}

function Get-SHRSessionHostParameters {
    [CmdletBinding()]
    param (
        [Parameter()]
        [string] $SessionHostParameters = (Get-FunctionConfig _SessionHostParameters)
    )
    $paramsHash = ConvertFrom-Json $SessionHostParameters -Depth 99 -AsHashtable
    Write-HostDetailed -Message "Session host parameters: $($paramsHash | Out-String)"
    $paramsHash
}

function Get-SHRTemplateSpecVersionResourceId {
    param(
        [Parameter(Mandatory = $true)]
        [string]$ResourceId
    )
    $Uri = $ResourceManagerUri + $ResourceId + '?api-version=2021-04-01'    
    $azResourceType = (Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri).ResourceType
    Write-HostDetailed -Message "Resource type: $azResourceType"
    switch ($azResourceType) {
        'Microsoft.Resources/templateSpecs' {
            # Get resource Id of the latest version of the template spec
            $Uri = $ResourceManagerUri + $ResourceId + '?$expand=versions&api-version=2021-05-01'
            $templateSpecVersions = (Invoke-AzureRestMethod -AccessToken $AccessToken -Method Get -Uri $Uri).Versions
            Write-HostDetailed -Message "Template Spec has $($templateSpecVersions.count) versions"
            $latestVersion = $templateSpecVersions | Sort-Object -Property CreationTime -Descending -Top 1
            Write-HostDetailed -Message "Latest version: $($latestVersion.Name) Created at $($latestVersion.CreationTime.ToString('o')) - Returning Resource Id $($latestVersion.Id)"
            $latestVersion.Id
        }
        'Microsoft.Resources/templateSpecs/versions' {
            # Return the resource Id as is, since supplied value is already a version.
            $ResourceId
        }
        Default {
            throw ("Supplied value has type '{0}' is not a valid Template Spec or Template Spec version resource Id." -f $azResourceType)
        }
    }
}

function Remove-SHRSessionHost {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        $SessionHostsPendingDelete,

        [Parameter()]
        [string] $ResourceGroupName = (Get-FunctionConfig _HostPoolResourceGroupName),

        [Parameter()]
        [string] $HostPoolName = (Get-FunctionConfig _HostPoolName),

        [Parameter()]
        [int] $DrainGracePeriodHours = (Get-FunctionConfig _DrainGracePeriodHours),

        [Parameter()]
        [string] $TagPendingDrainTimeStamp = (Get-FunctionConfig _Tag_PendingDrainTimestamp),

        [Parameter()]
        [string] $TagScalingPlanExclusionTag = (Get-FunctionConfig _Tag_ScalingPlanExclusionTag),

        [Parameter()]
        [bool] $RemoveEntraDevice,

        [Parameter()]
        [bool] $RemoveIntuneDevice
    )

    foreach ($sessionHost in $SessionHostsPendingDelete) {
        # Does the session host currently have sessions?
        # No sessions => Delete + Remove from host pool
        # Is the session host in drain mode?
        # Yes => Is the drain grace period tag old? => Delete + Remove from host pool
        # NO => Set drain mode + Message users + Set tag

        $drainSessionHost = $false
        $deleteSessionHost = $false

        if ($sessionHost.Session -eq 0) {
            #Does the session host currently have sessions?
            # No sessions => Delete + Remove from host pool
            Write-HostDetailed -Message "Session host $($sessionHost.FQDN) has no sessions." 
            $deleteSessionHost = $true
        }
        else {
            Write-HostDetailed -Message "Session host $($sessionHost.FQDN) has $($sessionHost.Session) sessions." 
            if (-Not $sessionHost.AllowNewSession) {
                # Is the session host in drain mode?
                Write-HostDetailed -Message "Session host $($sessionHost.FQDN) is in drain mode."
                if ($sessionHost.PendingDrainTimeStamp) {
                    #Session host has a drain timestamp
                    Write-HostDetailed -Message "Session Host $($sessionHost.FQDN) drain timestamp is $($sessionHost.PendingDrainTimeStamp)"
                    $maxDrainGracePeriodDate = $sessionHost.PendingDrainTimeStamp.AddHours($DrainGracePeriodHours)
                    Write-HostDetailed -Message "Session Host $($sessionHost.FQDN) can stay in grace period until $($maxDrainGracePeriodDate.ToUniversalTime().ToString('o'))" 
                    if ($maxDrainGracePeriodDate -lt (Get-Date)) {
                        Write-HostDetailed -Message "Session Host $($sessionHost.FQDN) has exceeded the drain grace period."
                        $deleteSessionHost = $true
                    }
                    else {
                        Write-HostDetailed -Message "Session Host $($sessionHost.FQDN) has not exceeded the drain grace period."
                    }
                }
                else {
                    Write-HostDetailed -Message "Session Host $($sessionHost.FQDN) does not have a drain timestamp."
                    $drainSessionHost = $true
                }
            }
            else {
                Write-HostDetailed -Message "Session host $($sessionHost.Name) in not in drain mode. Turning on drain mode." 
                $drainSessionHost = $true
            }
        }

        if ($drainSessionHost) {
            Write-HostDetailed -Message 'Turning on drain mode.'
            $Uri = $ResourceManagerUri + '/subscriptions/' + $SubscriptionId + + '/resourceGroups/' + $ResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts/' + $sessionHost.FQDN + '?api-version=2023-09-05'
            Invoke-AzureRestMethod `
                -AccessToken $AccessToken `
                -Body (@{properties = @{allowNewSession = $false}} | ConvertTo-Json) `
                -Method 'PATCH' `
                -Uri $Uri
            $drainTimestamp = (Get-Date).ToUniversalTime().ToString('o')
            Write-HostDetailed -Message "Setting drain timestamp on tag $TagPendingDrainTimeStamp to $drainTimestamp."
            $Uri = $ResourceManagerUri + $sessionHost.ResourceId + '/providers/Microsoft.Resources/tags/default?api-version=2021-04-01'
            $Body = @{
                operation = 'Merge'
                properties = @{
                    $TagPendingDrainTimeStamp = $drainTimestamp
                }
            }
            Invoke-AzureRestMethod -AccessToken $AccessToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $Uri
            
            if ($TagScalingPlanExclusionTag -ne ' ') {
                # This is string with a single space.
                Write-HostDetailed -Message "Setting scaling plan exclusion tag $TagScalingPlanExclusionTag to $true."
                $Body = @{
                    operation = 'Merge'
                    properties = @{
                        $TagScalingPlanExclusionTag = $true
                    }
                }
                Invoke-AzureRestMethod -AccessToken $AccessToken -Body ($Body | ConvertTo-Json -Depth 5) -Method PATCH -Uri $Uri
            }

            Write-HostDetailed -Message 'Notifying Users'
            Send-SHRDrainNotification -SessionHostName ($sessionHost.FQDN)
        }

        if ($deleteSessionHost) {
            Write-HostDetailed -Message "Deleting session host $($SessionHost.Name)..."
            if ($RemoveEntraDevice) {
                Write-HostDetailed -Message 'Deleting device from Entra ID'
                Remove-SHRSessionHostEntraDevice -VMName $sessionHost.VMName
            }
            if ($RemoveIntuneDevice) {
                Write-HostDetailed -Message 'Deleting device from Intune'
                Remove-SHRSessionHostIntuneDevice -VMName $sessionHost.VMName
            }
            Write-HostDetailed -Message "Removing Session Host from Host Pool $HostPoolName"
            $Uri = $ResourceManagerUri + '/subscriptions/' + $SubscriptionId + '/resourceGroups/' + $ResourceGroupName + '/providers/Microsoft.DesktopVirtualization/hostPools/' + $HostPoolName + '/sessionHosts/' + $sessionHost.FQDN + '?api-version=2024-04-03'
            Invoke-AzureRestMethod -AccessToken $AccessToken -Method DELETE -Uri $Uri            
            Write-HostDetailed -Message "Deleting VM: $($sessionHost.ResourceId)..."
            $Uri = $ResourceManagerUri + $sessionHost.ResourceId + '?forceDeletion=true&api-version=2024-07-01'
            Invoke-AzureRestMethod -AccessToken $AccessToken -Method 'DELETE' -Uri $Uri
            # We are not deleting Disk and NIC as the template should mark the delete option for these resources.
        }
    }
}

function Remove-SHRSessionHostEntraDevice {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        $GraphEndpoint = $env:GraphEndpoint,
        [Parameter(Mandatory = $true)]
        $GraphToken,
        [Parameter(Mandatory = $true)]
        [string] $VMName
    )
    $Headers = @{
        'Authorization' = "Bearer $GraphToken"
    }
    $Device = Invoke-RestMethod -Method Get -Uri $GraphEndpoint + '/v1.0/devices?$filter=equals(displayName,' + $VMName + ')' -Headers $Headers
    If ($Device) {
        $Id = $Device.id
        Write-HostDetailed -Message "Removing device from Entra ID for VM $VMName"
        Invoke-RestMethod -Method Delete -Uri $GraphEndpoint + '/v1.0/devices/' + $Id -Headers $Headers
    }    
}

function Remove-SHRSessionHostIntuneDevice {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $false)]
        $GraphEndpoint = $env:GraphEndpoint,
        [Parameter(Mandatory = $true)]
        $GraphToken,
        [Parameter(Mandatory = $true)]
        [string] $VMName
    )
    $Headers = @{
        'Authorization' = "Bearer $GraphToken"
    }
    $Device = Invoke-RestMethod -Method Get -Uri $GraphEndpoint + '/v1.0/deviceManagement/managedDevices?$filter=equals(displayName,' + $VMName + ')' -Headers $Headers
    If ($Device) {
        $Id = $Device.id
        Write-HostDetailed -Message "Removing device from Intune for VM $VMName"
        Invoke-RestMethod -Method Delete -Uri $GraphEndpoint + '/v1.0/deviceManagement/managedDevices/' + $Id -Headers $Headers
    }
}

function Write-HostDetailed {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $false)]
        [switch]$Err,

        [Parameter(Mandatory = $true, Position = 0)]
        [string]$Message,

        [Parameter(Mandatory = $false)]
        [switch]$Warn
    )

    [string]$MessageTimeStamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
    $Message = "[$($MyInvocation.ScriptLineNumber)] $Message"
    [string]$WriteMessage = "[$($MessageTimeStamp)] $Message"

    if ($Err)
    {
        Write-Error $WriteMessage
        $Message = "ERROR: $Message"
    }
    elseif ($Warn)
    {
        Write-Warning $WriteMessage
        $Message = "WARN: $Message"
    }
    else 
    {
        Write-Host $WriteMessage
    }
}



## Can get environment dynamically: https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/bicep-functions-deployment#environment
## https://learn.microsoft.com/en-us/graph/deployments
## Get a graph token against the endpoints above then follow the instructions below.

## Entra: 
## https://learn.microsoft.com/en-us/graph/api/device-list?view=graph-rest-1.0&tabs=http
## https://learn.microsoft.com/en-us/graph/api/device-delete?view=graph-rest-1.0&tabs=http
## Intune:
## https://learn.microsoft.com/en-us/graph/api/intune-devices-manageddevice-list?view=graph-rest-1.0
## DELETE https://graph.microsoft.com/v1.0/devices/{id}